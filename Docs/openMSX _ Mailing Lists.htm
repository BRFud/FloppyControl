<!DOCTYPE html>
<!-- Server: sfn-web-9 -->
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]>-->
<html class="js flexbox canvas canvastext no-touch geolocation postmessage no-websqldatabase no-indexeddb hashchange history draganddrop websockets rgba hsla multiplebgs backgroundsize borderimage borderradius boxshadow textshadow opacity cssanimations csscolumns cssgradients no-cssreflections csstransforms csstransforms3d csstransitions fontface video audio localstorage sessionstorage webworkers applicationcache svg inlinesvg smil svgclippaths js canvas canvastext" lang="en"><!--<![endif]--><head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>openMSX / Mailing Lists</title>
    
<meta id="project_name" name="project_name" content="openmsx">
<script src="openMSX%20_%20Mailing%20Lists_files/gpt.js" type="text/javascript" async=""></script><script src="openMSX%20_%20Mailing%20Lists_files/analytics.js" async=""></script><script src="openMSX%20_%20Mailing%20Lists_files/modernizr.js"></script>
<!--[if lt IE 7 ]>
  <script src="http://a.fsdn.com/allura/nf/1450288126/_ew_/theme/sftheme/js/sftheme/dd_belatedpng.js"></script>
  <script> DD_belatedPNG.fix('img, .png_bg'); //fix any <img> or .png_bg background-images </script>
<![endif]-->
<link href="openMSX%20_%20Mailing%20Lists_files/css_002.css" rel="stylesheet" type="text/css">
    <script type="text/javascript">
        /*jslint onevar: false, nomen: false, evil: true, css: true, plusplus: false, white: false, forin: true, on: true, immed: false */
        /*global confirm, alert, unescape, window, jQuery, $, net, COMSCORE */
    </script>
    
        <!-- ew:head_css -->

    
        <link rel="stylesheet" type="text/css" href="openMSX%20_%20Mailing%20Lists_files/css_003.css">
    
        <link rel="stylesheet" type="text/css" href="openMSX%20_%20Mailing%20Lists_files/font-awesome.css">
    
        <link rel="stylesheet" type="text/css" href="openMSX%20_%20Mailing%20Lists_files/forge.css">
    
        <link rel="stylesheet" type="text/css" href="openMSX%20_%20Mailing%20Lists_files/css.css">
    
        
<!-- /ew:head_css -->

    
    
        <!-- ew:head_js -->

    
        <script type="text/javascript" src="openMSX%20_%20Mailing%20Lists_files/js"></script>
    
        
<!-- /ew:head_js -->

    

    
        <style type="text/css">
            #page-body.project---init-- #top_nav { display: none; }

#page-body.project---init-- #nav_menu_holder { display: none; margin-bottom: 0; }

#page-body.project---init-- #content_base {margin-top: 0; }
        </style>
    
    
    <style>.XDluraaudGGGqmCnLUYfISXO {
        display: none
    }</style>

    
    
    
    


<script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    function _add_tracking(prefix, tracking_id) {
        ga('create', tracking_id, {cookieDomain: 'auto', 'name': prefix});
        
        ga(prefix+'.set', 'dimension9', 'openmsx');
        ga(prefix+'.set', 'dimension10', 'mailman');
        ga(prefix+'.send', 'pageview');
    }
      _add_tracking('sfnt1', 'UA-32013-6');
      _add_tracking('sfnt2', 'UA-36130941-1');
    
</script>
<script async="" src="openMSX%20_%20Mailing%20Lists_files/pubads_impl_78.js"></script></head>

<body id="forge">

    
        <!-- ew:body_top_js -->

    
        
<!-- /ew:body_top_js -->

    


<header id="site-header">
    <div class="wrapper">
        <a href="http://sourceforge.net/" class="logo">
            <span>SourceForge</span>
        </a>
        
        <form method="get" action="/directory/">
            <input tabindex="1" id="words" name="q" placeholder="Search" type="text">
        </form>
        
        <!--Switch to {language}-->
        <nav id="nav-site">
            <a href="http://sourceforge.net/directory/" title="Browse our software.">Browse</a>
            <a href="http://sourceforge.net/directory/enterprise" title="Browse our Enterprise software.">Enterprise</a>
            <a href="http://sourceforge.net/blog/" title="Read the latest news from the SF HQ.">Blog</a>
            <a href="http://sourceforge.net/jobs?source=header" title="Search 80k+ tech jobs.">Jobs</a>
            <a href="http://deals.sourceforge.net/?utm_source=sourceforge&amp;utm_medium=navbar&amp;utm_campaign=homepage" title="Discover and Save on the Best Gear, Gadgets, and Software" class="featured-link" target="_blank">Deals</a>
            <a href="http://sourceforge.net/support" title="Contact us for help and feedback.">Help</a>
        </nav>
        <nav id="nav-account">
            
              <div class="logged_out">
                <a href="http://sourceforge.net/auth/">Log In</a>
                <span>or</span>
                <a href="https://sourceforge.net/user/registration/">Join</a>
              </div>
            
        </nav>
        
    </div>
</header>
<header id="site-sec-header">
    <div class="wrapper">
        <nav id="nav-hubs">
            <h4>Solution Centers</h4>
            <a href="http://goparallel.sourceforge.net/">Go Parallel</a>
        </nav>
        <nav id="nav-collateral">
            <a href="http://library.slashdotmedia.com/?source=sfnet_header">Resources</a>
            
            <a href="">Newsletters</a>
            
        </nav>
    </div>
</header>

    
    
    

<section id="page-body" class=" neighborhood-Projects project-openmsx mountpoint-mailman">
    <div id="nav_menu_holder">
        
            



    
    
    
    
        
    <script type="text/javascript">
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
        (function() {

            var gads = document.createElement("script");
            gads.async = true;
            gads.type = "text/javascript";
            var useSSL = "https:" == document.location.protocol;
            gads.src = (useSSL ? "https:" : "http:") + "//www.googletagservices.com/tag/js/gpt.js";
            var node =document.getElementsByTagName("script")[0];
            node.parentNode.insertBefore(gads, node);
        })();

        googletag.cmd.push(function () {
            var leader_slot = googletag.defineSlot("/4140/ostg.sourceforge/SF_Mailarchive_728x90_A", [728, 90], "div-gpt-ad-1394299123435-0");
            leader_slot.addService(googletag.pubads())
                .setTargeting('shortname', 'openmsx')
                .setTargeting('page_type', 'mailman')
                .setTargeting('sz', '728x90')
                .setTargeting('dc_ref', 'http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203');

            googletag.pubads().enableAsyncRendering();
            googletag.pubads().collapseEmptyDivs();
            googletag.enableServices();
        });
    </script>

    <div id="div-gpt-ad-1394299123435-0" style="margin: 0 auto 5px auto; width:728px">
        <script type="text/javascript">
            googletag.cmd.push(function() { googletag.display('div-gpt-ad-1394299123435-0'); });
        </script><iframe class="sexqyzlwitnwokuyyoxr" style="visibility: hidden; display: none;" src="http://tpc.googlesyndication.com/safeframe/1-0-2/html/container.html"></iframe>
    <div style="border: 0pt none;" id="google_ads_iframe_/4140/ostg.sourceforge/SF_Mailarchive_728x90_A_0__container__"><iframe src="javascript:&quot;<html><body style='background:transparent'></body></html>&quot;" style="border: 0px none; vertical-align: bottom;" marginheight="0" marginwidth="0" scrolling="no" name="google_ads_iframe_/4140/ostg.sourceforge/SF_Mailarchive_728x90_A_0" id="google_ads_iframe_/4140/ostg.sourceforge/SF_Mailarchive_728x90_A_0" frameborder="0" height="90" width="728"></iframe></div><iframe src="javascript:&quot;<html><body style='background:transparent'></body></html>&quot;" style="border: 0px none; vertical-align: bottom; visibility: hidden; display: none;" marginheight="0" marginwidth="0" scrolling="no" name="google_ads_iframe_/4140/ostg.sourceforge/SF_Mailarchive_728x90_A_0__hidden__" id="google_ads_iframe_/4140/ostg.sourceforge/SF_Mailarchive_728x90_A_0__hidden__" frameborder="0" height="0" width="0"></iframe></div>
    
    <nav id="breadcrumbs">
        <ul>
            <li itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb"><a itemprop="url" href="http://sourceforge.net/">Home</a></li>
            <li itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb"><a itemprop="url" href="http://sourceforge.net/directory">Browse</a></li>
            
            
                
            
            
            
                <li itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb"><a itemprop="url" href="http://sourceforge.net/p/">Projects</a></li>
                
            
            
                <li itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb"><a itemprop="url" href="http://sourceforge.net/p/openmsx/">openMSX</a></li>
                
            
            
                <li itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb">Mailing Lists</li>
                
            
        </ul>
    </nav>
    
    
    
  
    
    <h1 class="project_title">
        <a href="http://sourceforge.net/p/openmsx/" class="project_link">openMSX</a>
    </h1>
    
    
    
    <h2 class="project_summary">
        
    </h2>
    
    <div class="brought-by">
        Brought to you by:
        
        
            
                <a href="http://sourceforge.net/u/andete/">andete</a>,
            
            
                <a href="http://sourceforge.net/u/m9710797/">m9710797</a>,
            
            
                <a href="http://sourceforge.net/u/manuelbi/">manuelbi</a>,
            
            
                <a href="http://sourceforge.net/u/mthuurne/">mthuurne</a>,
            
            
                <a href="http://sourceforge.net/u/turbor/">turbor</a>
            </div>
    

        
    </div>
    <div id="top_nav" class="">
        
            
<ul class="dropdown">
  
    <li class="">
        <a href="http://sourceforge.net/projects/openmsx/" class="tool-summary">
            Summary
        </a>
        
        
    </li>
	
    <li class="">
        <a href="http://sourceforge.net/projects/openmsx/files/" class="tool-files">
            Files
        </a>
        
        
    </li>
	
    <li class="">
        <a href="http://sourceforge.net/projects/openmsx/reviews" class="tool-reviews">
            Reviews
        </a>
        
        
    </li>
	
    <li class="">
        <a href="http://sourceforge.net/projects/openmsx/support" class="tool-support">
            Support
        </a>
        
        
    </li>
	
    <li class="selected">
        <a href="http://sourceforge.net/p/openmsx/mailman/" class="tool-mailman">
            Mailing Lists
        </a>
        
        
    </li>
	
    <li class="">
        <a href="http://sourceforge.net/p/openmsx/_list/tickets" class="tool-tickets">
            Tickets ▾
        </a>
        
        
            <ul>
                
                    <li class=""><a href="http://sourceforge.net/p/openmsx/feature-requests/">Feature Requests (DISABLED)</a></li>
                
                    <li class=""><a href="http://sourceforge.net/p/openmsx/patches/">Patches (DISABLED)</a></li>
                
                    <li class=""><a href="http://sourceforge.net/p/openmsx/bugs/">Bugs (DISABLED)</a></li>
                
                    <li class=""><a href="http://sourceforge.net/p/openmsx/support-requests/">Support Requests (DISABLED)</a></li>
                
            </ul>
        
    </li>
	
    <li class="">
        <a href="http://sourceforge.net/p/openmsx/news/" class="tool-blog">
            News
        </a>
        
        
    </li>
	
    <li class="">
        <a href="http://sourceforge.net/p/openmsx/discussion/" class="tool-discussion">
            Discussion (DISABLED)
        </a>
        
        
    </li>
	
    <li class="">
        <a href="http://sourceforge.net/p/openmsx/_list/git" class="tool-git">
            Git ▾
        </a>
        
        
            <ul>
                
                    <li class=""><a href="http://sourceforge.net/p/openmsx/openmsx/">Code (openMSX) (DISABLED)</a></li>
                
                    <li class=""><a href="http://sourceforge.net/p/openmsx/htdocs/">Code (website) (DISABLED)</a></li>
                
                    <li class=""><a href="http://sourceforge.net/p/openmsx/msxtar/">Code (msxtar) (DISABLED)</a></li>
                
                    <li class=""><a href="http://sourceforge.net/p/openmsx/webscripts/">Code (webscripts) (DISABLED)</a></li>
                
                    <li class=""><a href="http://sourceforge.net/p/openmsx/catapult/">Code (Catapult) (DISABLED)</a></li>
                
                    <li class=""><a href="http://sourceforge.net/p/openmsx/debugger/">Code (debugger) (DISABLED)</a></li>
                
                    <li class=""><a href="http://sourceforge.net/p/openmsx/package-windows/">Code (package-windows) (DISABLED)</a></li>
                
                    <li class=""><a href="http://sourceforge.net/p/openmsx/wxcatapult/">Code (wxCatapult) (DISABLED)</a></li>
                
            </ul>
        
    </li>
	
    <li class="">
        <a href="http://sourceforge.net/p/openmsx/code/" class="tool-svn">
            Old SVN repo (INACTIVE)
        </a>
        
        
    </li>
	
</ul>

        
    </div>
    <div id="content_base">
        
            
                
                    


<div id="sidebar">
  
    <form id="search" method="GET" action="/p/openmsx/mailman/search/">
      <input tabindex="2" name="q" title="Search Mailing Lists" placeholder="Search Mailing Lists" type="text">
    </form>
  
    
    
      
      
        
    
      <ul class="sidebarmenu">
      
    
  <li>
      
        <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-bugs/">
      
      <span>openmsx-bugs</span>
      </a>
  </li>
  
      
        
    
  <li class="active">
      
        <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/">
      
      <span>openmsx-commits</span>
      </a>
  </li>
  
      
        
    
  <li>
      
        <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-devel/">
      
      <span>openmsx-devel</span>
      </a>
  </li>
  
      
        
    
  <li>
      
        <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-user/">
      
      <span>openmsx-user</span>
      </a>
  </li>
  
      
    
    
      </ul>
      
    
    
    
</div>
                
                
            
            
                
            
            <div class="grid-20 pad">
                <h2 class="dark title">
  openmsx-commits
  
    — openMSX CVS commit mail
  

                    <!-- actions -->
                    <small>
                        
                    </small>
                    <!-- /actions -->
                </h2>
                
                <div>
                    
                    
  

  <p>You can subscribe to this list <a href="http://lists.sourceforge.net/lists/listinfo/openmsx-commits">here</a>.</p>
  
  
  <table class="calendar-month">
    
      <tbody><tr>
        <th>2001</th>
        
        
        
        <td>
          <sub>Jan</sub>
          <br>
          
          
            &nbsp;
          
        </td>
        
        
        
        <td>
          <sub>Feb</sub>
          <br>
          
          
            &nbsp;
          
        </td>
        
        
        
        <td>
          <sub>Mar</sub>
          <br>
          
          
            &nbsp;
          
        </td>
        
        
        
        <td>
          <sub>Apr</sub>
          <br>
          
          
            &nbsp;
          
        </td>
        
        
        
        <td>
          <sub>May</sub>
          <br>
          
          
            &nbsp;
          
        </td>
        
        
        
        <td>
          <sub>Jun</sub>
          <br>
          
          
            &nbsp;
          
        </td>
        
        
        
        <td>
          <sub>Jul</sub>
          <br>
          
          
            &nbsp;
          
        </td>
        
        
        
        <td>
          <sub>Aug</sub>
          <br>
          
          
            &nbsp;
          
        </td>
        
        
        
        <td>
          <sub>Sep</sub>
          <br>
          
          
            &nbsp;
          
        </td>
        
        
        
        <td>
          <sub>Oct</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200110">(6)</a>
          
        </td>
        
        
        
        <td>
          <sub>Nov</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200111">(80)</a>
          
        </td>
        
        
        
        <td>
          <sub>Dec</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200112">(239)</a>
          
        </td>
        
      </tr>
    
      <tr>
        <th>2002</th>
        
        
        
        <td>
          <sub>Jan</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200201">(168)</a>
          
        </td>
        
        
        
        <td>
          <sub>Feb</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200202">(177)</a>
          
        </td>
        
        
        
        <td>
          <sub>Mar</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200203">(233)</a>
          
        </td>
        
        
        
        <td>
          <sub>Apr</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200204">(172)</a>
          
        </td>
        
        
        
        <td>
          <sub>May</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200205">(74)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jun</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200206">(107)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jul</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200207">(77)</a>
          
        </td>
        
        
        
        <td>
          <sub>Aug</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200208">(133)</a>
          
        </td>
        
        
        
        <td>
          <sub>Sep</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200209">(85)</a>
          
        </td>
        
        
        
        <td>
          <sub>Oct</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200210">(108)</a>
          
        </td>
        
        
        
        <td>
          <sub>Nov</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200211">(87)</a>
          
        </td>
        
        
        
        <td>
          <sub>Dec</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200212">(96)</a>
          
        </td>
        
      </tr>
    
      <tr>
        <th>2003</th>
        
        
        
        <td>
          <sub>Jan</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200301">(218)</a>
          
        </td>
        
        
        
        <td>
          <sub>Feb</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200302">(134)</a>
          
        </td>
        
        
        
        <td>
          <sub>Mar</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200303">(273)</a>
          
        </td>
        
        
        
        <td>
          <sub>Apr</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200304">(127)</a>
          
        </td>
        
        
        
        <td>
          <sub>May</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200305">(304)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jun</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200306">(498)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jul</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200307">(231)</a>
          
        </td>
        
        
        
        <td>
          <sub>Aug</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200308">(301)</a>
          
        </td>
        
        
        
        <td>
          <sub>Sep</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200309">(181)</a>
          
        </td>
        
        
        
        <td>
          <sub>Oct</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200310">(258)</a>
          
        </td>
        
        
        
        <td>
          <sub>Nov</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200311">(229)</a>
          
        </td>
        
        
        
        <td>
          <sub>Dec</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200312">(207)</a>
          
        </td>
        
      </tr>
    
      <tr>
        <th>2004</th>
        
        
        
        <td>
          <sub>Jan</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200401">(169)</a>
          
        </td>
        
        
        
        <td>
          <sub>Feb</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200402">(181)</a>
          
        </td>
        
        
        
        <td>
          <sub>Mar</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200403">(255)</a>
          
        </td>
        
        
        
        <td>
          <sub>Apr</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200404">(468)</a>
          
        </td>
        
        
        
        <td>
          <sub>May</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200405">(467)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jun</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200406">(241)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jul</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200407">(146)</a>
          
        </td>
        
        
        
        <td>
          <sub>Aug</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200408">(157)</a>
          
        </td>
        
        
        
        <td>
          <sub>Sep</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200409">(260)</a>
          
        </td>
        
        
        
        <td>
          <sub>Oct</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200410">(656)</a>
          
        </td>
        
        
        
        <td>
          <sub>Nov</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200411">(148)</a>
          
        </td>
        
        
        
        <td>
          <sub>Dec</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200412">(199)</a>
          
        </td>
        
      </tr>
    
      <tr>
        <th>2005</th>
        
        
        
        <td>
          <sub>Jan</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200501">(257)</a>
          
        </td>
        
        
        
        <td>
          <sub>Feb</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200502">(250)</a>
          
        </td>
        
        
        
        <td>
          <sub>Mar</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200503">(206)</a>
          
        </td>
        
        
        
        <td>
          <sub>Apr</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200504">(102)</a>
          
        </td>
        
        
        
        <td>
          <sub>May</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200505">(215)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jun</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200506">(251)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jul</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200507">(104)</a>
          
        </td>
        
        
        
        <td>
          <sub>Aug</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200508">(116)</a>
          
        </td>
        
        
        
        <td>
          <sub>Sep</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200509">(176)</a>
          
        </td>
        
        
        
        <td>
          <sub>Oct</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200510">(154)</a>
          
        </td>
        
        
        
        <td>
          <sub>Nov</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200511">(281)</a>
          
        </td>
        
        
        
        <td>
          <sub>Dec</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200512">(212)</a>
          
        </td>
        
      </tr>
    
      <tr>
        <th>2006</th>
        
        
        
        <td>
          <sub>Jan</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200601">(255)</a>
          
        </td>
        
        
        
        <td>
          <sub>Feb</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200602">(157)</a>
          
        </td>
        
        
        
        <td>
          <sub>Mar</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200603">(145)</a>
          
        </td>
        
        
        
        <td>
          <sub>Apr</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200604">(179)</a>
          
        </td>
        
        
        
        <td>
          <sub>May</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200605">(170)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jun</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200606">(96)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jul</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200607">(153)</a>
          
        </td>
        
        
        
        <td>
          <sub>Aug</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200608">(106)</a>
          
        </td>
        
        
        
        <td>
          <sub>Sep</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200609">(222)</a>
          
        </td>
        
        
        
        <td>
          <sub>Oct</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200610">(94)</a>
          
        </td>
        
        
        
        <td>
          <sub>Nov</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200611">(88)</a>
          
        </td>
        
        
        
        <td>
          <sub>Dec</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200612">(66)</a>
          
        </td>
        
      </tr>
    
      <tr>
        <th>2007</th>
        
        
        
        <td>
          <sub>Jan</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200701">(59)</a>
          
        </td>
        
        
        
        <td>
          <sub>Feb</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200702">(105)</a>
          
        </td>
        
        
        
        <td>
          <sub>Mar</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200703">(114)</a>
          
        </td>
        
        
        
        <td>
          <sub>Apr</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200704">(193)</a>
          
        </td>
        
        
        
        <td>
          <sub>May</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200705">(145)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jun</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200706">(120)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jul</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200707">(79)</a>
          
        </td>
        
        
        
        <td>
          <sub>Aug</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200708">(114)</a>
          
        </td>
        
        
        
        <td>
          <sub>Sep</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200709">(234)</a>
          
        </td>
        
        
        
        <td>
          <sub>Oct</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200710">(105)</a>
          
        </td>
        
        
        
        <td>
          <sub>Nov</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200711">(113)</a>
          
        </td>
        
        
        
        <td>
          <sub>Dec</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200712">(163)</a>
          
        </td>
        
      </tr>
    
      <tr>
        <th>2008</th>
        
        
        
        <td>
          <sub>Jan</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200801">(96)</a>
          
        </td>
        
        
        
        <td>
          <sub>Feb</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200802">(35)</a>
          
        </td>
        
        
        
        <td>
          <sub>Mar</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200803">(105)</a>
          
        </td>
        
        
        
        <td>
          <sub>Apr</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200804">(64)</a>
          
        </td>
        
        
        
        <td>
          <sub>May</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200805">(85)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jun</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200806">(92)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jul</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200807">(139)</a>
          
        </td>
        
        
        
        <td>
          <sub>Aug</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200808">(81)</a>
          
        </td>
        
        
        
        <td>
          <sub>Sep</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200809">(84)</a>
          
        </td>
        
        
        
        <td>
          <sub>Oct</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200810">(55)</a>
          
        </td>
        
        
        
        <td>
          <sub>Nov</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200811">(45)</a>
          
        </td>
        
        
        
        <td>
          <sub>Dec</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200812">(56)</a>
          
        </td>
        
      </tr>
    
      <tr>
        <th>2009</th>
        
        
        
        <td>
          <sub>Jan</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200901">(110)</a>
          
        </td>
        
        
        
        <td>
          <sub>Feb</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200902">(184)</a>
          
        </td>
        
        
        
        <td>
          <sub>Mar</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200903">(150)</a>
          
        </td>
        
        
        
        <td>
          <sub>Apr</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200904">(235)</a>
          
        </td>
        
        
        
        <td>
          <sub>May</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200905">(267)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jun</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200906">(169)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jul</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200907">(180)</a>
          
        </td>
        
        
        
        <td>
          <sub>Aug</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200908">(141)</a>
          
        </td>
        
        
        
        <td>
          <sub>Sep</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200909">(191)</a>
          
        </td>
        
        
        
        <td>
          <sub>Oct</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200910">(103)</a>
          
        </td>
        
        
        
        <td>
          <sub>Nov</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200911">(118)</a>
          
        </td>
        
        
        
        <td>
          <sub>Dec</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=200912">(225)</a>
          
        </td>
        
      </tr>
    
      <tr>
        <th>2010</th>
        
        
        
        <td>
          <sub>Jan</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201001">(149)</a>
          
        </td>
        
        
        
        <td>
          <sub>Feb</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201002">(90)</a>
          
        </td>
        
        
        
        <td>
          <sub>Mar</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201003">(62)</a>
          
        </td>
        
        
        
        <td>
          <sub>Apr</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201004">(46)</a>
          
        </td>
        
        
        
        <td>
          <sub>May</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201005">(30)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jun</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201006">(110)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jul</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201007">(48)</a>
          
        </td>
        
        
        
        <td>
          <sub>Aug</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201008">(45)</a>
          
        </td>
        
        
        
        <td>
          <sub>Sep</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201009">(37)</a>
          
        </td>
        
        
        
        <td>
          <sub>Oct</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201010">(36)</a>
          
        </td>
        
        
        
        <td>
          <sub>Nov</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201011">(48)</a>
          
        </td>
        
        
        
        <td>
          <sub>Dec</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201012">(81)</a>
          
        </td>
        
      </tr>
    
      <tr>
        <th>2011</th>
        
        
        
        <td>
          <sub>Jan</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201101">(75)</a>
          
        </td>
        
        
        
        <td>
          <sub>Feb</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201102">(39)</a>
          
        </td>
        
        
        
        <td>
          <sub>Mar</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201103">(105)</a>
          
        </td>
        
        
        
        <td>
          <sub>Apr</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201104">(67)</a>
          
        </td>
        
        
        
        <td>
          <sub>May</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201105">(31)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jun</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201106">(19)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jul</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201107">(16)</a>
          
        </td>
        
        
        
        <td>
          <sub>Aug</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201108">(43)</a>
          
        </td>
        
        
        
        <td>
          <sub>Sep</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201109">(36)</a>
          
        </td>
        
        
        
        <td>
          <sub>Oct</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201110">(15)</a>
          
        </td>
        
        
        
        <td>
          <sub>Nov</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201111">(9)</a>
          
        </td>
        
        
        
        <td>
          <sub>Dec</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201112">(24)</a>
          
        </td>
        
      </tr>
    
      <tr>
        <th>2012</th>
        
        
        
        <td>
          <sub>Jan</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201201">(52)</a>
          
        </td>
        
        
        
        <td>
          <sub>Feb</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201202">(34)</a>
          
        </td>
        
        
        
        <td class="active">
          <sub>Mar</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203">(34)</a>
          
        </td>
        
        
        
        <td>
          <sub>Apr</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201204">(35)</a>
          
        </td>
        
        
        
        <td>
          <sub>May</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201205">(81)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jun</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201206">(114)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jul</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201207">(77)</a>
          
        </td>
        
        
        
        <td>
          <sub>Aug</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201208">(68)</a>
          
        </td>
        
        
        
        <td>
          <sub>Sep</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201209">(57)</a>
          
        </td>
        
        
        
        <td>
          <sub>Oct</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201210">(30)</a>
          
        </td>
        
        
        
        <td>
          <sub>Nov</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201211">(75)</a>
          
        </td>
        
        
        
        <td>
          <sub>Dec</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201212">(116)</a>
          
        </td>
        
      </tr>
    
      <tr>
        <th>2013</th>
        
        
        
        <td>
          <sub>Jan</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201301">(30)</a>
          
        </td>
        
        
        
        <td>
          <sub>Feb</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201302">(42)</a>
          
        </td>
        
        
        
        <td>
          <sub>Mar</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201303">(30)</a>
          
        </td>
        
        
        
        <td>
          <sub>Apr</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201304">(45)</a>
          
        </td>
        
        
        
        <td>
          <sub>May</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201305">(49)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jun</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201306">(29)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jul</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201307">(63)</a>
          
        </td>
        
        
        
        <td>
          <sub>Aug</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201308">(62)</a>
          
        </td>
        
        
        
        <td>
          <sub>Sep</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201309">(21)</a>
          
        </td>
        
        
        
        <td>
          <sub>Oct</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201310">(21)</a>
          
        </td>
        
        
        
        <td>
          <sub>Nov</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201311">(58)</a>
          
        </td>
        
        
        
        <td>
          <sub>Dec</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201312">(32)</a>
          
        </td>
        
      </tr>
    
      <tr>
        <th>2014</th>
        
        
        
        <td>
          <sub>Jan</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201401">(86)</a>
          
        </td>
        
        
        
        <td>
          <sub>Feb</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201402">(48)</a>
          
        </td>
        
        
        
        <td>
          <sub>Mar</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201403">(21)</a>
          
        </td>
        
        
        
        <td>
          <sub>Apr</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201404">(20)</a>
          
        </td>
        
        
        
        <td>
          <sub>May</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201405">(68)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jun</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201406">(42)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jul</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201407">(33)</a>
          
        </td>
        
        
        
        <td>
          <sub>Aug</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201408">(28)</a>
          
        </td>
        
        
        
        <td>
          <sub>Sep</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201409">(33)</a>
          
        </td>
        
        
        
        <td>
          <sub>Oct</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201410">(23)</a>
          
        </td>
        
        
        
        <td>
          <sub>Nov</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201411">(43)</a>
          
        </td>
        
        
        
        <td>
          <sub>Dec</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201412">(11)</a>
          
        </td>
        
      </tr>
    
      <tr>
        <th>2015</th>
        
        
        
        <td>
          <sub>Jan</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201501">(13)</a>
          
        </td>
        
        
        
        <td>
          <sub>Feb</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201502">(13)</a>
          
        </td>
        
        
        
        <td>
          <sub>Mar</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201503">(13)</a>
          
        </td>
        
        
        
        <td>
          <sub>Apr</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201504">(12)</a>
          
        </td>
        
        
        
        <td>
          <sub>May</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201505">(50)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jun</sub>
          <br>
          
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201506">(10)</a>
          
        </td>
        
        
        
        <td>
          <sub>Jul</sub>
          <br>
          
          
            &nbsp;
          
        </td>
        
        
        
        <td>
          <sub>Aug</sub>
          <br>
          
          
            &nbsp;
          
        </td>
        
        
        
        <td>
          <sub>Sep</sub>
          <br>
          
          
            &nbsp;
          
        </td>
        
        
        
        <td>
          <sub>Oct</sub>
          <br>
          
          
            &nbsp;
          
        </td>
        
        
        
        <td>
          <sub>Nov</sub>
          <br>
          
          
            &nbsp;
          
        </td>
        
        
        
        <td>
          <sub>Dec</sub>
          <br>
          
          
            &nbsp;
          
        </td>
        
      </tr>
    
  </tbody></table>
  

  
  
  <table class="calendar-day">
    <tbody><tr>
    
      <th>S</th>
    
      <th>M</th>
    
      <th>T</th>
    
      <th>W</th>
    
      <th>T</th>
    
      <th>F</th>
    
      <th>S</th>
    
    </tr>
    
      <tr>
        
        <td>
          &nbsp;
          <br>
          
            &nbsp;
          
        </td>
        
        <td>
          &nbsp;
          <br>
          
            &nbsp;
          
        </td>
        
        <td>
          &nbsp;
          <br>
          
            &nbsp;
          
        </td>
        
        <td>
          &nbsp;
          <br>
          
            &nbsp;
          
        </td>
        
        <td>
          1
          <br>
          
            &nbsp;
          
        </td>
        
        <td>
          2
          <br>
          
            &nbsp;
          
        </td>
        
        <td>
          3
          <br>
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203&amp;viewday=3">(2)</a>
          
        </td>
        
      </tr>
    
      <tr>
        
        <td>
          4
          <br>
          
            &nbsp;
          
        </td>
        
        <td>
          5
          <br>
          
            &nbsp;
          
        </td>
        
        <td>
          6
          <br>
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203&amp;viewday=6">(1)</a>
          
        </td>
        
        <td>
          7
          <br>
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203&amp;viewday=7">(2)</a>
          
        </td>
        
        <td>
          8
          <br>
          
            &nbsp;
          
        </td>
        
        <td>
          9
          <br>
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203&amp;viewday=9">(1)</a>
          
        </td>
        
        <td>
          10
          <br>
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203&amp;viewday=10">(2)</a>
          
        </td>
        
      </tr>
    
      <tr>
        
        <td>
          11
          <br>
          
            &nbsp;
          
        </td>
        
        <td>
          12
          <br>
          
            &nbsp;
          
        </td>
        
        <td>
          13
          <br>
          
            &nbsp;
          
        </td>
        
        <td>
          14
          <br>
          
            &nbsp;
          
        </td>
        
        <td>
          15
          <br>
          
            &nbsp;
          
        </td>
        
        <td>
          16
          <br>
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203&amp;viewday=16">(2)</a>
          
        </td>
        
        <td>
          17
          <br>
          
            &nbsp;
          
        </td>
        
      </tr>
    
      <tr>
        
        <td>
          18
          <br>
          
            &nbsp;
          
        </td>
        
        <td>
          19
          <br>
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203&amp;viewday=19">(1)</a>
          
        </td>
        
        <td>
          20
          <br>
          
            &nbsp;
          
        </td>
        
        <td>
          21
          <br>
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203&amp;viewday=21">(1)</a>
          
        </td>
        
        <td>
          22
          <br>
          
            &nbsp;
          
        </td>
        
        <td>
          23
          <br>
          
            &nbsp;
          
        </td>
        
        <td>
          24
          <br>
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203&amp;viewday=24">(14)</a>
          
        </td>
        
      </tr>
    
      <tr>
        
        <td>
          25
          <br>
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203&amp;viewday=25">(2)</a>
          
        </td>
        
        <td>
          26
          <br>
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203&amp;viewday=26">(5)</a>
          
        </td>
        
        <td>
          27
          <br>
          
            
            <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203&amp;viewday=27">(1)</a>
          
        </td>
        
        <td>
          28
          <br>
          
            &nbsp;
          
        </td>
        
        <td>
          29
          <br>
          
            &nbsp;
          
        </td>
        
        <td>
          30
          <br>
          
            &nbsp;
          
        </td>
        
        <td>
          31
          <br>
          
            &nbsp;
          
        </td>
        
      </tr>
    
  </tbody></table>
  

  <div class="grid-19 mail-archive-style-switcher">
    <div class="grid-8">
      <form method="get">
  
    <input tabindex="3" name="viewmonth" value="201203" type="hidden">
  
  
  <p><strong>Showing
  
    <select tabindex="4" class="results_per_page" name="limit">
      
          <option selected="selected" value="25">25</option>
      
          <option value="50">50</option>
      
          <option value="100">100</option>
      
          <option value="250">250</option>
      
    </select>
  
  results of 34 </strong></p>
  
</form>
    </div>
    <div class="grid-4 thread-flat-switcher margin-top-10">
      <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203&amp;style=flat">Flat</a> |
      <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203&amp;style=threaded">Threaded</a>
    </div>
    <div>
  <div class="page_list">
      <span class="pager_curpage">1</span> <a class="pager_link" href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203&amp;page=1">2</a> <a class="pager_link" href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203&amp;page=1">&gt;</a> <a class="pager_link" href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203&amp;page=1">&gt;&gt;</a> (Page 1 of 2)
  </div>
  <div class="clear"></div>
</div>
  </div>
  <div style="clear: both;"></div>

  
    
      

<table id="msg29045943">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29045943/">[openMSX-commits] SF.net SVN: openmsx:[12460] openmsx/trunk/src</a></b></div>
      
      <small>From: &lt;bifimsx@us...&gt; - 2012-03-27 18:13:57</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12460
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12460&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12460&amp;view=rev</a>
Author:   bifimsx
Date:     2012-03-27 18:13:51 +0000 (Tue, 27 Mar 2012)
Log Message:
-----------
Allow the samples of Playball and Moero! Nettou Yakyu'88 in the same 
directory as the game ROM is, additionally to share/nettou_yakyuu/*.wav 
and share/playball/*.wav.

If the name of the game ROM is playball.rom the sample files should be 
playball_0.wav to playball_14.wav to get them loaded from the same 
directory as the game ROM.

Modified Paths:
--------------
    openmsx/trunk/src/memory/RomNettouYakyuu.cc
    openmsx/trunk/src/memory/RomPlayBall.cc
    openmsx/trunk/src/sound/SamplePlayer.cc
    openmsx/trunk/src/sound/SamplePlayer.hh

Modified: openmsx/trunk/src/memory/RomNettouYakyuu.cc
===================================================================
--- openmsx/trunk/src/memory/RomNettouYakyuu.cc	2012-03-26 20:09:21 UTC 
(rev 12459)
+++ openmsx/trunk/src/memory/RomNettouYakyuu.cc	2012-03-27 18:13:51 UTC 
(rev 12460)
@@ -42,6 +42,7 @@
 
 #include "RomNettouYakyuu.hh"
 #include "Rom.hh"
+#include "FileOperations.hh"
 #include "SamplePlayer.hh"
 #include "serialize.hh"
 
@@ -49,11 +50,12 @@
 
 RomNettouYakyuu::RomNettouYakyuu(
 		MSXMotherBoard&amp; motherBoard, const XMLElement&amp; config,
-		std::auto_ptr&lt;Rom&gt; rom)
-	: Rom8kBBlocks(motherBoard, config, rom)
+		std::auto_ptr&lt;Rom&gt; rom_)
+	: Rom8kBBlocks(motherBoard, config, rom_)
 	, samplePlayer(new SamplePlayer(motherBoard, "Nettou Yakyuu-DAC",
 	                         "Jaleco Moero!! Nettou Yakuu '88 DAC", 
config,
-	                         "nettou_yakyuu/nettou_yakyuu_", 16))
+	                         
FileOperations::stripExtension(rom-&gt;getFilename()) + "_",
+	                         16, "nettou_yakyuu/nettou_yakyuu_"))
 {
 	reset(EmuTime::dummy());
 }

Modified: openmsx/trunk/src/memory/RomPlayBall.cc
===================================================================
--- openmsx/trunk/src/memory/RomPlayBall.cc	2012-03-26 20:09:21 UTC (rev
 12459)
+++ openmsx/trunk/src/memory/RomPlayBall.cc	2012-03-27 18:13:51 UTC (rev
 12460)
@@ -4,16 +4,18 @@
 #include "SamplePlayer.hh"
 #include "CacheLine.hh"
 #include "Rom.hh"
+#include "FileOperations.hh"
 #include "serialize.hh"
 
 namespace openmsx {
 
 RomPlayBall::RomPlayBall(MSXMotherBoard&amp; motherBoard, const 
XMLElement&amp; config,
-                         std::auto_ptr&lt;Rom&gt; rom)
-	: Rom16kBBlocks(motherBoard, config, rom)
+                         std::auto_ptr&lt;Rom&gt; rom_)
+	: Rom16kBBlocks(motherBoard, config, rom_)
 	, samplePlayer(new SamplePlayer(motherBoard, "Playball-DAC",
 	                                "Sony Playball's DAC", config,
-	                                "playball/playball_", 15))
+	                                
FileOperations::stripExtension(rom-&gt;getFilename()) + "_",
+	                                15, "playball/playball_"))
 {
 	setUnmapped(0);
 	setRom(1, 0);

Modified: openmsx/trunk/src/sound/SamplePlayer.cc
===================================================================
--- openmsx/trunk/src/sound/SamplePlayer.cc	2012-03-26 20:09:21 UTC (rev
 12459)
+++ openmsx/trunk/src/sound/SamplePlayer.cc	2012-03-27 18:13:51 UTC (rev
 12460)
@@ -14,26 +14,35 @@
 
 SamplePlayer::SamplePlayer(MSXMotherBoard&amp; motherBoard, const 
std::string&amp; name,
                            const std::string&amp; desc, const 
XMLElement&amp; config,
-                           const std::string&amp; samplesBaseName, 
unsigned numSamples)
+                           const std::string&amp; samplesBaseName, 
unsigned numSamples,
+                           const std::string&amp; alternativeName)
 	: ResampledSoundDevice(motherBoard, name, desc, 1)
 {
 	setInputRate(44100); // Initialize with dummy value
 
 	bool alreadyWarned = false;
 	samples.resize(numSamples); // initialize with NULL ptrs
+	SystemFileContext context;
 	for (unsigned i = 0; i &lt; numSamples; ++i) {
 		try {
-			SystemFileContext context;
 			std::string filename = StringOp::Builder() &lt;&lt;
 				samplesBaseName &lt;&lt; i &lt;&lt; ".wav";
 			samples[i].reset(new WavData(context.resolve(filename)));
-		} catch (MSXException&amp; e) {
-			if (!alreadyWarned) {
-				alreadyWarned = true;
-				motherBoard.getMSXCliComm().printWarning(
-					"Couldn't read " + name + " sample data: " +
-					e.getMessage() +
-					". Continuing without sample data.");
+		} catch (MSXException&amp; e1) {
+			try {
+				if (alternativeName.empty()) throw;
+				std::string filename = StringOp::Builder() &lt;&lt;
+					alternativeName &lt;&lt; i &lt;&lt; ".wav";
+				samples[i].reset(new WavData(context.resolve(filename)));
+			} catch (MSXException&amp; e2) {
+				if (!alreadyWarned) {
+					alreadyWarned = true;
+					// print message from the 1st error
+					motherBoard.getMSXCliComm().printWarning(
+						"Couldn't read " + name + " sample data: " +
+						e1.getMessage() +
+						". Continuing without sample data.");
+				}
 			}
 		}
 	}

Modified: openmsx/trunk/src/sound/SamplePlayer.hh
===================================================================
--- openmsx/trunk/src/sound/SamplePlayer.hh	2012-03-26 20:09:21 UTC (rev
 12459)
+++ openmsx/trunk/src/sound/SamplePlayer.hh	2012-03-27 18:13:51 UTC (rev
 12460)
@@ -17,7 +17,8 @@
 public:
 	SamplePlayer(MSXMotherBoard&amp; motherBoard, const std::string&amp; 
name,
 	             const std::string&amp; desc, const XMLElement&amp; 
config,
-	             const std::string&amp; samplesBaseName, unsigned 
numSamples);
+	             const std::string&amp; samplesBaseName, unsigned 
numSamples,
+	             const std::string&amp; alternativeName = "");
 	~SamplePlayer();
 
 	void reset();

This was sent by the SourceForge.net collaborative development platform,
 the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg29041106">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29041106/">[openMSX-commits] SF.net SVN: openmsx:[12459] openmsx/trunk</a></b></div>
      
      <small>From: &lt;m9710797@us...&gt; - 2012-03-26 20:09:27</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12459
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12459&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12459&amp;view=rev</a>
Author:   m9710797
Date:     2012-03-26 20:09:21 +0000 (Mon, 26 Mar 2012)
Log Message:
-----------
oops, added file in wrong directory

Added Paths:
-----------
    openmsx/trunk/Contrib/analyze-dmk.cc

Removed Paths:
-------------
    openmsx/trunk/analyze-dmk.cc

Copied: openmsx/trunk/Contrib/analyze-dmk.cc (from rev 12458, openmsx/trunk/analyze-dmk.cc)
===================================================================
--- openmsx/trunk/Contrib/analyze-dmk.cc	                        (rev 0)
+++ openmsx/trunk/Contrib/analyze-dmk.cc	2012-03-26 20:09:21 UTC (rev 12459)
@@ -0,0 +1,244 @@
+#include &lt;string&gt;
+#include &lt;stdexcept&gt;
+#include &lt;vector&gt;
+#include &lt;cassert&gt;
+#include &lt;cstdio&gt;
+#include &lt;cstdlib&gt;
+
+using namespace std;
+
+typedef unsigned char byte;
+typedef unsigned short word;
+
+
+struct DmkHeader
+{
+	byte writeProtected;
+	byte numTracks;
+	byte trackLen[2];
+	byte flags;
+	byte reserved[7];
+	byte format[4];
+};
+
+
+class File
+{
+public:
+	File(const string&amp; filename, const char* mode)
+		: f(fopen(filename.c_str(), mode))
+	{
+		if (!f) {
+			throw runtime_error("Couldn't open: " + filename);
+		}
+	}
+
+	~File()
+	{
+		fclose(f);
+	}
+
+	void read(void* data, int size)
+	{
+		if (fread(data, size, 1, f) != 1) {
+			throw runtime_error("Couldn't read file");
+		}
+	}
+
+private:
+	FILE* f;
+};
+
+
+// global variables for circular buffer
+vector&lt;byte&gt; buffer;
+int dmkTrackLen;
+byte readCircular(int idx)
+{
+	return buffer[128 + idx % (dmkTrackLen - 128)];
+}
+
+static void updateCrc(word&amp; crc, byte val)
+{
+	for (int i = 8; i &lt; 16; ++i) {
+		crc = (crc &lt;&lt; 1) ^ ((((crc ^ (val &lt;&lt; i)) &amp; 0x8000) ? 0x1021 : 0));
+	}
+}
+
+bool isValidDmkHeader(const DmkHeader&amp; header)
+{
+	if (!((header.writeProtected == 0x00) ||
+	      (header.writeProtected == 0xff))) {
+		return false;
+	}
+	int trackLen = header.trackLen[0] + 256 * header.trackLen[1];
+	if (trackLen &gt;= 0x4000) return false; // too large track length
+	if (trackLen &lt;= 128)    return false; // too small
+	if (header.flags &amp; ~0xd0) return false; // unknown flag set
+	const byte* p = header.reserved;
+	for (int i = 0; i &lt; 7 + 4; ++i) {
+		if (p[i] != 0) return false;
+	}
+	return true;
+}
+
+
+void analyzeTrack()
+{
+	for (int i = 0; i &lt; 64; ++i) {
+		// Get (and check) pointer into track data
+		int dmkIdx = buffer[2 * i + 0] + 256 * buffer[2 * i + 1];
+		if (dmkIdx == 0) {
+			// end of table reached
+			break;
+		}
+		printf("%2d: ", i);
+		if ((dmkIdx &amp; 0xC000) != 0x8000) {
+			printf("... skipping single-density sector\n");
+			continue;
+		}
+		dmkIdx &amp;= ~0xC000; // clear flags
+		if ((dmkIdx &lt; 128) || (dmkIdx &gt;= dmkTrackLen)) {
+			printf("... skipping invalid IDAM offset (wrong DMK file)\n");
+			continue;
+		}
+		dmkIdx -= 128;
+
+		// read (and check) address mark
+		int addrIdx = dmkIdx - 3; // might be negative
+		byte d0 = readCircular(addrIdx + 0);
+		byte d1 = readCircular(addrIdx + 1);
+		byte d2 = readCircular(addrIdx + 2);
+		byte d3 = readCircular(addrIdx + 3);
+		byte c  = readCircular(addrIdx + 4);
+		byte h  = readCircular(addrIdx + 5);
+		byte r  = readCircular(addrIdx + 6);
+		byte n  = readCircular(addrIdx + 7);
+		byte ch = readCircular(addrIdx + 8);
+		byte cl = readCircular(addrIdx + 9);
+
+		if ((d0 != 0xA1) || (d1 != 0xA1) || (d2 != 0xA1) || (d3 != 0xFE)) {
+			printf("... skipping wrong IDAM entry, does not point to an address mark\n");
+			continue;
+		}
+
+		// address mark CRC
+		word addrCrc = 0xFFFF;
+		updateCrc(addrCrc, d0);
+		updateCrc(addrCrc, d1);
+		updateCrc(addrCrc, d2);
+		updateCrc(addrCrc, d3);
+		updateCrc(addrCrc, c);
+		updateCrc(addrCrc, h);
+		updateCrc(addrCrc, r);
+		updateCrc(addrCrc, n);
+		int onDiskAddrCrc = 256 * ch + cl;
+		bool addrCrcErr = onDiskAddrCrc != addrCrc;
+
+		// print address mark info
+		printf("AOfst=%4d C=%3d H=%3d R=%3d N=%3d ACrc=%04x,%s",
+		       addrIdx, c, h, r, n, onDiskAddrCrc,
+		       (addrCrcErr ? "ERR\n" : "ok "));
+		if (onDiskAddrCrc != addrCrc) {
+			continue;
+		}
+
+		// locate data mark, should be within 43 bytes from end
+		// of address mark (according to WD2793 datasheet)
+		int i;
+		for (i = 10; i &lt; 53; ++i) {
+			int dataIdx = addrIdx + i;
+			byte a0 = readCircular(dataIdx + 0);
+			byte a1 = readCircular(dataIdx + 1);
+			byte a2 = readCircular(dataIdx + 2);
+			byte t  = readCircular(dataIdx + 3);
+			if ((a0 != 0xA1) || (a1 != 0xA1) || (a2 != 0xA1)) {
+				continue;
+			}
+
+			// calculate data CRC, data mark part
+			word dataCrc = 0xFFFF;
+			updateCrc(dataCrc, a0);
+			updateCrc(dataCrc, a1);
+			updateCrc(dataCrc, a2);
+			updateCrc(dataCrc, t);
+
+			// actual sector data
+			int sectorSize = 128 &lt;&lt; (n &amp; 7);
+			for (int j = 0; j &lt; sectorSize; ++j) {
+				byte d = readCircular(dataIdx + 4 + j);
+				updateCrc(dataCrc, d);
+			}
+
+			byte crc1 = readCircular(dataIdx + 4 + sectorSize + 0);
+			byte crc2 = readCircular(dataIdx + 4 + sectorSize + 1);
+			int onDiskDataCrc = 256 * crc1 + crc2;
+			bool dataCrcErr = onDiskDataCrc != dataCrc;
+
+			char type = (t == 0xFB) ? 'n' :
+			            (t == 0xF8) ? 'd' :
+			                          '?';
+			printf(" DOfst=%4d T=%c DCrc=%04x,%s\n",
+			       dataIdx, type, onDiskDataCrc,
+			       (dataCrcErr ? "ERR" : "ok "));
+			break;
+		}
+		if (i == 53) {
+			printf(" data mark not found within 43 bytes from address mark\n");
+		}
+	}
+}
+
+void analyzeDisk(const string&amp; input)
+{
+	File inf(input, "rb");
+	DmkHeader header;
+	inf.read(&amp;header, sizeof(header));
+	if (!isValidDmkHeader(header)) {
+		throw runtime_error("Invalid DMK header");
+	}
+
+	int numCylinders = header.numTracks;
+	int numSides = (header.flags &amp; 0x10) ? 1 : 2;
+	dmkTrackLen = header.trackLen[0] + 256 * header.trackLen[1];
+	buffer.resize(dmkTrackLen);
+
+	printf("Legend:\n"
+	       "  AOfst:  address mark offset in track\n"
+	       "  C:      cylinder\n"
+	       "  H:      head\n"
+	       "  R:      record (sector number)\n"
+	       "  N:      sector size  (in bytes: 128 &lt;&lt; N)\n"
+	       "  ACrc:   CRC value of the address block\n"
+	       "  DOfst:  data mark offset in track\n"
+	       "  T:      data mark type (n = normal, d = deleted, ? = unknown)\n"
+	       "  DCrc:   CRC value of data block\n"
+	       "\n");
+
+	printf("Raw track length = %d bytes\n\n", dmkTrackLen - 128);
+
+	for (int t = 0; t &lt; numCylinders; ++t) {
+		for (int h = 0; h &lt; numSides; ++h) {
+			printf("-- physical track %d, head %d\n", t, h);
+			inf.read(&amp;buffer[0], dmkTrackLen);
+			analyzeTrack();
+		}
+	}
+}
+
+int main(int argc, char** argv)
+{
+	if (argc != 2) {
+		printf("analyze-dmk\n"
+		       "\n"
+		       "Analyze the content of a DMK disk image.\n"
+		       "\n"
+		       "usage: %s &lt;file.dmk&gt;\n", argv[0]);
+		exit(1);
+	}
+	try {
+		analyzeDisk(argv[1]);
+	} catch (std::exception&amp; e) {
+		fprintf(stderr, "Error: %s\n", e.what());
+	}
+}

Deleted: openmsx/trunk/analyze-dmk.cc
===================================================================
--- openmsx/trunk/analyze-dmk.cc	2012-03-26 20:04:50 UTC (rev 12458)
+++ openmsx/trunk/analyze-dmk.cc	2012-03-26 20:09:21 UTC (rev 12459)
@@ -1,244 +0,0 @@
-#include &lt;string&gt;
-#include &lt;stdexcept&gt;
-#include &lt;vector&gt;
-#include &lt;cassert&gt;
-#include &lt;cstdio&gt;
-#include &lt;cstdlib&gt;
-
-using namespace std;
-
-typedef unsigned char byte;
-typedef unsigned short word;
-
-
-struct DmkHeader
-{
-	byte writeProtected;
-	byte numTracks;
-	byte trackLen[2];
-	byte flags;
-	byte reserved[7];
-	byte format[4];
-};
-
-
-class File
-{
-public:
-	File(const string&amp; filename, const char* mode)
-		: f(fopen(filename.c_str(), mode))
-	{
-		if (!f) {
-			throw runtime_error("Couldn't open: " + filename);
-		}
-	}
-
-	~File()
-	{
-		fclose(f);
-	}
-
-	void read(void* data, int size)
-	{
-		if (fread(data, size, 1, f) != 1) {
-			throw runtime_error("Couldn't read file");
-		}
-	}
-
-private:
-	FILE* f;
-};
-
-
-// global variables for circular buffer
-vector&lt;byte&gt; buffer;
-int dmkTrackLen;
-byte readCircular(int idx)
-{
-	return buffer[128 + idx % (dmkTrackLen - 128)];
-}
-
-static void updateCrc(word&amp; crc, byte val)
-{
-	for (int i = 8; i &lt; 16; ++i) {
-		crc = (crc &lt;&lt; 1) ^ ((((crc ^ (val &lt;&lt; i)) &amp; 0x8000) ? 0x1021 : 0));
-	}
-}
-
-bool isValidDmkHeader(const DmkHeader&amp; header)
-{
-	if (!((header.writeProtected == 0x00) ||
-	      (header.writeProtected == 0xff))) {
-		return false;
-	}
-	int trackLen = header.trackLen[0] + 256 * header.trackLen[1];
-	if (trackLen &gt;= 0x4000) return false; // too large track length
-	if (trackLen &lt;= 128)    return false; // too small
-	if (header.flags &amp; ~0xd0) return false; // unknown flag set
-	const byte* p = header.reserved;
-	for (int i = 0; i &lt; 7 + 4; ++i) {
-		if (p[i] != 0) return false;
-	}
-	return true;
-}
-
-
-void analyzeTrack()
-{
-	for (int i = 0; i &lt; 64; ++i) {
-		// Get (and check) pointer into track data
-		int dmkIdx = buffer[2 * i + 0] + 256 * buffer[2 * i + 1];
-		if (dmkIdx == 0) {
-			// end of table reached
-			break;
-		}
-		printf("%2d: ", i);
-		if ((dmkIdx &amp; 0xC000) != 0x8000) {
-			printf("... skipping single-density sector\n");
-			continue;
-		}
-		dmkIdx &amp;= ~0xC000; // clear flags
-		if ((dmkIdx &lt; 128) || (dmkIdx &gt;= dmkTrackLen)) {
-			printf("... skipping invalid IDAM offset (wrong DMK file)\n");
-			continue;
-		}
-		dmkIdx -= 128;
-
-		// read (and check) address mark
-		int addrIdx = dmkIdx - 3; // might be negative
-		byte d0 = readCircular(addrIdx + 0);
-		byte d1 = readCircular(addrIdx + 1);
-		byte d2 = readCircular(addrIdx + 2);
-		byte d3 = readCircular(addrIdx + 3);
-		byte c  = readCircular(addrIdx + 4);
-		byte h  = readCircular(addrIdx + 5);
-		byte r  = readCircular(addrIdx + 6);
-		byte n  = readCircular(addrIdx + 7);
-		byte ch = readCircular(addrIdx + 8);
-		byte cl = readCircular(addrIdx + 9);
-
-		if ((d0 != 0xA1) || (d1 != 0xA1) || (d2 != 0xA1) || (d3 != 0xFE)) {
-			printf("... skipping wrong IDAM entry, does not point to an address mark\n");
-			continue;
-		}
-
-		// address mark CRC
-		word addrCrc = 0xFFFF;
-		updateCrc(addrCrc, d0);
-		updateCrc(addrCrc, d1);
-		updateCrc(addrCrc, d2);
-		updateCrc(addrCrc, d3);
-		updateCrc(addrCrc, c);
-		updateCrc(addrCrc, h);
-		updateCrc(addrCrc, r);
-		updateCrc(addrCrc, n);
-		int onDiskAddrCrc = 256 * ch + cl;
-		bool addrCrcErr = onDiskAddrCrc != addrCrc;
-
-		// print address mark info
-		printf("AOfst=%4d C=%3d H=%3d R=%3d N=%3d ACrc=%04x,%s",
-		       addrIdx, c, h, r, n, onDiskAddrCrc,
-		       (addrCrcErr ? "ERR\n" : "ok "));
-		if (onDiskAddrCrc != addrCrc) {
-			continue;
-		}
-
-		// locate data mark, should be within 43 bytes from end
-		// of address mark (according to WD2793 datasheet)
-		int i;
-		for (i = 10; i &lt; 53; ++i) {
-			int dataIdx = addrIdx + i;
-			byte a0 = readCircular(dataIdx + 0);
-			byte a1 = readCircular(dataIdx + 1);
-			byte a2 = readCircular(dataIdx + 2);
-			byte t  = readCircular(dataIdx + 3);
-			if ((a0 != 0xA1) || (a1 != 0xA1) || (a2 != 0xA1)) {
-				continue;
-			}
-
-			// calculate data CRC, data mark part
-			word dataCrc = 0xFFFF;
-			updateCrc(dataCrc, a0);
-			updateCrc(dataCrc, a1);
-			updateCrc(dataCrc, a2);
-			updateCrc(dataCrc, t);
-
-			// actual sector data
-			int sectorSize = 128 &lt;&lt; (n &amp; 7);
-			for (int j = 0; j &lt; sectorSize; ++j) {
-				byte d = readCircular(dataIdx + 4 + j);
-				updateCrc(dataCrc, d);
-			}
-
-			byte crc1 = readCircular(dataIdx + 4 + sectorSize + 0);
-			byte crc2 = readCircular(dataIdx + 4 + sectorSize + 1);
-			int onDiskDataCrc = 256 * crc1 + crc2;
-			bool dataCrcErr = onDiskDataCrc != dataCrc;
-
-			char type = (t == 0xFB) ? 'n' :
-			            (t == 0xF8) ? 'd' :
-			                          '?';
-			printf(" DOfst=%4d T=%c DCrc=%04x,%s\n",
-			       dataIdx, type, onDiskDataCrc,
-			       (dataCrcErr ? "ERR" : "ok "));
-			break;
-		}
-		if (i == 53) {
-			printf(" data mark not found within 43 bytes from address mark\n");
-		}
-	}
-}
-
-void analyzeDisk(const string&amp; input)
-{
-	File inf(input, "rb");
-	DmkHeader header;
-	inf.read(&amp;header, sizeof(header));
-	if (!isValidDmkHeader(header)) {
-		throw runtime_error("Invalid DMK header");
-	}
-
-	int numCylinders = header.numTracks;
-	int numSides = (header.flags &amp; 0x10) ? 1 : 2;
-	dmkTrackLen = header.trackLen[0] + 256 * header.trackLen[1];
-	buffer.resize(dmkTrackLen);
-
-	printf("Legend:\n"
-	       "  AOfst:  address mark offset in track\n"
-	       "  C:      cylinder\n"
-	       "  H:      head\n"
-	       "  R:      record (sector number)\n"
-	       "  N:      sector size  (in bytes: 128 &lt;&lt; N)\n"
-	       "  ACrc:   CRC value of the address block\n"
-	       "  DOfst:  data mark offset in track\n"
-	       "  T:      data mark type (n = normal, d = deleted, ? = unknown)\n"
-	       "  DCrc:   CRC value of data block\n"
-	       "\n");
-
-	printf("Raw track length = %d bytes\n\n", dmkTrackLen - 128);
-
-	for (int t = 0; t &lt; numCylinders; ++t) {
-		for (int h = 0; h &lt; numSides; ++h) {
-			printf("-- physical track %d, head %d\n", t, h);
-			inf.read(&amp;buffer[0], dmkTrackLen);
-			analyzeTrack();
-		}
-	}
-}
-
-int main(int argc, char** argv)
-{
-	if (argc != 2) {
-		printf("analyze-dmk\n"
-		       "\n"
-		       "Analyze the content of a DMK disk image.\n"
-		       "\n"
-		       "usage: %s &lt;file.dmk&gt;\n", argv[0]);
-		exit(1);
-	}
-	try {
-		analyzeDisk(argv[1]);
-	} catch (std::exception&amp; e) {
-		fprintf(stderr, "Error: %s\n", e.what());
-	}
-}

This was sent by the SourceForge.net collaborative development platform, the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg29041084">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29041084/">[openMSX-commits] SF.net SVN: openmsx:[12458]
	openmsx/trunk/analyze-dmk.cc</a></b></div>
      
      <small>From: &lt;m9710797@us...&gt; - 2012-03-26 20:04:57</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12458
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12458&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12458&amp;view=rev</a>
Author:   m9710797
Date:     2012-03-26 20:04:50 +0000 (Mon, 26 Mar 2012)
Log Message:
-----------
Added utility to analyze an existing DMK disk image file

Added Paths:
-----------
    openmsx/trunk/analyze-dmk.cc

Added: openmsx/trunk/analyze-dmk.cc
===================================================================
--- openmsx/trunk/analyze-dmk.cc	                        (rev 0)
+++ openmsx/trunk/analyze-dmk.cc	2012-03-26 20:04:50 UTC (rev 12458)
@@ -0,0 +1,244 @@
+#include &lt;string&gt;
+#include &lt;stdexcept&gt;
+#include &lt;vector&gt;
+#include &lt;cassert&gt;
+#include &lt;cstdio&gt;
+#include &lt;cstdlib&gt;
+
+using namespace std;
+
+typedef unsigned char byte;
+typedef unsigned short word;
+
+
+struct DmkHeader
+{
+	byte writeProtected;
+	byte numTracks;
+	byte trackLen[2];
+	byte flags;
+	byte reserved[7];
+	byte format[4];
+};
+
+
+class File
+{
+public:
+	File(const string&amp; filename, const char* mode)
+		: f(fopen(filename.c_str(), mode))
+	{
+		if (!f) {
+			throw runtime_error("Couldn't open: " + filename);
+		}
+	}
+
+	~File()
+	{
+		fclose(f);
+	}
+
+	void read(void* data, int size)
+	{
+		if (fread(data, size, 1, f) != 1) {
+			throw runtime_error("Couldn't read file");
+		}
+	}
+
+private:
+	FILE* f;
+};
+
+
+// global variables for circular buffer
+vector&lt;byte&gt; buffer;
+int dmkTrackLen;
+byte readCircular(int idx)
+{
+	return buffer[128 + idx % (dmkTrackLen - 128)];
+}
+
+static void updateCrc(word&amp; crc, byte val)
+{
+	for (int i = 8; i &lt; 16; ++i) {
+		crc = (crc &lt;&lt; 1) ^ ((((crc ^ (val &lt;&lt; i)) &amp; 0x8000) ? 0x1021 : 0));
+	}
+}
+
+bool isValidDmkHeader(const DmkHeader&amp; header)
+{
+	if (!((header.writeProtected == 0x00) ||
+	      (header.writeProtected == 0xff))) {
+		return false;
+	}
+	int trackLen = header.trackLen[0] + 256 * header.trackLen[1];
+	if (trackLen &gt;= 0x4000) return false; // too large track length
+	if (trackLen &lt;= 128)    return false; // too small
+	if (header.flags &amp; ~0xd0) return false; // unknown flag set
+	const byte* p = header.reserved;
+	for (int i = 0; i &lt; 7 + 4; ++i) {
+		if (p[i] != 0) return false;
+	}
+	return true;
+}
+
+
+void analyzeTrack()
+{
+	for (int i = 0; i &lt; 64; ++i) {
+		// Get (and check) pointer into track data
+		int dmkIdx = buffer[2 * i + 0] + 256 * buffer[2 * i + 1];
+		if (dmkIdx == 0) {
+			// end of table reached
+			break;
+		}
+		printf("%2d: ", i);
+		if ((dmkIdx &amp; 0xC000) != 0x8000) {
+			printf("... skipping single-density sector\n");
+			continue;
+		}
+		dmkIdx &amp;= ~0xC000; // clear flags
+		if ((dmkIdx &lt; 128) || (dmkIdx &gt;= dmkTrackLen)) {
+			printf("... skipping invalid IDAM offset (wrong DMK file)\n");
+			continue;
+		}
+		dmkIdx -= 128;
+
+		// read (and check) address mark
+		int addrIdx = dmkIdx - 3; // might be negative
+		byte d0 = readCircular(addrIdx + 0);
+		byte d1 = readCircular(addrIdx + 1);
+		byte d2 = readCircular(addrIdx + 2);
+		byte d3 = readCircular(addrIdx + 3);
+		byte c  = readCircular(addrIdx + 4);
+		byte h  = readCircular(addrIdx + 5);
+		byte r  = readCircular(addrIdx + 6);
+		byte n  = readCircular(addrIdx + 7);
+		byte ch = readCircular(addrIdx + 8);
+		byte cl = readCircular(addrIdx + 9);
+
+		if ((d0 != 0xA1) || (d1 != 0xA1) || (d2 != 0xA1) || (d3 != 0xFE)) {
+			printf("... skipping wrong IDAM entry, does not point to an address mark\n");
+			continue;
+		}
+
+		// address mark CRC
+		word addrCrc = 0xFFFF;
+		updateCrc(addrCrc, d0);
+		updateCrc(addrCrc, d1);
+		updateCrc(addrCrc, d2);
+		updateCrc(addrCrc, d3);
+		updateCrc(addrCrc, c);
+		updateCrc(addrCrc, h);
+		updateCrc(addrCrc, r);
+		updateCrc(addrCrc, n);
+		int onDiskAddrCrc = 256 * ch + cl;
+		bool addrCrcErr = onDiskAddrCrc != addrCrc;
+
+		// print address mark info
+		printf("AOfst=%4d C=%3d H=%3d R=%3d N=%3d ACrc=%04x,%s",
+		       addrIdx, c, h, r, n, onDiskAddrCrc,
+		       (addrCrcErr ? "ERR\n" : "ok "));
+		if (onDiskAddrCrc != addrCrc) {
+			continue;
+		}
+
+		// locate data mark, should be within 43 bytes from end
+		// of address mark (according to WD2793 datasheet)
+		int i;
+		for (i = 10; i &lt; 53; ++i) {
+			int dataIdx = addrIdx + i;
+			byte a0 = readCircular(dataIdx + 0);
+			byte a1 = readCircular(dataIdx + 1);
+			byte a2 = readCircular(dataIdx + 2);
+			byte t  = readCircular(dataIdx + 3);
+			if ((a0 != 0xA1) || (a1 != 0xA1) || (a2 != 0xA1)) {
+				continue;
+			}
+
+			// calculate data CRC, data mark part
+			word dataCrc = 0xFFFF;
+			updateCrc(dataCrc, a0);
+			updateCrc(dataCrc, a1);
+			updateCrc(dataCrc, a2);
+			updateCrc(dataCrc, t);
+
+			// actual sector data
+			int sectorSize = 128 &lt;&lt; (n &amp; 7);
+			for (int j = 0; j &lt; sectorSize; ++j) {
+				byte d = readCircular(dataIdx + 4 + j);
+				updateCrc(dataCrc, d);
+			}
+
+			byte crc1 = readCircular(dataIdx + 4 + sectorSize + 0);
+			byte crc2 = readCircular(dataIdx + 4 + sectorSize + 1);
+			int onDiskDataCrc = 256 * crc1 + crc2;
+			bool dataCrcErr = onDiskDataCrc != dataCrc;
+
+			char type = (t == 0xFB) ? 'n' :
+			            (t == 0xF8) ? 'd' :
+			                          '?';
+			printf(" DOfst=%4d T=%c DCrc=%04x,%s\n",
+			       dataIdx, type, onDiskDataCrc,
+			       (dataCrcErr ? "ERR" : "ok "));
+			break;
+		}
+		if (i == 53) {
+			printf(" data mark not found within 43 bytes from address mark\n");
+		}
+	}
+}
+
+void analyzeDisk(const string&amp; input)
+{
+	File inf(input, "rb");
+	DmkHeader header;
+	inf.read(&amp;header, sizeof(header));
+	if (!isValidDmkHeader(header)) {
+		throw runtime_error("Invalid DMK header");
+	}
+
+	int numCylinders = header.numTracks;
+	int numSides = (header.flags &amp; 0x10) ? 1 : 2;
+	dmkTrackLen = header.trackLen[0] + 256 * header.trackLen[1];
+	buffer.resize(dmkTrackLen);
+
+	printf("Legend:\n"
+	       "  AOfst:  address mark offset in track\n"
+	       "  C:      cylinder\n"
+	       "  H:      head\n"
+	       "  R:      record (sector number)\n"
+	       "  N:      sector size  (in bytes: 128 &lt;&lt; N)\n"
+	       "  ACrc:   CRC value of the address block\n"
+	       "  DOfst:  data mark offset in track\n"
+	       "  T:      data mark type (n = normal, d = deleted, ? = unknown)\n"
+	       "  DCrc:   CRC value of data block\n"
+	       "\n");
+
+	printf("Raw track length = %d bytes\n\n", dmkTrackLen - 128);
+
+	for (int t = 0; t &lt; numCylinders; ++t) {
+		for (int h = 0; h &lt; numSides; ++h) {
+			printf("-- physical track %d, head %d\n", t, h);
+			inf.read(&amp;buffer[0], dmkTrackLen);
+			analyzeTrack();
+		}
+	}
+}
+
+int main(int argc, char** argv)
+{
+	if (argc != 2) {
+		printf("analyze-dmk\n"
+		       "\n"
+		       "Analyze the content of a DMK disk image.\n"
+		       "\n"
+		       "usage: %s &lt;file.dmk&gt;\n", argv[0]);
+		exit(1);
+	}
+	try {
+		analyzeDisk(argv[1]);
+	} catch (std::exception&amp; e) {
+		fprintf(stderr, "Error: %s\n", e.what());
+	}
+}

This was sent by the SourceForge.net collaborative development platform, the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg29041037">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29041037/">[openMSX-commits] SF.net SVN: openmsx:[12457] openmsx/trunk/src</a></b></div>
      
      <small>From: &lt;bifimsx@us...&gt; - 2012-03-26 19:52:34</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12457
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12457&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12457&amp;view=rev</a>
Author:   bifimsx
Date:     2012-03-26 19:52:27 +0000 (Mon, 26 Mar 2012)
Log Message:
-----------
Allow Keyboard Master voice ROM in the same directory as the software 
ROM is, additionally to share/keyboardmaster/voice.rom.

If the name of the software ROM is keyboardmaster.rom the voice ROM 
should be called keyboardmaster_voice.rom to get it loaded from the same
 directory as the software ROM.

Modified Paths:
--------------
    openmsx/trunk/src/memory/RomKonamiKeyboardMaster.cc
    openmsx/trunk/src/sound/VLM5030.cc
    openmsx/trunk/src/sound/VLM5030.hh

Modified: openmsx/trunk/src/memory/RomKonamiKeyboardMaster.cc
===================================================================
--- openmsx/trunk/src/memory/RomKonamiKeyboardMaster.cc	2012-03-26 
19:50:07 UTC (rev 12456)
+++ openmsx/trunk/src/memory/RomKonamiKeyboardMaster.cc	2012-03-26 
19:52:27 UTC (rev 12457)
@@ -12,10 +12,11 @@
 
 RomKonamiKeyboardMaster::RomKonamiKeyboardMaster(
 		MSXMotherBoard&amp; motherBoard, const XMLElement&amp; config,
-		std::auto_ptr&lt;Rom&gt; rom)
-	: Rom16kBBlocks(motherBoard, config, rom)
+		std::auto_ptr&lt;Rom&gt; rom_)
+	: Rom16kBBlocks(motherBoard, config, rom_)
 	, vlm5030(new VLM5030(motherBoard, "VLM5030",
-	                      "Konami Keyboard Master's VLM5030", config))
+	                      "Konami Keyboard Master's VLM5030",
+	                      rom-&gt;getFilename(), config))
 {
 	setUnmapped(0);
 	setRom(1, 0);

Modified: openmsx/trunk/src/sound/VLM5030.cc
===================================================================
--- openmsx/trunk/src/sound/VLM5030.cc	2012-03-26 19:50:07 UTC (rev 
12456)
+++ openmsx/trunk/src/sound/VLM5030.cc	2012-03-26 19:52:27 UTC (rev 
12457)
@@ -81,6 +81,7 @@
 #include "Rom.hh"
 #include "XMLElement.hh"
 #include "FileContext.hh"
+#include "FileOperations.hh"
 #include "serialize.hh"
 #include &lt;cstring&gt;
 #include &lt;cstdlib&gt;
@@ -91,7 +92,8 @@
 {
 public:
 	Impl(MSXMotherBoard&amp; motherBoard, const std::string&amp; name,
-	            const std::string&amp; desc, const XMLElement&amp; 
config);
+	            const std::string&amp; desc, const std::string&amp; 
romFilename,
+	            const XMLElement&amp; config);
 	~Impl();
 
 	void reset();
@@ -574,7 +576,8 @@
 }
 
 VLM5030::Impl::Impl(MSXMotherBoard&amp; motherBoard, const 
std::string&amp; name,
-                 const std::string&amp; desc, const XMLElement&amp; 
config)
+                 const std::string&amp; desc, const std::string&amp; 
romFilename,
+                 const XMLElement&amp; config)
 	: ResampledSoundDevice(motherBoard, name, desc, 1)
 {
 	XMLElement voiceROMconfig(name);
@@ -585,6 +588,8 @@
 		std::auto_ptr&lt;XMLElement&gt;(new XMLElement("rom")));
 	romElement-&gt;addChild(std::auto_ptr&lt;XMLElement&gt;( // load by 
sha1sum
 		new XMLElement("sha1", "4f36d139ee4baa7d5980f765de9895570ee05f40")));
+	romElement-&gt;addChild(std::auto_ptr&lt;XMLElement&gt;( // load by 
predefined filename in software rom's dir
+		new XMLElement("filename", 
FileOperations::stripExtension(romFilename) + "_voice.rom")));
 	romElement-&gt;addChild(std::auto_ptr&lt;XMLElement&gt;( // or 
hardcoded filename in ditto dir
 		new XMLElement("filename", "keyboardmaster/voice.rom")));
 	voiceROMconfig.addChild(romElement);
@@ -649,8 +654,9 @@
 // class VLM5030
 
 VLM5030::VLM5030(MSXMotherBoard&amp; motherBoard, const 
std::string&amp; name,
-                 const std::string&amp; desc, const XMLElement&amp; 
config)
-	: pimpl(new Impl(motherBoard, name, desc, config))
+                 const std::string&amp; desc, const std::string&amp; 
romFilename,
+                 const XMLElement&amp; config)
+	: pimpl(new Impl(motherBoard, name, desc, romFilename, config))
 {
 }
 

Modified: openmsx/trunk/src/sound/VLM5030.hh
===================================================================
--- openmsx/trunk/src/sound/VLM5030.hh	2012-03-26 19:50:07 UTC (rev 
12456)
+++ openmsx/trunk/src/sound/VLM5030.hh	2012-03-26 19:52:27 UTC (rev 
12457)
@@ -17,7 +17,8 @@
 {
 public:
 	VLM5030(MSXMotherBoard&amp; motherBoard, const std::string&amp; name,
-	        const std::string&amp; desc, const XMLElement&amp; config);
+	        const std::string&amp; desc, const std::string&amp; 
romFilename,
+	        const XMLElement&amp; config);
 	~VLM5030();
 	void reset();
 

This was sent by the SourceForge.net collaborative development platform,
 the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg29041008">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29041008/">[openMSX-commits] SF.net SVN: openmsx:[12456]
	openmsx/trunk/src/memory</a></b></div>
      
      <small>From: &lt;bifimsx@us...&gt; - 2012-03-26 19:50:14</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12456
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12456&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12456&amp;view=rev</a>
Author:   bifimsx
Date:     2012-03-26 19:50:07 +0000 (Mon, 26 Mar 2012)
Log Message:
-----------
Allow to get the full path- and filename of a ROM image. This allows a 
rom mapper to load additional files from the same directory (and even 
with the same filename, with different extension) the software ROM is 
located in.

Modified Paths:
--------------
    openmsx/trunk/src/memory/Rom.cc
    openmsx/trunk/src/memory/Rom.hh

Modified: openmsx/trunk/src/memory/Rom.cc
===================================================================
--- openmsx/trunk/src/memory/Rom.cc	2012-03-26 19:47:22 UTC (rev 12455)
+++ openmsx/trunk/src/memory/Rom.cc	2012-03-26 19:50:07 UTC (rev 12456)
@@ -333,6 +333,11 @@
 {
 }
 
+string Rom::getFilename() const
+{
+	return file.get() ? file-&gt;getURL() : "";
+}
+
 const string&amp; Rom::getName() const
 {
 	return name;

Modified: openmsx/trunk/src/memory/Rom.hh
===================================================================
--- openmsx/trunk/src/memory/Rom.hh	2012-03-26 19:47:22 UTC (rev 12455)
+++ openmsx/trunk/src/memory/Rom.hh	2012-03-26 19:50:07 UTC (rev 12456)
@@ -32,6 +32,7 @@
 	}
 	unsigned getSize() const { return size; }
 
+	std::string getFilename() const;
 	const std::string&amp; getName() const;
 	const std::string&amp; getDescription() const;
 	const std::string&amp; getOriginalSHA1() const;

This was sent by the SourceForge.net collaborative development platform,
 the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg29041007">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29041007/">[openMSX-commits] SF.net SVN: openmsx:[12455] openmsx/trunk/src/file</a></b></div>
      
      <small>From: &lt;bifimsx@us...&gt; - 2012-03-26 19:47:29</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12455
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12455&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12455&amp;view=rev</a>
Author:   bifimsx
Date:     2012-03-26 19:47:22 +0000 (Mon, 26 Mar 2012)
Log Message:
-----------
Added stripExtension function, also removing the '.'.

Modified Paths:
--------------
    openmsx/trunk/src/file/FileOperations.cc
    openmsx/trunk/src/file/FileOperations.hh

Modified: openmsx/trunk/src/file/FileOperations.cc
===================================================================
--- openmsx/trunk/src/file/FileOperations.cc	2012-03-25 18:09:40 UTC (rev 12454)
+++ openmsx/trunk/src/file/FileOperations.cc	2012-03-26 19:47:22 UTC (rev 12455)
@@ -317,6 +317,16 @@
 	}
 }
 
+string stripExtension (const string&amp; path)
+{
+	string::size_type pos = path.rfind('.');
+	if (pos == string::npos) {
+		return path;
+	} else {
+		return path.substr(0, pos);
+	}
+}
+
 string join(const string&amp; part1, const string&amp; part2)
 {
 	if (isAbsolutePath(part2)) {

Modified: openmsx/trunk/src/file/FileOperations.hh
===================================================================
--- openmsx/trunk/src/file/FileOperations.hh	2012-03-25 18:09:40 UTC (rev 12454)
+++ openmsx/trunk/src/file/FileOperations.hh	2012-03-26 19:47:22 UTC (rev 12455)
@@ -107,6 +107,15 @@
 	 */
 	std::string getExtension(const std::string&amp; path);
 
+	/**
+	 * Returns the path without extension.
+	 * @param path The pathname
+	 * @result The path without extension. This excludes the '.'.
+	 *         If path doesn't have an extension portion the result
+	 *         remains unchanged.
+	 */
+	std::string stripExtension(const std::string&amp; path);
+
 	/** Join two paths.
 	 * Returns the equivalent of 'path1 + '/' + path2'. If 'part2' is an
 	 * absolute path, that path is returned ('part1' is ignored). If

This was sent by the SourceForge.net collaborative development platform, the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg29037306">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29037306/">[openMSX-commits] SF.net SVN: openmsx:[12454]
	openmsx/trunk/Contrib/dsk2dmk.cc</a></b></div>
      
      <small>From: &lt;m9710797@us...&gt; - 2012-03-25 18:09:46</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12454
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12454&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12454&amp;view=rev</a>
Author:   m9710797
Date:     2012-03-25 18:09:40 +0000 (Sun, 25 Mar 2012)
Log Message:
-----------
The example program didn't compile on mingw

The conversion 'File::operator FILE*()' didn't work for some reason. Worked
around it by using stat() instead of fstat(), do that we don't need fileno().

Modified Paths:
--------------
    openmsx/trunk/Contrib/dsk2dmk.cc

Modified: openmsx/trunk/Contrib/dsk2dmk.cc
===================================================================
--- openmsx/trunk/Contrib/dsk2dmk.cc	2012-03-25 09:07:20 UTC (rev 12453)
+++ openmsx/trunk/Contrib/dsk2dmk.cc	2012-03-25 18:09:40 UTC (rev 12454)
@@ -54,8 +54,6 @@
 		fclose(f);
 	}
 
-	operator FILE*() const { return f; }
-
 	void read(void* data, int size)
 	{
 		if (fread(data, size, 1, f) != 1) {
@@ -89,8 +87,6 @@
 
 void convert(const DiskInfo&amp; info, const string&amp; input, const string&amp; output)
 {
-	File inf(input, "rb");
-
 	int numSides = info.doubleSided ? 2 : 1;
 	int sectorSize = 128 &lt;&lt; info.sectorSizeCode;
 	int totalTracks = numSides * info.numberCylinders;
@@ -98,11 +94,12 @@
 	int totalSize = totalSectors * sectorSize;
 
 	struct stat st;
-	fstat(fileno(inf), &amp;st);
+	stat(input.c_str(), &amp;st);
 	if (st.st_size != totalSize) {
 		throw runtime_error("Wrong input filesize");
 	}
 
+	File inf(input, "rb");
 	File outf(output, "wb");
 
 	int rawSectorLen =

This was sent by the SourceForge.net collaborative development platform, the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg29033745">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29033745/">[openMSX-commits] SF.net SVN: openmsx:[12453]
	openmsx/trunk/Contrib/dsk2dmk.cc</a></b></div>
      
      <small>From: &lt;m9710797@us...&gt; - 2012-03-25 09:07:31</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12453
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12453&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12453&amp;view=rev</a>
Author:   m9710797
Date:     2012-03-25 09:07:20 +0000 (Sun, 25 Mar 2012)
Log Message:
-----------
Added a (limited) utility to convert a dsk disk image into a dmk disk image.

Added Paths:
-----------
    openmsx/trunk/Contrib/dsk2dmk.cc

Added: openmsx/trunk/Contrib/dsk2dmk.cc
===================================================================
--- openmsx/trunk/Contrib/dsk2dmk.cc	                        (rev 0)
+++ openmsx/trunk/Contrib/dsk2dmk.cc	2012-03-25 09:07:20 UTC (rev 12453)
@@ -0,0 +1,223 @@
+#include &lt;string&gt;
+#include &lt;stdexcept&gt;
+#include &lt;vector&gt;
+#include &lt;cassert&gt;
+#include &lt;cstdio&gt;
+#include &lt;cstring&gt;
+#include &lt;cstdlib&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;sys/types.h&gt;
+
+using namespace std;
+
+typedef unsigned char  byte; //  8 bit
+typedef unsigned short word; // 16 bit
+
+
+struct DiskInfo
+{
+	int gap1;
+	int gap2;
+	int gap3;
+	int gap4a;
+	int gap4b;
+	int sectorsPerTrack;
+	int numberCylinders;
+	int sectorSizeCode;
+	bool doubleSided;
+};
+
+struct DmkHeader
+{
+	byte writeProtected;
+	byte numTracks;
+	byte trackLen[2];
+	byte flags;
+	byte reserved[7];
+	byte format[4];
+};
+
+
+class File
+{
+public:
+	File(const string&amp; filename, const char* mode)
+		: f(fopen(filename.c_str(), mode))
+	{
+		if (!f) {
+			throw runtime_error("Couldn't open: " + filename);
+		}
+	}
+
+	~File()
+	{
+		fclose(f);
+	}
+
+	operator FILE*() const { return f; }
+
+	void read(void* data, int size)
+	{
+		if (fread(data, size, 1, f) != 1) {
+			throw runtime_error("Couldn't read file");
+		}
+	}
+	void write(const void* data, int size)
+	{
+		if (fwrite(data, size, 1, f) != 1) {
+			throw runtime_error("Couldn't write file");
+		}
+	}
+
+private:
+	FILE* f;
+};
+
+
+static void updateCrc(word&amp; crc, byte val)
+{
+	for (int i = 8; i &lt; 16; ++i) {
+		crc = (crc &lt;&lt; 1) ^ ((((crc ^ (val &lt;&lt; i)) &amp; 0x8000) ? 0x1021 : 0));
+	}
+}
+
+static void fill(byte*&amp; p, int len, byte value)
+{
+	memset(p, value, len);
+	p += len;
+}
+
+void convert(const DiskInfo&amp; info, const string&amp; input, const string&amp; output)
+{
+	File inf(input, "rb");
+
+	int numSides = info.doubleSided ? 2 : 1;
+	int sectorSize = 128 &lt;&lt; info.sectorSizeCode;
+	int totalTracks = numSides * info.numberCylinders;
+	int totalSectors = totalTracks * info.sectorsPerTrack;
+	int totalSize = totalSectors * sectorSize;
+
+	struct stat st;
+	fstat(fileno(inf), &amp;st);
+	if (st.st_size != totalSize) {
+		throw runtime_error("Wrong input filesize");
+	}
+
+	File outf(output, "wb");
+
+	int rawSectorLen =
+		12 + 10 + info.gap2 + 12 + 4 +
+		sectorSize + 2 + info.gap3;
+	int rawTrackLen =
+		info.gap4a + 12 + 4 + info.gap1 +
+		info.sectorsPerTrack * rawSectorLen + info.gap4b;
+	assert(rawTrackLen == 6250);
+	int dmkTrackLen = rawTrackLen + 128;
+
+	DmkHeader header;
+	memset(&amp;header, 0, sizeof(header));
+	header.numTracks = info.numberCylinders;
+	header.trackLen[0] = dmkTrackLen &amp; 0xff;
+	header.trackLen[1] = dmkTrackLen &gt;&gt; 8;
+	header.flags = (info.doubleSided ? (0 &lt;&lt; 4) : (1 &lt;&lt; 4)) |
+	               (0 &lt;&lt; 6); // double density (MFM)
+	outf.write(&amp;header, sizeof(header));
+
+	vector&lt;byte*&gt; addrPos(info.sectorsPerTrack);
+	vector&lt;byte*&gt; dataPos(info.sectorsPerTrack);
+	vector&lt;byte&gt; buf(dmkTrackLen); // zero-initialized
+	byte* ip = &amp;buf[  0]; // pointer in IDAM table
+	byte* tp = &amp;buf[128]; // pointer in actual track data
+
+	fill(tp, info.gap4a, 0x4e); // gap4a
+	fill(tp,         12, 0x00); // sync
+	fill(tp,          3, 0xc2); // index mark
+	fill(tp,          1, 0xfc); //
+	fill(tp, info.gap1,  0x4e); // gap1
+	for (int sec = 0; sec &lt; info.sectorsPerTrack; ++sec) {
+		fill(tp,         12, 0x00); // sync
+		fill(tp,          3, 0xa1); // ID addr mark
+		int pos = tp - &amp;buf[0];
+		assert(pos &lt; 0x4000);
+		*ip++ = pos &amp; 0xff;
+		*ip++ = (pos &gt;&gt; 8) | 0x80; // double density (MFM) sector
+		fill(tp,          1, 0xfe); // ID addr mark (cont)
+		addrPos[sec] = tp;
+		fill(tp,          6, 0x00); // C H R N CRC (overwritten later)
+		fill(tp, info.gap2,  0x4e); // gap2
+		fill(tp,         12, 0x00); // sync
+		fill(tp,          3, 0xa1); // data mark
+		fill(tp,          1, 0xfb); //
+		dataPos[sec] = tp;
+		fill(tp, sectorSize, 0x00); // sector data (overwritten later)
+		fill(tp,          2, 0x00); // CRC (overwritten later)
+		fill(tp, info.gap3,  0x4e); // gap3
+	}
+	fill(tp, info.gap4b, 0x4e); // gap4b
+	assert((tp - &amp;buf[0]) == dmkTrackLen);
+
+	for (int cyl = 0; cyl &lt; info.numberCylinders; ++cyl) {
+		for (int head = 0; head &lt; numSides; ++head) {
+			for (int sec = 0; sec &lt; info.sectorsPerTrack; ++sec) {
+				byte* ap = addrPos[sec];
+				*ap++ = cyl;
+				*ap++ = head;
+				*ap++ = sec + 1;
+				*ap++ = info.sectorSizeCode;
+
+				word addrCrc = 0xffff;
+				const byte* t1 = ap - 8;
+				for (int i = 0; i &lt; 8; ++i) {
+					updateCrc(addrCrc, t1[i]);
+				}
+				*ap++ = addrCrc &gt;&gt; 8;
+				*ap++ = addrCrc &amp; 0xff;
+
+				byte* dp = dataPos[sec];
+				inf.read(dp, sectorSize);
+				dp += sectorSize;
+
+				word dataCrc = 0xffff;
+				const byte* t2 = dp - sectorSize - 4;
+				for (int i = 0; i &lt; sectorSize + 4; ++i) {
+					updateCrc(dataCrc, t2[i]);
+				}
+				*dp++ = dataCrc &gt;&gt; 8;
+				*dp++ = dataCrc &amp; 0xff;
+			}
+			outf.write(&amp;buf[0], dmkTrackLen);
+		}
+	}
+}
+
+int main(int argc, char** argv)
+{
+	if (argc != 3) {
+		printf("dsk2dmk\n"
+		       "\n"
+		       "Utility to convert a dsk disk image into a dmk disk\n"
+		       "image. At the moment this utility is limited to 720kB\n"
+		       "double sided, double density dsk images.\n"
+		       "\n"
+		       "Usage: %s &lt;input.dsk&gt; &lt;output.dmk&gt;\n", argv[0]);
+		exit(1);
+	}
+
+	// TODO add command line options to make these parameters configurable
+	DiskInfo info;
+	info.gap1  =  50;
+	info.gap2  =  22;
+	info.gap3  =  84;
+	info.gap4a =  80;
+	info.gap4b = 182; // TODO calculate from other values
+	info.sectorsPerTrack = 9;
+	info.numberCylinders = 80;
+	info.sectorSizeCode = 2; // 512 = 128 &lt;&lt; 2
+	info.doubleSided = true;
+
+	try {
+		convert(info, argv[1], argv[2]);
+	} catch (std::exception&amp; e) {
+		fprintf(stderr, "Error: %s\n", e.what());
+	}
+}

This was sent by the SourceForge.net collaborative development platform, the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg29031953">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29031953/">[openMSX-commits] SF.net SVN: openmsx:[12452]
	openmsx/trunk/src/memory/MegaFlashRomSCCPlus.cc</a></b></div>
      
      <small>From: &lt;bifimsx@us...&gt; - 2012-03-24 18:24:21</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12452
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12452&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12452&amp;view=rev</a>
Author:   bifimsx
Date:     2012-03-24 18:24:10 +0000 (Sat, 24 Mar 2012)
Log Message:
-----------
Fixed irregularities in the bankswitching part of the non-SCC Konami part.

Modified Paths:
--------------
    openmsx/trunk/src/memory/MegaFlashRomSCCPlus.cc

Modified: openmsx/trunk/src/memory/MegaFlashRomSCCPlus.cc
===================================================================
--- openmsx/trunk/src/memory/MegaFlashRomSCCPlus.cc	2012-03-24 18:10:38 UTC (rev 12451)
+++ openmsx/trunk/src/memory/MegaFlashRomSCCPlus.cc	2012-03-24 18:24:10 UTC (rev 12452)
@@ -272,7 +272,7 @@
 			break;
 		case 0x20: {
 			// Konami
-			if (((configReg &amp; 0x08) == 0x00) &amp;&amp; (addr &lt; 0x6000)) {
+			if (((configReg &amp; 0x08) == 0x08) &amp;&amp; (addr &lt; 0x6000)) {
 				// Switching 0x4000-0x5FFF disabled.
 				// This bit blocks writing to the bank register
 				// (an alternative was forcing a 0 on read).
@@ -281,7 +281,8 @@
 			}
 			// Making of the mapper bits is done on
 			// write (and only in Konami(-scc) mode)
-			byte mask = (configReg &amp; 0x01) ? 0x1F : 0xFF;
+			if ((addr &lt; 0x5000) || ((0x5800 &lt;= addr) &amp;&amp; (addr &lt; 0x6000))) break; // only SCC range works
+			byte mask = (configReg &amp; 0x01) ? 0x1F : 0x7F;
 			bankRegs[subslot][page8] = value &amp; mask;
 			invalidateMemCache(0x4000 + 0x2000 * page8, 0x2000);
 			break;

This was sent by the SourceForge.net collaborative development platform, the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg29031897">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29031897/">[openMSX-commits] SF.net SVN: openmsx:[12451] openmsx/trunk/src/fdc</a></b></div>
      
      <small>From: &lt;m9710797@us...&gt; - 2012-03-24 18:10:51</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12451
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12451&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12451&amp;view=rev</a>
Author:   m9710797
Date:     2012-03-24 18:10:38 +0000 (Sat, 24 Mar 2012)
Log Message:
-----------
Worked around vc++ bug(?) (see comments in RawTrack.cc)

Also fixed some vc++ specific compiler warnings.

Modified Paths:
--------------
    openmsx/trunk/src/fdc/DMKDiskImage.cc
    openmsx/trunk/src/fdc/DiskFactory.cc
    openmsx/trunk/src/fdc/RawTrack.cc
    openmsx/trunk/src/fdc/TC8566AF.cc
    openmsx/trunk/src/fdc/WD2793.cc

Modified: openmsx/trunk/src/fdc/DMKDiskImage.cc
===================================================================
--- openmsx/trunk/src/fdc/DMKDiskImage.cc	2012-03-24 17:22:00 UTC (rev 12450)
+++ openmsx/trunk/src/fdc/DMKDiskImage.cc	2012-03-24 18:10:38 UTC (rev 12451)
@@ -59,7 +59,7 @@
 
 	numTracks = header.numTracks;
 	dmkTrackLen = header.trackLen[0] + 256 * header.trackLen[1] - 128;
-	singleSided = header.flags &amp; FLAG_SINGLE_SIDED;
+	singleSided = (header.flags &amp; FLAG_SINGLE_SIDED) != 0;;
 	writeProtected = header.writeProtected == 0xff;
 
 	// TODO should we print a warning when dmkTrackLen is too far from the
@@ -143,7 +143,7 @@
 	// Write idam table.
 	byte idamOut[2 * 64] = {}; // zero-initialize
 	const vector&lt;int&gt;&amp; idamIn = input.getIdamBuffer();
-	for (int i = 0; i &lt; std::min&lt;int&gt;(64, idamIn.size()); ++i) {
+	for (int i = 0; i &lt; std::min&lt;int&gt;(64, int(idamIn.size())); ++i) {
 		int t = (idamIn[i] + 128) | FLAG_MFM_SECTOR;
 		idamOut[2 * i + 0] = t &amp; 0xff;
 		idamOut[2 * i + 1] = t &gt;&gt; 8;
@@ -156,7 +156,7 @@
 	file-&gt;write(input.getRawBuffer(), std::min(dmkTrackLen, RawTrack::SIZE));
 	if (dmkTrackLen &gt; RawTrack::SIZE) {
 		vector&lt;byte&gt; pad(dmkTrackLen - RawTrack::SIZE, 0x4e);
-		file-&gt;write(&amp;pad[0], pad.size());
+		file-&gt;write(&amp;pad[0], unsigned(pad.size()));
 	}
 }
 

Modified: openmsx/trunk/src/fdc/DiskFactory.cc
===================================================================
--- openmsx/trunk/src/fdc/DiskFactory.cc	2012-03-24 17:22:00 UTC (rev 12450)
+++ openmsx/trunk/src/fdc/DiskFactory.cc	2012-03-24 18:10:38 UTC (rev 12451)
@@ -76,7 +76,7 @@
 			// next try dmk
 			file-&gt;seek(0);
 			return new DMKDiskImage(filename, file);
-		} catch (MSXException&amp; e) {
+		} catch (MSXException&amp; /*e*/) {
 			// DMK didn't work, still no problem
 		}
 		// next try normal DSK

Modified: openmsx/trunk/src/fdc/RawTrack.cc
===================================================================
--- openmsx/trunk/src/fdc/RawTrack.cc	2012-03-24 17:22:00 UTC (rev 12450)
+++ openmsx/trunk/src/fdc/RawTrack.cc	2012-03-24 18:10:38 UTC (rev 12451)
@@ -12,7 +12,16 @@
 
 namespace openmsx {
 
+#ifndef _MSC_VER
+// Workaround vc++ bug???
+//  I'm reasonably sure the following line is required. If it's left out I get
+//  a link error when compiling with gcc (though only in a debug build). This
+//  page also says it's required:
+//    <a href="http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.13" rel="nofollow">http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.13</a>
+//  Though with this line Vampier got a link error in vc++, removing the line
+//  fixed the problem.
 const int RawTrack::SIZE;
+#endif
 
 RawTrack::RawTrack()
 {

Modified: openmsx/trunk/src/fdc/TC8566AF.cc
===================================================================
--- openmsx/trunk/src/fdc/TC8566AF.cc	2012-03-24 17:22:00 UTC (rev 12450)
+++ openmsx/trunk/src/fdc/TC8566AF.cc	2012-03-24 18:10:38 UTC (rev 12451)
@@ -427,7 +427,7 @@
 		try {
 			next = drive[driveSelect]-&gt;getNextSector(
 				next, trackData, sectorInfo);
-		} catch (MSXException&amp; e) {
+		} catch (MSXException&amp; /*e*/) {
 			return EmuTime::infinity;
 		}
 		if ((next == EmuTime::infinity) ||

Modified: openmsx/trunk/src/fdc/WD2793.cc
===================================================================
--- openmsx/trunk/src/fdc/WD2793.cc	2012-03-24 17:22:00 UTC (rev 12450)
+++ openmsx/trunk/src/fdc/WD2793.cc	2012-03-24 18:10:38 UTC (rev 12451)
@@ -562,7 +562,7 @@
 	while (true) {
 		try {
 			next = drive.getNextSector(next, trackData, sectorInfo);
-		} catch (MSXException&amp; e) {
+		} catch (MSXException&amp; /*e*/) {
 			statusReg |= RECORD_NOT_FOUND;
 			endCmd();
 			return;

This was sent by the SourceForge.net collaborative development platform, the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg29031780">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29031780/">[openMSX-commits] SF.net SVN: openmsx:[12450]
	openmsx/trunk/build/msvc/openmsx.vcxproj</a></b></div>
      
      <small>From: V&lt;ampier@us...&gt; - 2012-03-24 17:22:13</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12450
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12450&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12450&amp;view=rev</a>
Author:   Vampier
Date:     2012-03-24 17:22:00 +0000 (Sat, 24 Mar 2012)
Log Message:
-----------
added 2 new files to the project file for visual studio

Modified Paths:
--------------
    openmsx/trunk/build/msvc/openmsx.vcxproj

Modified: openmsx/trunk/build/msvc/openmsx.vcxproj
===================================================================
--- openmsx/trunk/build/msvc/openmsx.vcxproj	2012-03-24 16:36:49 UTC (rev 12449)
+++ openmsx/trunk/build/msvc/openmsx.vcxproj	2012-03-24 17:22:00 UTC (rev 12450)
@@ -387,6 +387,8 @@
     &lt;ClCompile Include="$(OpenMSXSrcDir)\fdc\RealDrive.cc" /&gt;
     &lt;ClCompile Include="$(OpenMSXSrcDir)\fdc\SectorAccessibleDisk.cc" /&gt;
     &lt;ClCompile Include="$(OpenMSXSrcDir)\fdc\SectorBasedDisk.cc" /&gt;
+	&lt;ClCompile Include="$(OpenMSXSrcDir)\fdc\RawTrack.cc" /&gt;
+	&lt;ClCompile Include="$(OpenMSXSrcDir)\fdc\DMKDiskImage.cc" /&gt;
     &lt;ClCompile Include="$(OpenMSXSrcDir)\fdc\TC8566AF.cc" /&gt;
     &lt;ClCompile Include="$(OpenMSXSrcDir)\fdc\TurboRFDC.cc" /&gt;
     &lt;ClCompile Include="$(OpenMSXSrcDir)\fdc\WD2793.cc" /&gt;
@@ -881,6 +883,7 @@
     &lt;None Include="$(OpenMSXSrcDir)\fdc\NowindInterface.hh" /&gt;
     &lt;None Include="$(OpenMSXSrcDir)\fdc\NowindRomDisk.hh" /&gt;
     &lt;None Include="$(OpenMSXSrcDir)\fdc\PhilipsFDC.hh" /&gt;
+    &lt;None Include="$(OpenMSXSrcDir)\fdc\RawTrack.hh" /&gt;
     &lt;None Include="$(OpenMSXSrcDir)\fdc\RamDSKDiskImage.hh" /&gt;
     &lt;None Include="$(OpenMSXSrcDir)\fdc\RealDrive.hh" /&gt;
     &lt;None Include="$(OpenMSXSrcDir)\fdc\SectorAccessibleDisk.hh" /&gt;

This was sent by the SourceForge.net collaborative development platform, the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg29031629">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29031629/">[openMSX-commits] SF.net SVN: openmsx:[12449]
	openmsx/trunk/Contrib/empty-dmk.cc</a></b></div>
      
      <small>From: &lt;m9710797@us...&gt; - 2012-03-24 16:36:59</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12449
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12449&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12449&amp;view=rev</a>
Author:   m9710797
Date:     2012-03-24 16:36:49 +0000 (Sat, 24 Mar 2012)
Log Message:
-----------
Added 'empty-dmk' utility

ATM this utility is the only way to start using DMK disk images in openMSX. I
also manually created some DMK images of copy-protected games to be able to
test the openMSX implementation, but obviously I can't spread those images.
The goal is to eventually develop some (MSX) tool so that users can dump their
own original disks to DMK disk images.

Added Paths:
-----------
    openmsx/trunk/Contrib/empty-dmk.cc

Added: openmsx/trunk/Contrib/empty-dmk.cc
===================================================================
--- openmsx/trunk/Contrib/empty-dmk.cc	                        (rev 0)
+++ openmsx/trunk/Contrib/empty-dmk.cc	2012-03-24 16:36:49 UTC (rev 12449)
@@ -0,0 +1,48 @@
+#include &lt;cstdio&gt;
+#include &lt;cstring&gt;
+#include &lt;cstdlib&gt;
+
+typedef unsigned char byte;
+
+struct DmkHeader {
+	byte writeProtected;
+	byte numTracks;
+	byte trackLen[2];
+	byte flags;
+	byte reserved[7];
+	byte format[4];
+};
+
+static const int RAW_TRACK_SIZE = 6250; // 250kbps, 300rpm
+
+int main(int argc, char** argv)
+{
+	if (argc != 2) {
+		printf("empty-dmk\n"
+		       "\n"
+		       "Utility to create an empty DMK disk image.\n"
+		       "The disk image is double sided and contains\n"
+		       "80 unformatted tracks.\n"
+		       "\n"
+		       "usage: %s &lt;filename&gt;\n", argv[0]);
+		exit(1);
+	}
+
+	FILE* f = fopen(argv[1], "wb");
+
+	DmkHeader header;
+	memset(&amp;header, 0, sizeof(header));
+	header.numTracks = 80;
+	header.trackLen[0] = (128 + RAW_TRACK_SIZE) &amp; 255;
+	header.trackLen[1] = (128 + RAW_TRACK_SIZE) &gt;&gt; 8;
+	fwrite(&amp;header, sizeof(header), 1, f);
+
+	byte buf[128 + RAW_TRACK_SIZE];
+	memset(&amp;buf[  0],    0,  128);
+	memset(&amp;buf[128], 0x4e, RAW_TRACK_SIZE);
+	for (int i = 0; i &lt; 2 * 80; ++i) {
+		fwrite(buf, sizeof(buf), 1, f);
+	}
+
+	fclose(f);
+}

This was sent by the SourceForge.net collaborative development platform, the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg29031628">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29031628/">[openMSX-commits] SF.net SVN: openmsx:[12448] openmsx/trunk/src/fdc</a></b></div>
      
      <small>From: &lt;m9710797@us...&gt; - 2012-03-24 16:36:45</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12448
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12448&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12448&amp;view=rev</a>
Author:   m9710797
Date:     2012-03-24 16:36:34 +0000 (Sat, 24 Mar 2012)
Log Message:
-----------
Improved accuracy of disk drive rotation

Before this patch, when the drive motor was stopped and later started again,
the orientation (=rotation angle) of the disk was reset to zero degrees. After
this patch, we continue rotating from the angle we stopped at.

This change was needed to make the 'Sunrise disk copy-protection'-test pass on
a TurboR machine (tested with a DMK image of 'Shrines of Enigma'). This disk
has a track which contains a sector with the same ID multiple times. It reads
this sector several times and expects to see different results. Though without
this disk drive improvement it turned out we always read the same version and
thus the test failed. On a Philips MSX2 machine the drive motor is not turned
off for the duration of the copy-protection-test, and so this change doesn't
have any effect (the test already passed).

Note that a real disk drive has some inertia (both for spinning up and spinning
down). This is currently not emulated. Also need to investigate how a real
TurboR behaves when the motor is turned off for a short amount of time. Does it
really stop rotating (not taking inertia into account) or does it have some
hardware timeout mechanism?

Modified Paths:
--------------
    openmsx/trunk/src/fdc/RealDrive.cc
    openmsx/trunk/src/fdc/RealDrive.hh

Modified: openmsx/trunk/src/fdc/RealDrive.cc
===================================================================
--- openmsx/trunk/src/fdc/RealDrive.cc	2012-03-24 16:36:19 UTC (rev 12447)
+++ openmsx/trunk/src/fdc/RealDrive.cc	2012-03-24 16:36:34 UTC (rev 12448)
@@ -39,7 +39,8 @@
 	, motorTimeout(motorTimeout_)
 	, motorTimer(getCurrentTime())
 	, headLoadTimer(getCurrentTime())
-	, headPos(0), side(0), motorStatus(false), headLoadStatus(false)
+	, headPos(0), side(0), startAngle(0)
+	, motorStatus(false), headLoadStatus(false)
 	, doubleSizedDrive(doubleSided)
 {
 	MSXMotherBoard::SharedStuff&amp; info =
@@ -200,8 +201,21 @@
 	}
 }
 
+int RealDrive::getCurrentAngle(EmuTime::param time) const
+{
+	if (motorStatus) {
+		// rotating, take passed time into account
+		int deltaAngle = motorTimer.getTicksTill(time);
+		return (startAngle + deltaAngle) % TICKS_PER_ROTATION;
+	} else {
+		// not rotating, angle didn't change
+		return startAngle;
+	}
+}
+
 void RealDrive::doSetMotor(bool status, EmuTime::param time)
 {
+	startAngle = getCurrentAngle(time);
 	motorStatus = status;
 	motorTimer.advance(time);
 
@@ -241,8 +255,7 @@
 	if (!(motorStatus &amp;&amp; isDiskInserted())) {
 		return false;
 	}
-	int angle = motorTimer.getTicksTill(time) % TICKS_PER_ROTATION;
-	return angle &lt; INDEX_DURATION;
+	return getCurrentAngle(time) &lt; INDEX_DURATION;
 }
 
 EmuTime RealDrive::getTimeTillIndexPulse(EmuTime::param time)
@@ -250,8 +263,7 @@
 	if (!motorStatus || !isDiskInserted()) { // TODO is this correct?
 		return time;
 	}
-	int delta = TICKS_PER_ROTATION -
-	            (motorTimer.getTicksTill(time) % TICKS_PER_ROTATION);
+	int delta = TICKS_PER_ROTATION - getCurrentAngle(time);
 	EmuDuration dur = MotorClock::duration(delta);
 	return time + dur;
 }
@@ -283,7 +295,7 @@
 EmuTime RealDrive::getNextSector(
 	EmuTime::param time, RawTrack&amp; track, RawTrack::Sector&amp; sector)
 {
-	int idx = motorTimer.getTicksTill(time) % TICKS_PER_ROTATION;
+	int idx = getCurrentAngle(time);
 	changer-&gt;getDisk().readTrack(headPos, side, track);
 	if (!track.decodeNextSector(idx, sector)) {
 		return EmuTime::infinity;
@@ -311,8 +323,9 @@
 
 // version 1: initial version
 // version 2: removed 'timeOut', added MOTOR_TIMEOUT schedulable
+// version 3: added 'startAngle'
 template&lt;typename Archive&gt;
-void RealDrive::serialize(Archive&amp; ar, unsigned /*version*/)
+void RealDrive::serialize(Archive&amp; ar, unsigned version)
 {
 	ar.template serializeBase&lt;Schedulable&gt;(*this);
 	ar.serialize("motorTimer", motorTimer);
@@ -322,6 +335,12 @@
 	ar.serialize("side", side);
 	ar.serialize("motorStatus", motorStatus);
 	ar.serialize("headLoadStatus", headLoadStatus);
+	if (ar.versionAtLeast(version, 3)) {
+		ar.serialize("startAngle", startAngle);
+	} else {
+		assert(ar.isLoader());
+		startAngle = 0;
+	}
 	if (ar.isLoader()) {
 		// Right after a loadstate, the 'loading indicator' state may
 		// be wrong, but that's OK. It's anyway only a heuristic and

Modified: openmsx/trunk/src/fdc/RealDrive.hh
===================================================================
--- openmsx/trunk/src/fdc/RealDrive.hh	2012-03-24 16:36:19 UTC (rev 12447)
+++ openmsx/trunk/src/fdc/RealDrive.hh	2012-03-24 16:36:34 UTC (rev 12448)
@@ -51,6 +51,7 @@
 	virtual void executeUntil(EmuTime::param time, int userData);
 	void doSetMotor(bool status, EmuTime::param time);
 	void setLoading(EmuTime::param time);
+	int getCurrentAngle(EmuTime::param time) const;
 
 	static const int MAX_TRACK = 85;
 	static const int TICKS_PER_ROTATION = 6250; // see Disk.hh
@@ -67,11 +68,12 @@
 	std::auto_ptr&lt;DiskChanger&gt; changer;
 	int headPos;
 	int side;
+	int startAngle;
 	bool motorStatus;
 	bool headLoadStatus;
 	const bool doubleSizedDrive;
 };
-SERIALIZE_CLASS_VERSION(RealDrive, 2);
+SERIALIZE_CLASS_VERSION(RealDrive, 3);
 
 } // namespace openmsx
 

This was sent by the SourceForge.net collaborative development platform, the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg29031627">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29031627/">[openMSX-commits] SF.net SVN: openmsx:[12447] openmsx/trunk/src</a></b></div>
      
      <small>From: &lt;m9710797@us...&gt; - 2012-03-24 16:36:31</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12447
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12447&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12447&amp;view=rev</a>
Author:   m9710797
Date:     2012-03-24 16:36:19 +0000 (Sat, 24 Mar 2012)
Log Message:
-----------
compute CRC16 of short sequences at compile time

Modified Paths:
--------------
    openmsx/trunk/src/fdc/RawTrack.cc
    openmsx/trunk/src/fdc/TC8566AF.cc
    openmsx/trunk/src/fdc/WD2793.cc
    openmsx/trunk/src/utils/CRC16.hh

Modified: openmsx/trunk/src/fdc/RawTrack.cc
===================================================================
--- openmsx/trunk/src/fdc/RawTrack.cc	2012-03-24 16:35:59 UTC (rev 12446)
+++ openmsx/trunk/src/fdc/RawTrack.cc	2012-03-24 16:36:19 UTC (rev 12447)
@@ -35,12 +35,11 @@
 bool RawTrack::decodeSector(int idx, Sector&amp; sector) const
 {
 	// read (and check) address mark
-	CRC16 addrCrc;
 	// assume addr mark starts with three A1 bytes (should be
 	// located right before the current 'idx' position)
-	for (int i = 0; i &lt; 3; ++i) {
-		addrCrc.update(0xA1);
-	}
+	CRC16 addrCrc;
+	addrCrc.init&lt;0xA1, 0xA1, 0xA1&gt;();
+
 	if (read(idx++) != 0xFE) return false;
 	addrCrc.update(0xFE);
 	int addrIdx = idx;

Modified: openmsx/trunk/src/fdc/TC8566AF.cc
===================================================================
--- openmsx/trunk/src/fdc/TC8566AF.cc	2012-03-24 16:35:59 UTC (rev 12446)
+++ openmsx/trunk/src/fdc/TC8566AF.cc	2012-03-24 16:36:19 UTC (rev 12447)
@@ -502,7 +502,7 @@
 			}
 			// Initialize crc
 			// TODO 0xFB vs 0xF8 depends on deleted vs normal data
-			crc.init(0xE295); // A1 A1 A1 FB
+			crc.init&lt;0xA1, 0xA1, 0xA1, 0xFB&gt;();
 
 			// first byte is available when it's rotated below the
 			// drive-head

Modified: openmsx/trunk/src/fdc/WD2793.cc
===================================================================
--- openmsx/trunk/src/fdc/WD2793.cc	2012-03-24 16:35:59 UTC (rev 12446)
+++ openmsx/trunk/src/fdc/WD2793.cc	2012-03-24 16:36:19 UTC (rev 12447)
@@ -253,7 +253,7 @@
 				// 3rd A1 byte. Though what we do instead is on
 				// each A1 byte initialize the value as if
 				// there were already 2 A1 bytes written.
-				crc.init(0x968B);
+				crc.init&lt;0xA1, 0xA1&gt;();
 			} else if (value == 0xF6) {
 				// write C2 with missing clock transitions
 				write = 0xC2;
@@ -606,7 +606,7 @@
 		//  - write A1 A1 A1 FB   (or F8)
 		// But ATM we reuse the previous location of the data block
 	}
-	crc.init(0xE295); // A1 A1 A1 FB
+	crc.init&lt;0xA1, 0xA1, 0xA1, 0xFB&gt;();
 
 	// wait till sector is actually rotated under head
 	schedule(FSM_TYPE2_ROTATED, next);

Modified: openmsx/trunk/src/utils/CRC16.hh
===================================================================
--- openmsx/trunk/src/utils/CRC16.hh	2012-03-24 16:35:59 UTC (rev 12446)
+++ openmsx/trunk/src/utils/CRC16.hh	2012-03-24 16:36:19 UTC (rev 12447)
@@ -28,6 +28,40 @@
 		crc = initialCRC;
 	}
 
+	/** (Re)initialize with a short initial sequence.
+	  * The initial value is guaranteed to be computed at compile time.
+	  */
+	template&lt;byte V1&gt; void init()
+	{
+		static const word T0 = 0xffff;
+		static const word T1 = CT_CRC16&lt;T0, V1&gt;::value;
+		init(T1);
+	}
+	template&lt;byte V1, byte V2&gt; void init()
+	{
+		static const word T0 = 0xffff;
+		static const word T1 = CT_CRC16&lt;T0, V1&gt;::value;
+		static const word T2 = CT_CRC16&lt;T1, V2&gt;::value;
+		init(T2);
+	}
+	template&lt;byte V1, byte V2, byte V3&gt; void init()
+	{
+		static const word T0 = 0xffff;
+		static const word T1 = CT_CRC16&lt;T0, V1&gt;::value;
+		static const word T2 = CT_CRC16&lt;T1, V2&gt;::value;
+		static const word T3 = CT_CRC16&lt;T2, V3&gt;::value;
+		init(T3);
+	}
+	template&lt;byte V1, byte V2, byte V3, byte V4&gt; void init()
+	{
+		static const word T0 = 0xffff;
+		static const word T1 = CT_CRC16&lt;T0, V1&gt;::value;
+		static const word T2 = CT_CRC16&lt;T1, V2&gt;::value;
+		static const word T3 = CT_CRC16&lt;T2, V3&gt;::value;
+		static const word T4 = CT_CRC16&lt;T3, V4&gt;::value;
+		init(T4);
+	}
+
 	/** Update CRC with one byte
 	 */
 	void update(byte value)
@@ -45,6 +79,20 @@
 private:
 	word crc;
 	static const word CRC16Table[256];
+
+	// The Stuff below is template magic to perform the following
+	// computation at compile-time:
+	//    for (int i = 8; i &lt; 16; ++i) {
+	//        crc = (crc &lt;&lt; 1) ^ ((((crc ^ (data &lt;&lt; i)) &amp; 0x8000) ? 0x1021 : 0));
+	//    }
+	template&lt;word C, word V, int B&gt; struct CT_H {
+		static const word D = word(C &lt;&lt; 1) ^ (((C ^ V) &amp; 0x8000) ? 0x1021 : 0);
+		static const word value = CT_H&lt;D, word(V &lt;&lt; 1), B - 1&gt;::value;
+	};
+	template&lt;word C, word V&gt; struct CT_H&lt;C, V, 0&gt; {
+		static const word value = C;
+	};
+	template&lt;word IN, byte VAL&gt; struct CT_CRC16 : CT_H&lt;IN, VAL &lt;&lt; 8, 8&gt; {};
 };
 
 } // namespace openmsx

This was sent by the SourceForge.net collaborative development platform, the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg29031626">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29031626/">[openMSX-commits] SF.net SVN: openmsx:[12446] openmsx/trunk/src</a></b></div>
      
      <small>From: &lt;m9710797@us...&gt; - 2012-03-24 16:36:11</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12446
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12446&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12446&amp;view=rev</a>
Author:   m9710797
Date:     2012-03-24 16:35:59 +0000 (Sat, 24 Mar 2012)
Log Message:
-----------
added support for DMK disk images

Modified Paths:
--------------
    openmsx/trunk/src/CommandLineParser.cc
    openmsx/trunk/src/fdc/DSKDiskImage.cc
    openmsx/trunk/src/fdc/DSKDiskImage.hh
    openmsx/trunk/src/fdc/Disk.hh
    openmsx/trunk/src/fdc/DiskFactory.cc
    openmsx/trunk/src/fdc/RawTrack.hh
    openmsx/trunk/src/fdc/node.mk

Added Paths:
-----------
    openmsx/trunk/src/fdc/DMKDiskImage.cc
    openmsx/trunk/src/fdc/DMKDiskImage.hh

Modified: openmsx/trunk/src/CommandLineParser.cc
===================================================================
--- openmsx/trunk/src/CommandLineParser.cc	2012-03-24 16:35:36 UTC (rev 12445)
+++ openmsx/trunk/src/CommandLineParser.cc	2012-03-24 16:35:59 UTC (rev 12446)
@@ -248,6 +248,7 @@
 		fileExtMap["rom"] = "romimage";
 		fileExtMap["ri"]  = "romimage";
 		fileExtMap["dsk"] = "diskimage";
+		fileExtMap["dmk"] = "diskimage";
 		fileExtMap["di1"] = "diskimage";
 		fileExtMap["di2"] = "diskimage";
 		fileExtMap["xsa"] = "diskimage";

Added: openmsx/trunk/src/fdc/DMKDiskImage.cc
===================================================================
--- openmsx/trunk/src/fdc/DMKDiskImage.cc	                        (rev 0)
+++ openmsx/trunk/src/fdc/DMKDiskImage.cc	2012-03-24 16:35:59 UTC (rev 12446)
@@ -0,0 +1,227 @@
+// $Id$
+
+#include "DMKDiskImage.hh"
+#include "DiskExceptions.hh"
+#include "File.hh"
+#include "static_assert.hh"
+#include &lt;algorithm&gt;
+#include &lt;cassert&gt;
+
+using std::vector;
+
+namespace openmsx {
+
+struct DmkHeader
+{
+	byte writeProtected;
+	byte numTracks;
+	byte trackLen[2];
+	byte flags;
+	byte reserved[7];
+	byte format[4];
+};
+STATIC_ASSERT(sizeof(DmkHeader) == 16);
+
+static const byte FLAG_SINGLE_SIDED = 0x10;
+static const int  IDAM_FLAGS_MASK   = 0xC000;
+static const int  FLAG_MFM_SECTOR   = 0x8000;
+
+
+static bool isValidDmkHeader(const DmkHeader&amp; header)
+{
+	if (!((header.writeProtected == 0x00) ||
+	      (header.writeProtected == 0xff))) {
+		return false;
+	}
+	unsigned trackLen = header.trackLen[0] + 256 * header.trackLen[1];
+	if (trackLen &gt;= 0x4000) return false; // too large track length
+	if (trackLen &lt;= 128)    return false; // too small
+	if (header.flags &amp; ~0xd0) return false; // unknown flag set
+	for (int i = 0; i &lt; 7; ++i) {
+		if (header.reserved[i] != 0) return false;
+	}
+	for (int i = 0; i &lt; 4; ++i) {
+		if (header.format[i] != 0) return false;
+	}
+	return true;
+}
+
+DMKDiskImage::DMKDiskImage(Filename&amp; filename, shared_ptr&lt;File&gt; file_)
+	: Disk(filename)
+	, file(file_)
+{
+	DmkHeader header;
+	file-&gt;seek(0);
+	file-&gt;read(&amp;header, sizeof(header));
+	if (!isValidDmkHeader(header)) {
+		throw MSXException("Not a DMK image");
+	}
+
+	numTracks = header.numTracks;
+	dmkTrackLen = header.trackLen[0] + 256 * header.trackLen[1] - 128;
+	singleSided = header.flags &amp; FLAG_SINGLE_SIDED;
+	writeProtected = header.writeProtected == 0xff;
+
+	// TODO should we print a warning when dmkTrackLen is too far from the
+	//      ideal value RawTrack::SIZE? This might indicate the disk image
+	//      was not a 3.5" DD disk image and data will be lost on either
+	//      read or write.
+}
+
+void DMKDiskImage::seekTrack(byte track, byte side)
+{
+	unsigned t = singleSided ? track : (2 * track + side);
+	file-&gt;seek(sizeof(DmkHeader) + t * (dmkTrackLen + 128));
+}
+
+void DMKDiskImage::readTrack(byte track, byte side, RawTrack&amp; output)
+{
+	assert(side &lt; 2);
+	output.clear();
+	if ((singleSided &amp;&amp; side) || (track &gt;= numTracks)) {
+		// no such side/track, only clear output
+		return;
+	}
+
+	seekTrack(track, side);
+
+	// Read idam data (still needs to be converted).
+	byte idamBuf[2 * 64];
+	file-&gt;read(idamBuf, sizeof(idamBuf));
+
+	// Read raw track data. In case
+	//   dmkTrackLen &gt; RawTrack::SIZE : ignore extra data
+	//   dmkTrackLen &lt; RawTrack::SIZE : extra data initialized by clear()
+	file-&gt;read(output.getRawBuffer(), std::min(dmkTrackLen, RawTrack::SIZE));
+
+	// Convert idam data into an easier to work with internal format.
+	int lastIdam = -1;
+	for (int i = 0; i &lt; 64; ++i) {
+		int idx = idamBuf[2 * i + 0] + 256 * idamBuf[2 * i + 1];
+		if (idx == 0) break; // end of table reached
+
+		if ((idx &amp; IDAM_FLAGS_MASK) != FLAG_MFM_SECTOR) {
+			// single density (FM) sector not yet supported, ignore
+			continue;
+		}
+		idx &amp;= ~IDAM_FLAGS_MASK; // clear flags
+
+		if (idx &lt; 128) {
+			// Invalid IDAM offset, ignore
+			continue;
+		}
+		idx -= 128;
+		if (idx &gt;= dmkTrackLen) {
+			// Invalid IDAM offset, ignore
+			continue;
+		}
+
+		if (idx &lt;= lastIdam) {
+			// Invalid IDAM offset:
+			//   must be strictly bigger than previous, ignore
+			continue;
+		}
+
+		output.addIdam(idx);
+		lastIdam = idx;
+	}
+}
+
+void DMKDiskImage::writeTrackImpl(byte track, byte side, const RawTrack&amp; input)
+{
+	assert(side &lt; 2);
+	if ((singleSided &amp;&amp; side) || (track &gt;= numTracks)) {
+		// no such side/track, ignore write
+		// TODO a possible enhancement is to extend the file with
+		//      extra tracks (or even convert from single sided to
+		//      double sided)
+		return;
+	}
+
+	seekTrack(track, side);
+
+	// Write idam table.
+	byte idamOut[2 * 64] = {}; // zero-initialize
+	const vector&lt;int&gt;&amp; idamIn = input.getIdamBuffer();
+	for (int i = 0; i &lt; std::min&lt;int&gt;(64, idamIn.size()); ++i) {
+		int t = (idamIn[i] + 128) | FLAG_MFM_SECTOR;
+		idamOut[2 * i + 0] = t &amp; 0xff;
+		idamOut[2 * i + 1] = t &gt;&gt; 8;
+	}
+	file-&gt;write(idamOut, sizeof(idamOut));
+
+	// Write raw track data. In case
+	//   dmkTrackLen &gt; RawTrack::SIZE : extra bytes filled with 0x4e
+	//   dmkTrackLen &lt; RawTrack::SIZE : extra bytes are ignored
+	file-&gt;write(input.getRawBuffer(), std::min(dmkTrackLen, RawTrack::SIZE));
+	if (dmkTrackLen &gt; RawTrack::SIZE) {
+		vector&lt;byte&gt; pad(dmkTrackLen - RawTrack::SIZE, 0x4e);
+		file-&gt;write(&amp;pad[0], pad.size());
+	}
+}
+
+
+void DMKDiskImage::readSectorImpl(unsigned logicalSector, byte* buf)
+{
+	byte track, side, sector;
+	logToPhys(logicalSector, track, side, sector);
+	RawTrack rawTrack;
+	readTrack(track, side, rawTrack);
+
+	RawTrack::Sector sectorInfo;
+	if (!rawTrack.decodeSector(sector, sectorInfo)) {
+		throw NoSuchSectorException("Sector not found");
+	}
+	// TODO should we check sector size == 512?
+	//      crc errors? correct track/head?
+	rawTrack.readBlock(sectorInfo.dataIdx, 512, buf);
+}
+
+void DMKDiskImage::writeSectorImpl(unsigned logicalSector, const byte* buf)
+{
+	byte track, side, sector;
+	logToPhys(logicalSector, track, side, sector);
+	RawTrack rawTrack;
+	readTrack(track, side, rawTrack);
+
+	RawTrack::Sector sectorInfo;
+	if (!rawTrack.decodeSector(sector, sectorInfo)) {
+		throw NoSuchSectorException("Sector not found");
+	}
+	// TODO do checks? see readSectorImpl()
+	rawTrack.writeBlock(sectorInfo.dataIdx, 512, buf);
+
+	writeTrack(track, side, rawTrack);
+}
+
+unsigned DMKDiskImage::getNbSectorsImpl() const
+{
+	unsigned t = singleSided ? numTracks : (2 * numTracks);
+	return t * const_cast&lt;DMKDiskImage*&gt;(this)-&gt;getSectorsPerTrack();
+}
+
+bool DMKDiskImage::isWriteProtectedImpl() const
+{
+	return writeProtected || file-&gt;isReadOnly();
+}
+
+std::string DMKDiskImage::getSha1Sum()
+{
+	return file-&gt;getSha1Sum();
+}
+
+void DMKDiskImage::detectGeometryFallback()
+{
+	// The implementation in Disk::detectGeometryFallback() uses
+	// getNbSectors(), but for DMK images that doesn't work before we know
+	// the geometry.
+
+	// detectGeometryFallback() is for example used when the bootsector
+	// could not be read. For a DMK image this can happen when that sector
+	// has CRC errors or is missing or deleted.
+
+	setSectorsPerTrack(9);
+	setNbSides(singleSided ? 1 : 2);
+}
+
+} // namespace openmsx

Added: openmsx/trunk/src/fdc/DMKDiskImage.hh
===================================================================
--- openmsx/trunk/src/fdc/DMKDiskImage.hh	                        (rev 0)
+++ openmsx/trunk/src/fdc/DMKDiskImage.hh	2012-03-24 16:35:59 UTC (rev 12446)
@@ -0,0 +1,46 @@
+// $Id$
+
+#ifndef DMKDISKIMAGE_HH
+#define DMKDISKIMAGE_HH
+
+#include "Disk.hh"
+#include "shared_ptr.hh"
+#include &lt;vector&gt;
+
+namespace openmsx {
+
+class File;
+
+/** DMK disk image. See here for a description of the file format:
+  *   <a href="http://www.trs-80.com/wordpress/emulation-dmk-format/" rel="nofollow">http://www.trs-80.com/wordpress/emulation-dmk-format/</a>
+  */
+class DMKDiskImage : public Disk
+{
+public:
+	DMKDiskImage(Filename&amp; filename, shared_ptr&lt;File&gt; file);
+
+	virtual void readTrack(byte track, byte side, RawTrack&amp; output);
+	virtual void writeTrackImpl(byte track, byte side, const RawTrack&amp; input);
+
+	// logical sector emulation for SectorAccessibleDisk
+	virtual void readSectorImpl(unsigned sector, byte* buf);
+	virtual void writeSectorImpl(unsigned sector, const byte* buf);
+	virtual unsigned getNbSectorsImpl() const;
+	virtual bool isWriteProtectedImpl() const;
+	virtual std::string getSha1Sum();
+
+private:
+	virtual void detectGeometryFallback();
+
+	void seekTrack(byte track, byte side);
+
+	shared_ptr&lt;File&gt; file;
+	int numTracks;
+	int dmkTrackLen;
+	bool singleSided;
+	bool writeProtected;
+};
+
+} // namespace openmsx
+
+#endif

Modified: openmsx/trunk/src/fdc/DSKDiskImage.cc
===================================================================
--- openmsx/trunk/src/fdc/DSKDiskImage.cc	2012-03-24 16:35:36 UTC (rev 12445)
+++ openmsx/trunk/src/fdc/DSKDiskImage.cc	2012-03-24 16:35:59 UTC (rev 12446)
@@ -12,7 +12,7 @@
 	setNbSectors(file-&gt;getSize() / SECTOR_SIZE);
 }
 
-DSKDiskImage::DSKDiskImage(const Filename&amp; fileName, std::auto_ptr&lt;File&gt; file_)
+DSKDiskImage::DSKDiskImage(const Filename&amp; fileName, shared_ptr&lt;File&gt; file_)
 	: SectorBasedDisk(fileName)
 	, file(file_)
 {

Modified: openmsx/trunk/src/fdc/DSKDiskImage.hh
===================================================================
--- openmsx/trunk/src/fdc/DSKDiskImage.hh	2012-03-24 16:35:36 UTC (rev 12445)
+++ openmsx/trunk/src/fdc/DSKDiskImage.hh	2012-03-24 16:35:59 UTC (rev 12446)
@@ -4,7 +4,7 @@
 #define DSKDISKIMAGE_HH
 
 #include "SectorBasedDisk.hh"
-#include &lt;memory&gt;
+#include "shared_ptr.hh"
 
 namespace openmsx {
 
@@ -14,7 +14,7 @@
 {
 public:
 	explicit DSKDiskImage(const Filename&amp; filename);
-	DSKDiskImage(const Filename&amp; filename, std::auto_ptr&lt;File&gt; file);
+	DSKDiskImage(const Filename&amp; filename, shared_ptr&lt;File&gt; file);
 	virtual ~DSKDiskImage();
 
 private:
@@ -23,7 +23,7 @@
 	virtual bool isWriteProtectedImpl() const;
 	virtual std::string getSha1Sum();
 
-	const std::auto_ptr&lt;File&gt; file;
+	const shared_ptr&lt;File&gt; file;
 };
 
 } // namespace openmsx

Modified: openmsx/trunk/src/fdc/Disk.hh
===================================================================
--- openmsx/trunk/src/fdc/Disk.hh	2012-03-24 16:35:36 UTC (rev 12445)
+++ openmsx/trunk/src/fdc/Disk.hh	2012-03-24 16:35:59 UTC (rev 12446)
@@ -31,6 +31,7 @@
 	void logToPhys(int log, byte&amp; track, byte&amp; side, byte&amp; sector);
 
 	virtual void detectGeometry();
+	virtual void detectGeometryFallback();
 
 	void setSectorsPerTrack(unsigned num);
 	unsigned getSectorsPerTrack();
@@ -39,8 +40,6 @@
 	virtual void writeTrackImpl(byte track, byte side, const RawTrack&amp; input) = 0;
 
 private:
-	void detectGeometryFallback();
-
 	const DiskName name;
 	unsigned sectorsPerTrack;
 	unsigned nbSides;

Modified: openmsx/trunk/src/fdc/DiskFactory.cc
===================================================================
--- openmsx/trunk/src/fdc/DiskFactory.cc	2012-03-24 16:35:36 UTC (rev 12445)
+++ openmsx/trunk/src/fdc/DiskFactory.cc	2012-03-24 16:35:59 UTC (rev 12446)
@@ -7,6 +7,7 @@
 #include "FileContext.hh"
 #include "DSKDiskImage.hh"
 #include "XSADiskImage.hh"
+#include "DMKDiskImage.hh"
 #include "RamDSKDiskImage.hh"
 #include "DirAsDSK.hh"
 #include "DiskPartition.hh"
@@ -62,7 +63,7 @@
 		// DirAsDSK didn't work, no problem
 	}
 	try {
-		std::auto_ptr&lt;File&gt; file(new File(filename, File::PRE_CACHE));
+		shared_ptr&lt;File&gt; file(new File(filename, File::PRE_CACHE));
 		file-&gt;setFilePool(reactor.getFilePool());
 
 		try {
@@ -71,6 +72,13 @@
 		} catch (MSXException&amp;) {
 			// XSA didn't work, still no problem
 		}
+		try {
+			// next try dmk
+			file-&gt;seek(0);
+			return new DMKDiskImage(filename, file);
+		} catch (MSXException&amp; e) {
+			// DMK didn't work, still no problem
+		}
 		// next try normal DSK
 		return new DSKDiskImage(filename, file);
 

Modified: openmsx/trunk/src/fdc/RawTrack.hh
===================================================================
--- openmsx/trunk/src/fdc/RawTrack.hh	2012-03-24 16:35:36 UTC (rev 12445)
+++ openmsx/trunk/src/fdc/RawTrack.hh	2012-03-24 16:35:59 UTC (rev 12446)
@@ -93,6 +93,10 @@
 	byte read(int idx) const { return data[idx % SIZE]; }
 	void write(int idx, byte val) { data[idx % SIZE] = val; }
 
+	      byte* getRawBuffer()       { return data; }
+	const byte* getRawBuffer() const { return data; }
+	const std::vector&lt;int&gt;&amp; getIdamBuffer() const { return idam; }
+
 	/** Get info on all sectors in this track. */
 	std::vector&lt;Sector&gt; decodeAll() const;
 

Modified: openmsx/trunk/src/fdc/node.mk
===================================================================
--- openmsx/trunk/src/fdc/node.mk	2012-03-24 16:35:36 UTC (rev 12445)
+++ openmsx/trunk/src/fdc/node.mk	2012-03-24 16:35:59 UTC (rev 12446)
@@ -26,6 +26,7 @@
 	DummyDisk \
 	DSKDiskImage \
 	XSADiskImage \
+	DMKDiskImage \
 	DirAsDSK \
 	EmptyDiskPatch \
 	RamDSKDiskImage \

This was sent by the SourceForge.net collaborative development platform, the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg29031625">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29031625/">[openMSX-commits] SF.net SVN: openmsx:[12445] openmsx/trunk/src/fdc</a></b></div>
      
      <small>From: &lt;m9710797@us...&gt; - 2012-03-24 16:35:48</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12445
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12445&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12445&amp;view=rev</a>
Author:   m9710797
Date:     2012-03-24 16:35:36 +0000 (Sat, 24 Mar 2012)
Log Message:
-----------
Removed old low-level Disk/DiskDrive access interface

As mentioned in the previous patches: the WD2793 and TC8566AF controllers
have been converted from the old to the new Disk interface, so now the old
interface can be removed.

Note that many of the methods in the old interface were never used (e.g.
readTrackData()) or even never implemented (getTrackHeader(),
getSectorHeader()) or implemented but at the wrong place
(SectorBasedDisk::writeTrackDataImpl() that knew about WD2793 commands).

Modified Paths:
--------------
    openmsx/trunk/src/fdc/Disk.cc
    openmsx/trunk/src/fdc/Disk.hh
    openmsx/trunk/src/fdc/DiskDrive.cc
    openmsx/trunk/src/fdc/DiskDrive.hh
    openmsx/trunk/src/fdc/DriveMultiplexer.cc
    openmsx/trunk/src/fdc/DriveMultiplexer.hh
    openmsx/trunk/src/fdc/RealDrive.cc
    openmsx/trunk/src/fdc/RealDrive.hh
    openmsx/trunk/src/fdc/SectorBasedDisk.cc
    openmsx/trunk/src/fdc/SectorBasedDisk.hh

Modified: openmsx/trunk/src/fdc/Disk.cc
===================================================================
--- openmsx/trunk/src/fdc/Disk.cc	2012-03-24 16:35:10 UTC (rev 12444)
+++ openmsx/trunk/src/fdc/Disk.cc	2012-03-24 16:35:36 UTC (rev 12445)
@@ -21,46 +21,6 @@
 	return name;
 }
 
-void Disk::write(byte track, byte sector,
-                 byte side, unsigned size, const byte* buf)
-{
-	if (isWriteProtected()) {
-		throw WriteProtectedException("");
-	}
-	writeImpl(track, sector, side, size, buf);
-}
-
-void Disk::writeTrackData(byte track, byte side, const byte* data)
-{
-	if (isWriteProtected()) {
-		throw WriteProtectedException("");
-	}
-	writeTrackDataImpl(track, side, data);
-}
-
-void Disk::getTrackHeader(byte /*track*/, byte /*side*/, byte* /*buf*/)
-{
-	PRT_DEBUG("Disk::getTrackHeader [unimplemented]");
-}
-void Disk::getSectorHeader(byte /*track*/, byte /*sector*/, byte /*side*/,
-                           byte* /*buf*/)
-{
-	PRT_DEBUG("Disk::getSectorHeader [unimplemented]");
-}
-
-void Disk::writeTrackDataImpl(byte /*track*/, byte /*side*/, const byte* /*data*/)
-{
-	PRT_DEBUG("Disk::writeTrackData [unimplemented]");
-}
-
-void Disk::readTrackData(byte /*track*/, byte /*side*/, byte* output)
-{
-	PRT_DEBUG("Disk::readTrackData [unimplemented]");
-	for (int i = 0; i &lt; RAWTRACK_SIZE; ++i) {
-		output[i] = 0xF4;
-	}
-}
-
 void Disk::writeTrack(byte track, byte side, const RawTrack&amp; input)
 {
 	if (isWriteProtected()) {

Modified: openmsx/trunk/src/fdc/Disk.hh
===================================================================
--- openmsx/trunk/src/fdc/Disk.hh	2012-03-24 16:35:10 UTC (rev 12444)
+++ openmsx/trunk/src/fdc/Disk.hh	2012-03-24 16:35:36 UTC (rev 12445)
@@ -13,25 +13,10 @@
 class Disk : public SectorAccessibleDisk
 {
 public:
-	// TODO This should be 6250 (see calculation in RawTrack), but it will
-	//      soon be replaced.
-	static const int RAWTRACK_SIZE = 6850;
-
 	virtual ~Disk();
 
 	const DiskName&amp; getName() const;
 
-	virtual void read(byte track, byte sector,
-	                  byte side, unsigned size, byte* buf) = 0;
-	void write(byte track, byte sector,
-	           byte side, unsigned size, const byte* buf);
-	virtual void getSectorHeader(byte track, byte sector,
-	                             byte side, byte* buf);
-	virtual void getTrackHeader(byte track,
-	                            byte side, byte* buf);
-	void writeTrackData(byte track, byte side, const byte* data);
-	virtual void readTrackData(byte track, byte side, byte* output);
-
 	/** Replace a full track in this image with the given track. */
 	        void writeTrack(byte track, byte side, const RawTrack&amp; input);
 
@@ -51,9 +36,6 @@
 	unsigned getSectorsPerTrack();
 	void setNbSides(unsigned num);
 
-	virtual void writeImpl(byte track, byte sector,
-	                       byte side, unsigned size, const byte* buf) = 0;
-	virtual void writeTrackDataImpl(byte track, byte side, const byte* data);
 	virtual void writeTrackImpl(byte track, byte side, const RawTrack&amp; input) = 0;
 
 private:

Modified: openmsx/trunk/src/fdc/DiskDrive.cc
===================================================================
--- openmsx/trunk/src/fdc/DiskDrive.cc	2012-03-24 16:35:10 UTC (rev 12444)
+++ openmsx/trunk/src/fdc/DiskDrive.cc	2012-03-24 16:35:36 UTC (rev 12445)
@@ -55,11 +55,6 @@
 	return false;
 }
 
-EmuTime DummyDrive::getTimeTillSector(byte /*sector*/, EmuTime::param time)
-{
-	return time;
-}
-
 EmuTime DummyDrive::getTimeTillIndexPulse(EmuTime::param time)
 {
 	return time;
@@ -75,35 +70,6 @@
 	return false;
 }
 
-void DummyDrive::read(byte /*sector*/, byte* /*buf*/,
-                      byte&amp; /*onDiskTrack*/, byte&amp; /*onDiskSector*/,
-                      byte&amp; /*onDiskSide*/,  int&amp;  /*onDiskSize*/)
-{
-	throw DriveEmptyException("No drive connected");
-}
-
-void DummyDrive::write(byte /*sector*/, const byte* /*buf*/,
-                       byte&amp; /*onDiskTrack*/, byte&amp; /*onDiskSector*/,
-                       byte&amp; /*onDiskSide*/,  int&amp; /*onDiskSize*/)
-{
-	throw DriveEmptyException("No drive connected");
-}
-
-void DummyDrive::getSectorHeader(byte /*sector*/, byte* /*buf*/)
-{
-	throw DriveEmptyException("No drive connected");
-}
-
-void DummyDrive::getTrackHeader(byte* /*buf*/)
-{
-	throw DriveEmptyException("No drive connected");
-}
-
-void DummyDrive::writeTrackData(const byte* /*data*/)
-{
-	// ignore ???
-}
-
 void DummyDrive::writeTrack(const RawTrack&amp; /*track*/)
 {
 	assert(false);

Modified: openmsx/trunk/src/fdc/DiskDrive.hh
===================================================================
--- openmsx/trunk/src/fdc/DiskDrive.hh	2012-03-24 16:35:10 UTC (rev 12444)
+++ openmsx/trunk/src/fdc/DiskDrive.hh	2012-03-24 16:35:36 UTC (rev 12445)
@@ -59,16 +59,6 @@
 	 */
 	virtual bool indexPulse(EmuTime::param time) = 0;
 
-	/** Return the time when the indicated sector will be rotated under
-	 * the drive head.
-	 * TODO what when the requested sector is not present? For the moment
-	 * returns the current time.
-	 * @param sector The requested sector number
-	 * @param time The current time
-	 * @return Time when the requested sector is under the drive head.
-	 */
-	virtual EmuTime getTimeTillSector(byte sector, EmuTime::param time) = 0;
-
 	/** Return the time till the start of the next index pulse
 	 * When there is no disk in the drive or when the disk is not spinning,
 	 * this function returns the current time.
@@ -87,18 +77,6 @@
 	 */
 	virtual bool headLoaded(EmuTime::param time) = 0;
 
-	// TODO
-	// Read / write methods, mostly copied from Disk,
-	// but needs to be reworked
-	virtual void read (byte sector, byte* buf,
-	                   byte&amp; onDiskTrack, byte&amp; onDiskSector,
-	                   byte&amp; onDiskSide,  int&amp; onDiskSize) = 0;
-	virtual void write(byte sector, const byte* buf,
-	                   byte&amp; onDiskTrack, byte&amp; onDiskSector,
-	                   byte&amp; onDiskSide,  int&amp; onDiskSize) = 0;
-	virtual void getSectorHeader(byte sector, byte* buf) = 0;
-	virtual void getTrackHeader(byte* buf) = 0;
-	virtual void writeTrackData(const byte* data) = 0;
 	virtual void writeTrack(const RawTrack&amp; track) = 0;
 	virtual void readTrack (      RawTrack&amp; track) = 0;
 	virtual EmuTime getNextSector(EmuTime::param time, RawTrack&amp; track,
@@ -129,19 +107,9 @@
 	virtual void step(bool direction, EmuTime::param time);
 	virtual void setMotor(bool status, EmuTime::param time);
 	virtual bool indexPulse(EmuTime::param time);
-	virtual EmuTime getTimeTillSector(byte sector, EmuTime::param time);
 	virtual EmuTime getTimeTillIndexPulse(EmuTime::param time);
 	virtual void setHeadLoaded(bool status, EmuTime::param time);
 	virtual bool headLoaded(EmuTime::param time);
-	virtual void read (byte sector, byte* buf,
-	                   byte&amp; onDiskTrack, byte&amp; onDiskSector,
-	                   byte&amp; onDiskSide,  int&amp;  onDiskSize);
-	virtual void write(byte sector, const byte* buf,
-	                   byte&amp; onDiskTrack, byte&amp; onDiskSector,
-	                   byte&amp; onDiskSide,  int&amp;  onDiskSize);
-	virtual void getSectorHeader(byte sector, byte* buf);
-	virtual void getTrackHeader(byte* buf);
-	virtual void writeTrackData(const byte* data);
 	virtual void writeTrack(const RawTrack&amp; track);
 	virtual void readTrack (      RawTrack&amp; track);
 	virtual EmuTime getNextSector(EmuTime::param time, RawTrack&amp; track,

Modified: openmsx/trunk/src/fdc/DriveMultiplexer.cc
===================================================================
--- openmsx/trunk/src/fdc/DriveMultiplexer.cc	2012-03-24 16:35:10 UTC (rev 12444)
+++ openmsx/trunk/src/fdc/DriveMultiplexer.cc	2012-03-24 16:35:36 UTC (rev 12445)
@@ -74,11 +74,6 @@
 	return drive[selected]-&gt;indexPulse(time);
 }
 
-EmuTime DriveMultiplexer::getTimeTillSector(byte sector, EmuTime::param time)
-{
-	return drive[selected]-&gt;getTimeTillSector(sector, time);
-}
-
 EmuTime DriveMultiplexer::getTimeTillIndexPulse(EmuTime::param time)
 {
 	return drive[selected]-&gt;getTimeTillIndexPulse(time);
@@ -94,37 +89,6 @@
 	return drive[selected]-&gt;headLoaded(time);
 }
 
-void DriveMultiplexer::read(byte sector, byte* buf,
-                            byte&amp; onDiskTrack, byte&amp; onDiskSector,
-                            byte&amp; onDiskSide,  int&amp;  onDiskSize)
-{
-	drive[selected]-&gt;read(sector, buf, onDiskTrack,
-	                      onDiskSector, onDiskSide, onDiskSize);
-}
-
-void DriveMultiplexer::write(byte sector, const byte* buf,
-                             byte&amp; onDiskTrack, byte&amp; onDiskSector,
-                             byte&amp; onDiskSide,  int&amp;  onDiskSize)
-{
-	drive[selected]-&gt;write(sector, buf, onDiskTrack,
-	                       onDiskSector, onDiskSide, onDiskSize);
-}
-
-void DriveMultiplexer::getSectorHeader(byte sector, byte* buf)
-{
-	drive[selected]-&gt;getSectorHeader(sector, buf);
-}
-
-void DriveMultiplexer::getTrackHeader(byte* buf)
-{
-	drive[selected]-&gt;getTrackHeader(buf);
-}
-
-void DriveMultiplexer::writeTrackData(const byte* data)
-{
-	drive[selected]-&gt;writeTrackData(data);
-}
-
 void DriveMultiplexer::writeTrack(const RawTrack&amp; track)
 {
 	drive[selected]-&gt;writeTrack(track);

Modified: openmsx/trunk/src/fdc/DriveMultiplexer.hh
===================================================================
--- openmsx/trunk/src/fdc/DriveMultiplexer.hh	2012-03-24 16:35:10 UTC (rev 12444)
+++ openmsx/trunk/src/fdc/DriveMultiplexer.hh	2012-03-24 16:35:36 UTC (rev 12445)
@@ -36,19 +36,9 @@
 	virtual void step(bool direction, EmuTime::param time);
 	virtual void setMotor(bool status, EmuTime::param time);
 	virtual bool indexPulse(EmuTime::param time);
-	virtual EmuTime getTimeTillSector(byte sector, EmuTime::param time);
 	virtual EmuTime getTimeTillIndexPulse(EmuTime::param time);
 	virtual void setHeadLoaded(bool status, EmuTime::param time);
 	virtual bool headLoaded(EmuTime::param time);
-	virtual void read (byte sector, byte* buf,
-	                   byte&amp; onDiskTrack, byte&amp; onDiskSector,
-	                   byte&amp; onDiskSide,  int&amp;  onDiskSize);
-	virtual void write(byte sector, const byte* buf,
-	                   byte&amp; onDiskTrack, byte&amp; onDiskSector,
-	                   byte&amp; onDiskSide,  int&amp;  onDiskSize);
-	virtual void getSectorHeader(byte sector, byte* buf);
-	virtual void getTrackHeader(byte* buf);
-	virtual void writeTrackData(const byte* data);
 	virtual void writeTrack(const RawTrack&amp; track);
 	virtual void readTrack (      RawTrack&amp; track);
 	virtual EmuTime getNextSector(EmuTime::param time, RawTrack&amp; track,

Modified: openmsx/trunk/src/fdc/RealDrive.cc
===================================================================
--- openmsx/trunk/src/fdc/RealDrive.cc	2012-03-24 16:35:10 UTC (rev 12444)
+++ openmsx/trunk/src/fdc/RealDrive.cc	2012-03-24 16:35:36 UTC (rev 12445)
@@ -245,34 +245,6 @@
 	return angle &lt; INDEX_DURATION;
 }
 
-EmuTime RealDrive::getTimeTillSector(byte sector, EmuTime::param time)
-{
-	if (!motorStatus || !isDiskInserted()) { // TODO is this correct?
-		return time;
-	}
-	// TODO this really belongs in the Disk class
-	int delta;
-	if (sector == 0) {
-		// there is no sector 0 on normal disks, but it triggers with
-		// the following command:
-		//    openmsx -machine Sony_HB-F700D -ext msxdos2 -diska dos2.dsk
-		// we'll just search for a complete rotation
-		delta = TICKS_PER_ROTATION - 1;
-	} else {
-		int sectorAngle = ((sector - 1) * (TICKS_PER_ROTATION / 9)) %
-				  TICKS_PER_ROTATION;
-
-		int angle = motorTimer.getTicksTill(time) % TICKS_PER_ROTATION;
-		delta = sectorAngle - angle;
-		if (delta &lt; 0) delta += TICKS_PER_ROTATION;
-	}
-	assert((0 &lt;= delta) &amp;&amp; (delta &lt; TICKS_PER_ROTATION));
-
-	EmuDuration dur = Clock&lt;TICKS_PER_ROTATION * ROTATIONS_PER_SECOND&gt;::
-	                      duration(delta);
-	return time + dur;
-}
-
 EmuTime RealDrive::getTimeTillIndexPulse(EmuTime::param time)
 {
 	if (!motorStatus || !isDiskInserted()) { // TODO is this correct?
@@ -298,43 +270,6 @@
 	       (headLoadTimer.getTicksTill(time) &gt; 10);
 }
 
-void RealDrive::read(byte sector, byte* buf,
-                     byte&amp; onDiskTrack, byte&amp; onDiskSector,
-                     byte&amp; onDiskSide,  int&amp;  onDiskSize)
-{
-	onDiskTrack = headPos;
-	onDiskSector = sector;
-	onDiskSide = side;
-	onDiskSize = 512;
-	changer-&gt;getDisk().read(headPos, sector, side, 512, buf);
-}
-
-void RealDrive::write(byte sector, const byte* buf,
-                      byte&amp; onDiskTrack, byte&amp; onDiskSector,
-                      byte&amp; onDiskSide,  int&amp;  onDiskSize)
-{
-	onDiskTrack = headPos;
-	onDiskSector = sector;
-	onDiskSide = side;
-	onDiskSize = 512;
-	changer-&gt;getDisk().write(headPos, sector, side, 512, buf);
-}
-
-void RealDrive::getSectorHeader(byte sector, byte* buf)
-{
-	changer-&gt;getDisk().getSectorHeader(headPos, sector, side, buf);
-}
-
-void RealDrive::getTrackHeader(byte* buf)
-{
-	changer-&gt;getDisk().getTrackHeader(headPos, side, buf);
-}
-
-void RealDrive::writeTrackData(const byte* data)
-{
-	changer-&gt;getDisk().writeTrackData(headPos, side, data);
-}
-
 void RealDrive::writeTrack(const RawTrack&amp; track)
 {
 	changer-&gt;getDisk().writeTrack(headPos, side, track);

Modified: openmsx/trunk/src/fdc/RealDrive.hh
===================================================================
--- openmsx/trunk/src/fdc/RealDrive.hh	2012-03-24 16:35:10 UTC (rev 12444)
+++ openmsx/trunk/src/fdc/RealDrive.hh	2012-03-24 16:35:36 UTC (rev 12445)
@@ -33,19 +33,9 @@
 	virtual void step(bool direction, EmuTime::param time);
 	virtual void setMotor(bool status, EmuTime::param time);
 	virtual bool indexPulse(EmuTime::param time);
-	virtual EmuTime getTimeTillSector(byte sector, EmuTime::param time);
 	virtual EmuTime getTimeTillIndexPulse(EmuTime::param time);
 	virtual void setHeadLoaded(bool status, EmuTime::param time);
 	virtual bool headLoaded(EmuTime::param time);
-	virtual void read (byte sector, byte* buf,
-	                   byte&amp; onDiskTrack, byte&amp; onDiskSector,
-	                   byte&amp; onDiskSide,  int&amp;  onDiskSize);
-	virtual void write(byte sector, const byte* buf,
-	                   byte&amp; onDiskTrack, byte&amp; onDiskSector,
-	                   byte&amp; onDiskSide,  int&amp;  onDiskSize);
-	virtual void getSectorHeader(byte sector, byte* buf);
-	virtual void getTrackHeader(byte* buf);
-	virtual void writeTrackData(const byte* data);
 	virtual void writeTrack(const RawTrack&amp; track);
 	virtual void readTrack (      RawTrack&amp; track);
 	virtual EmuTime getNextSector(EmuTime::param time, RawTrack&amp; track,

Modified: openmsx/trunk/src/fdc/SectorBasedDisk.cc
===================================================================
--- openmsx/trunk/src/fdc/SectorBasedDisk.cc	2012-03-24 16:35:10 UTC (rev 12444)
+++ openmsx/trunk/src/fdc/SectorBasedDisk.cc	2012-03-24 16:35:36 UTC (rev 12445)
@@ -18,111 +18,6 @@
 {
 }
 
-void SectorBasedDisk::read(byte track, byte sector, byte side,
-                           unsigned size, byte* buf)
-{
-	(void)size;
-	assert(size == SECTOR_SIZE);
-	unsigned logicalSector = physToLog(track, side, sector);
-	readSector(logicalSector, buf);
-}
-
-void SectorBasedDisk::writeImpl(byte track, byte sector, byte side,
-                                unsigned size, const byte* buf)
-{
-	(void)size;
-	assert(size == SECTOR_SIZE);
-	unsigned logicalSector = physToLog(track, side, sector);
-	writeSector(logicalSector, buf);
-	// it's important to use writeSector() and not writeSectorImpl()
-	// because only the former flushes SHA1 cache
-}
-
-void SectorBasedDisk::writeTrackDataImpl(byte track, byte side, const byte* data)
-{
-	unsigned sector = 1;
-	bool hasFirstCRC = false;
-	for (int i = 0; i &lt; RAWTRACK_SIZE; ++i) {
-		// Look for two 0xF7 bytes (two CRC characters)
-		// the first is the CRC for the sector header, the second is
-		// for the actual sector data.
-		// TODO this seems WD2793 specific, we might have to fix this
-		//      once we implement more FDC write-raw-track commands
-		if (data[i] == 0xF7) {
-			if (!hasFirstCRC) {
-				hasFirstCRC = true;
-				// ... still wait for 2nd CRC byte ...
-			} else {
-				// ... found it, previous 512 bytes are sector data
-				hasFirstCRC = false;
-				if (i &gt;= 512) {
-					write(track, sector, side, 512,
-					      &amp;data[i - 512]);
-				}
-				++sector;
-			}
-		}
-	}
-}
-
-void SectorBasedDisk::readTrackData(byte track, byte side, byte* output)
-{
-	// init following data structure
-	// according to Alex Wulms
-	// 122 bytes track header aka pre-gap
-	// 9 * 628 bytes sectordata (sector header, data en closure gap)
-	// 1080 bytes end-of-track gap
-	//
-	// This data comes from the TC8566AF manual
-	// each track in IBM format contains
-	//   '4E' x 80, '00' x 12, 'C2' x 3
-	//   'FC' x  1, '4E' x 50
-	//   sector data 1 to n
-	//   '4E' x ?? (closing gap)
-	// each sector data contains
-	//   '00' x 12, 'A1' x 3, 'FE' x 1,
-	//   C,H,R,N,CRC(2bytes), '4E' x 22, '00' x 12,
-	//   'A1' x  4,'FB'('F8') x 1, data(512 bytes),CRC(2bytes),'4E'(gap3)
-
-	byte* out = output;
-
-	// track header
-	for (int i = 0; i &lt; 80; ++i) *out++ = 0x4E;
-	for (int i = 0; i &lt; 12; ++i) *out++ = 0x00;
-	for (int i = 0; i &lt;  3; ++i) *out++ = 0xC2;
-	for (int i = 0; i &lt;  1; ++i) *out++ = 0xFC;
-	for (int i = 0; i &lt; 50; ++i) *out++ = 0x4E;
-	assert((out - output) == 146); // correct length?
-
-	// sectors
-	for (int j = 0; j &lt; 9; ++j) {
-		// sector header
-		for (int i = 0; i &lt; 12; ++i) *out++ = 0x00;
-		for (int i = 0; i &lt;  3; ++i) *out++ = 0xA1;
-		for (int i = 0; i &lt;  1; ++i) *out++ = 0xFE;
-		*out++ = track; // C: Cylinder number
-		*out++ = side;  // H: Head Address
-		*out++ = j + 1; // R: Record
-		*out++ = 0x02;  // N: Number (length of sector)
-		*out++ = 0x00;  // CRC byte 1   TODO
-		*out++ = 0x00;  // CRC byte 2
-		for (int i = 0; i &lt; 22; ++i) *out++ = 0x4E;
-		for (int i = 0; i &lt; 12; ++i) *out++ = 0x00;
-		// sector data
-		read(track, j + 1, side, 512, out);
-		out += 512;
-		*out++ = 0x00;  // CRC byte 1   TODO
-		*out++ = 0x00;  // CRC byte 2
-		// end-of-sector gap
-		for (int i = 0; i &lt; 58; ++i) *out++ = 0x4E;
-	}
-	assert((out - output) == (146 + 9 * 628)); // correct length?
-
-	// end-of-track gap
-	for (int i = 0; i &lt; 1052; ++i) *out++ = 0x4E;
-	assert((out - output) == RAWTRACK_SIZE);
-}
-
 void SectorBasedDisk::writeTrackImpl(byte track, byte side, const RawTrack&amp; input)
 {
 	std::vector&lt;RawTrack::Sector&gt; sectors = input.decodeAll();

Modified: openmsx/trunk/src/fdc/SectorBasedDisk.hh
===================================================================
--- openmsx/trunk/src/fdc/SectorBasedDisk.hh	2012-03-24 16:35:10 UTC (rev 12444)
+++ openmsx/trunk/src/fdc/SectorBasedDisk.hh	2012-03-24 16:35:36 UTC (rev 12445)
@@ -24,12 +24,6 @@
 private:
 	// Disk
 	virtual unsigned getNbSectorsImpl() const;
-	virtual void read(byte track, byte sector, byte side,
-	                  unsigned size, byte* buf);
-	virtual void readTrackData(byte track, byte side, byte* output);
-	virtual void writeImpl(byte track, byte sector, byte side,
-	                       unsigned size, const byte* buf);
-	virtual void writeTrackDataImpl(byte track, byte side, const byte* data);
 	virtual void readTrack(byte track, byte side, RawTrack&amp; output);
 	virtual void writeTrackImpl(byte track, byte side, const RawTrack&amp; input);
 

This was sent by the SourceForge.net collaborative development platform, the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg29031624">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29031624/">[openMSX-commits] SF.net SVN: openmsx:[12444] openmsx/trunk/src/fdc</a></b></div>
      
      <small>From: &lt;m9710797@us...&gt; - 2012-03-24 16:35:22</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12444
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12444&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12444&amp;view=rev</a>
Author:   m9710797
Date:     2012-03-24 16:35:10 +0000 (Sat, 24 Mar 2012)
Log Message:
-----------
Converted TC8566AF to the new low level Disk interface

This is similar to the previous patch which did the same for WD2793. Compared
to the WD2793 class, the TC8566AF is still a lot less accurate (both timing and
feature wise). Though I believe that for most disk protection schemes the
current implementation will already be good enough.

Modified Paths:
--------------
    openmsx/trunk/src/fdc/TC8566AF.cc
    openmsx/trunk/src/fdc/TC8566AF.hh
    openmsx/trunk/src/fdc/TurboRFDC.cc

Modified: openmsx/trunk/src/fdc/TC8566AF.cc
===================================================================
--- openmsx/trunk/src/fdc/TC8566AF.cc	2012-03-24 16:34:52 UTC (rev 12443)
+++ openmsx/trunk/src/fdc/TC8566AF.cc	2012-03-24 16:35:10 UTC (rev 12444)
@@ -7,62 +7,69 @@
 
 #include "TC8566AF.hh"
 #include "DiskDrive.hh"
+#include "CliComm.hh"
 #include "MSXException.hh"
 #include "serialize.hh"
 #include &lt;cstring&gt;
 
 namespace openmsx {
 
-static const byte STM_DB0 = 0x01;
-static const byte STM_DB1 = 0x02;
-static const byte STM_DB2 = 0x04;
-static const byte STM_DB3 = 0x08;
-static const byte STM_CB  = 0x10;
-static const byte STM_NDM = 0x20;
-static const byte STM_DIO = 0x40;
-static const byte STM_RQM = 0x80;
+static const byte STM_DB0 = 0x01; // FDD 0 Busy
+static const byte STM_DB1 = 0x02; // FDD 1 Busy
+static const byte STM_DB2 = 0x04; // FDD 2 Busy
+static const byte STM_DB3 = 0x08; // FDD 3 Busy
+static const byte STM_CB  = 0x10; // FDC Busy
+static const byte STM_NDM = 0x20; // Non-DMA mode
+static const byte STM_DIO = 0x40; // Data Input/Output
+static const byte STM_RQM = 0x80; // Request for Master
 
-static const byte ST0_DS0 = 0x01;
-static const byte ST0_DS1 = 0x02;
-static const byte ST0_HD  = 0x04;
-static const byte ST0_NR  = 0x08;
-static const byte ST0_EC  = 0x10;
-static const byte ST0_SE  = 0x20;
-static const byte ST0_IC0 = 0x40;
-static const byte ST0_IC1 = 0x80;
+static const byte ST0_DS0 = 0x01; // Drive Select 0,1
+static const byte ST0_DS1 = 0x02; //
+static const byte ST0_HD  = 0x04; // Head Address
+static const byte ST0_NR  = 0x08; // Not Ready
+static const byte ST0_EC  = 0x10; // Equipment Check
+static const byte ST0_SE  = 0x20; // Seek End
+static const byte ST0_IC0 = 0x40; // Interrupt Code
+static const byte ST0_IC1 = 0x80; //
 
-static const byte ST1_MA  = 0x01;
-static const byte ST1_NW  = 0x02;
-static const byte ST1_ND  = 0x04;
-static const byte ST1_OR  = 0x10;
-static const byte ST1_DE  = 0x20;
-static const byte ST1_EN  = 0x80;
+static const byte ST1_MA  = 0x01; // Missing Address Mark
+static const byte ST1_NW  = 0x02; // Not Writable
+static const byte ST1_ND  = 0x04; // No Data
+//                        = 0x08; // -
+static const byte ST1_OR  = 0x10; // Over Run
+static const byte ST1_DE  = 0x20; // Data Error
+//                        = 0x40; // -
+static const byte ST1_EN  = 0x80; // End of Cylinder
 
-static const byte ST2_MD  = 0x01;
-static const byte ST2_BC  = 0x02;
-static const byte ST2_SN  = 0x04;
-static const byte ST2_SH  = 0x08;
-static const byte ST2_NC  = 0x10;
-static const byte ST2_DD  = 0x20;
-static const byte ST2_CM  = 0x40;
+static const byte ST2_MD  = 0x01; // Missing Address Mark in Data Field
+static const byte ST2_BC  = 0x02; // Bad Cylinder
+static const byte ST2_SN  = 0x04; // Scan Not Satisfied
+static const byte ST2_SH  = 0x08; // Scan Equal Satisfied
+static const byte ST2_NC  = 0x10; // No cylinder
+static const byte ST2_DD  = 0x20; // Data Error in Data Field
+static const byte ST2_CM  = 0x40; // Control Mark
+//                        = 0x80; // -
 
-static const byte ST3_DS0 = 0x01;
-static const byte ST3_DS1 = 0x02;
-static const byte ST3_HD  = 0x04;
-static const byte ST3_2S  = 0x08;
-static const byte ST3_TK0 = 0x10;
-static const byte ST3_RDY = 0x20;
-static const byte ST3_WP  = 0x40;
-static const byte ST3_FLT = 0x80;
+static const byte ST3_DS0 = 0x01; // Drive Select 0
+static const byte ST3_DS1 = 0x02; // Drive Select 1
+static const byte ST3_HD  = 0x04; // Head Address
+static const byte ST3_2S  = 0x08; // Two Side
+static const byte ST3_TK0 = 0x10; // Track 0
+static const byte ST3_RDY = 0x20; // Ready
+static const byte ST3_WP  = 0x40; // Write Protect
+static const byte ST3_FLT = 0x80; // Fault
 
 
-TC8566AF::TC8566AF(Scheduler&amp; scheduler, DiskDrive* drv[4], EmuTime::param time)
+TC8566AF::TC8566AF(Scheduler&amp; scheduler, DiskDrive* drv[4], CliComm&amp; cliComm_,
+                   EmuTime::param time)
 	: Schedulable(scheduler)
+	, cliComm(cliComm_)
 	, delayTime(EmuTime::zero)
 	, headUnloadTime(EmuTime::zero) // head not loaded
 {
 	// avoid UMR (on savestate)
-	memset(sectorBuf, 0, sizeof(sectorBuf));
+	dataAvailable = 0;
+	dataCurrent = 0;
 
 	drive[0] = drv[0];
 	drive[1] = drv[1];
@@ -96,8 +103,7 @@
 	currentTrack = 0;
 	sectorsPerCylinder = 0;
 	fillerByte = 0;
-	sectorSize = 0;
-	sectorOffset = 0;
+	gapLength = 0;
 	specifyData[0] = 0; // TODO check
 	specifyData[1] = 0; // TODO check
 	seekValue = 0;
@@ -107,13 +113,13 @@
 	//interrupt = false;
 }
 
-byte TC8566AF::peekReg(int reg, EmuTime::param /*time*/) const
+byte TC8566AF::peekReg(int reg, EmuTime::param time) const
 {
 	switch (reg) {
 	case 4: // Main Status Register
 		return peekStatus();
 	case 5: // data port
-		return peekDataPort();
+		return peekDataPort(time);
 	}
 	return 0xff;
 }
@@ -144,11 +150,11 @@
 	return peekStatus();
 }
 
-byte TC8566AF::peekDataPort() const
+byte TC8566AF::peekDataPort(EmuTime::param time) const
 {
 	switch (phase) {
 	case PHASE_DATATRANSFER:
-		return executionPhasePeek();
+		return executionPhasePeek(time);
 	case PHASE_RESULT:
 		return resultsPhasePeek();
 	default:
@@ -160,13 +166,12 @@
 {
 	//interrupt = false;
 	switch (phase) {
-	case PHASE_DATATRANSFER: {
-		byte result = executionPhaseRead();
-		delayTime.reset(time);
-		delayTime += 15;  // TODO 15 correct?
-		mainStatus &amp;= ~STM_RQM;
-		return result;
-	}
+	case PHASE_DATATRANSFER:
+		if (delayTime.before(time)) {
+			return executionPhaseRead(time);
+		} else {
+			return 0xff; // TODO check this
+		}
 	case PHASE_RESULT:
 		return resultsPhaseRead(time);
 	default:
@@ -174,33 +179,47 @@
 	}
 }
 
-byte TC8566AF::executionPhasePeek() const
+byte TC8566AF::executionPhasePeek(EmuTime::param time) const
 {
 	switch (command) {
 	case CMD_READ_DATA:
-		if (sectorOffset &lt; sectorSize) {
-			return sectorBuf[sectorOffset];
+		if (delayTime.before(time)) {
+			assert(dataAvailable);
+			return trackData.read(dataCurrent);
+		} else {
+			return 0xff; // TODO check this
 		}
-		// fall-through
 	default:
 		return 0xff;
 	}
 }
 
-byte TC8566AF::executionPhaseRead()
+byte TC8566AF::executionPhaseRead(EmuTime::param time)
 {
 	switch (command) {
-	case CMD_READ_DATA:
-		if (sectorOffset &lt; sectorSize) {
-			byte value = sectorBuf[sectorOffset++];
-			if (sectorOffset == sectorSize) {
-				phase = PHASE_RESULT;
-				phaseStep = 0;
-				//interrupt = true;
+	case CMD_READ_DATA: {
+		assert(dataAvailable);
+		byte result = trackData.read(dataCurrent++);
+		crc.update(result);
+		--dataAvailable;
+		delayTime += 1; // time when next byte will be available
+		mainStatus &amp;= ~STM_RQM;
+		if (delayTime.before(time)) {
+			// lost data
+			status1 |= ST1_OR;
+			resultPhase();
+		} else if (!dataAvailable) {
+			// check crc error
+			word diskCrc  = 256 * trackData.read(dataCurrent++);
+			     diskCrc +=       trackData.read(dataCurrent++);
+			if (diskCrc != crc.getValue()) {
+				status1 |= ST1_DE;
+				status2 |= ST2_DD;
 			}
-			return value;
+			resultPhase();
 		}
-		// fall-through
+		return result;
+	}
 	default:
 		return 0xff;
 	}
@@ -323,10 +342,7 @@
 		break;
 
 	case PHASE_DATATRANSFER:
-		executionPhaseWrite(value);
-		delayTime.reset(time);
-		delayTime += 15;
-		mainStatus &amp;= ~STM_RQM;
+		executionPhaseWrite(value, time);
 		break;
 	default:
 		// nothing
@@ -363,7 +379,8 @@
 	case CMD_WRITE_DATA:
 	case CMD_FORMAT:
 		status0 &amp;= ~(ST0_IC0 | ST0_IC1);
-		status1 &amp;= ~(ST1_ND | ST1_NW);
+		status1 = 0;
+		status2 = 0;
 		//MT  = value &amp; 0x80;
 		//MFM = value &amp; 0x40;
 		//SK  = value &amp; 0x20;
@@ -374,9 +391,7 @@
 		break;
 
 	case CMD_SENSE_INTERRUPT_STATUS:
-		mainStatus |= STM_DIO;
-		phase       = PHASE_RESULT;
-		//interrupt   = true;
+		resultPhase();
 		break;
 
 	case CMD_SEEK:
@@ -403,9 +418,38 @@
 	           (drive[driveSelect]-&gt;isDiskInserted()   ? ST3_RDY : 0);
 }
 
+EmuTime TC8566AF::locateSector(EmuTime::param time)
+{
+	RawTrack::Sector sectorInfo;
+	int lastIdx = -1;
+	EmuTime next = time;
+	while (true) {
+		try {
+			next = drive[driveSelect]-&gt;getNextSector(
+				next, trackData, sectorInfo);
+		} catch (MSXException&amp; e) {
+			return EmuTime::infinity;
+		}
+		if ((next == EmuTime::infinity) ||
+		    (sectorInfo.addrIdx == lastIdx)) {
+			// no sectors on track or sector already seen
+			return EmuTime::infinity;
+		}
+		if (lastIdx == -1) lastIdx = sectorInfo.addrIdx;
+		if (sectorInfo.addrCrcErr)               continue;
+		if (sectorInfo.track  != cylinderNumber) continue;
+		if (sectorInfo.head   != headNumber)     continue;
+		if (sectorInfo.sector != sectorNumber)   continue;
+		break;
+	}
+	// TODO does TC8566AF look at lower 3 bits?
+	dataAvailable = 128 &lt;&lt; (sectorInfo.sizeCode &amp; 7);
+	dataCurrent = sectorInfo.dataIdx;
+	return next;
+}
+
 void TC8566AF::commandPhaseWrite(byte value, EmuTime::param time)
 {
-	DiskDrive&amp; currentDrive = *drive[driveSelect];
 	switch (command) {
 	case CMD_READ_DATA:
 	case CMD_WRITE_DATA:
@@ -424,37 +468,12 @@
 			break;
 		case 4:
 			number = value;
-			//sectorSize = diskGetSectorSize(driveSelect, side, currentTrack, 0);
-			//sectorOffset = (number == 1 &amp;&amp; (commandCode &amp; 0xc0) == 0x40)
-			//             ? 0
-			//             : sectorSize; // FIXME
-			//sectorSize = ((MT == 0) &amp;&amp; (MFM == 1) &amp;&amp; (number == 2)) ? 512 : 0;
-			sectorSize = 512;
-			sectorOffset = 0;
 			break;
 		case 5: // End Of Track
 			break;
 		case 6: // Gap Length
 			break;
 		case 7: // Data length
-			if (command == CMD_READ_DATA) {
-				try {
-					byte onDiskTrack;
-					byte onDiskSector;
-					byte onDiskSide;
-					int  onDiskSize;
-					currentDrive.read(
-						sectorNumber, sectorBuf,
-						onDiskTrack, onDiskSector,
-						onDiskSide,  onDiskSize);
-				} catch (MSXException&amp;) {
-					status0 |= ST0_IC0;
-					status1 |= ST1_ND;
-				}
-				mainStatus |= STM_DIO;
-			} else {
-				mainStatus &amp;= ~STM_DIO;
-			}
 			phase = PHASE_DATATRANSFER;
 			phaseStep = 0;
 			//interrupt = true;
@@ -466,9 +485,27 @@
 				// set 'head is loaded'
 				headUnloadTime = EmuTime::infinity;
 			}
+
+			// actually read sector: fills in
+			//   trackData, dataAvailable and dataCurrent
+			ready = locateSector(ready);
+			if (ready == EmuTime::infinity) {
+				status0 |= ST0_IC0;
+				status1 |= ST1_ND;
+				resultPhase();
+				return;
+			}
+			if (command == CMD_READ_DATA) {
+				mainStatus |= STM_DIO;
+			} else {
+				mainStatus &amp;= ~STM_DIO;
+			}
+			// Initialize crc
+			// TODO 0xFB vs 0xF8 depends on deleted vs normal data
+			crc.init(0xE295); // A1 A1 A1 FB
+
 			// first byte is available when it's rotated below the
 			// drive-head
-			ready = currentDrive.getTimeTillSector(sectorNumber, ready);
 			delayTime.reset(ready);
 			mainStatus &amp;= ~STM_RQM;
 			break;
@@ -479,8 +516,6 @@
 		switch (phaseStep++) {
 		case 0:
 			commandPhase1(value);
-			//sectorSize = diskGetSectorSize(driveSelect, side, currentTrack, 0);
-			sectorSize = 512;
 			break;
 		case 1:
 			number = value;
@@ -489,13 +524,16 @@
 			sectorsPerCylinder = value;
 			sectorNumber       = value;
 			break;
+		case 3:
+			gapLength = value;
+			break;
 		case 4:
 			fillerByte   = value;
-			sectorOffset = 0;
 			mainStatus  &amp;= ~STM_DIO;
 			phase        = PHASE_DATATRANSFER;
 			phaseStep    = 0;
 			//interrupt    = true;
+			initTrackHeader();
 			break;
 		}
 		break;
@@ -535,10 +573,7 @@
 		switch (phaseStep++) {
 		case 0:
 			commandPhase1(value);
-
-			mainStatus |= STM_DIO;
-			phase       = PHASE_RESULT;
-			phaseStep   = 0;
+			resultPhase();
 			break;
 		}
 		break;
@@ -548,6 +583,50 @@
 	}
 }
 
+void TC8566AF::initTrackHeader()
+{
+	trackData.clear();
+	dataCurrent = 0;
+	dataAvailable = RawTrack::SIZE;
+
+	for (int i = 0; i &lt; 80; ++i) trackData.write(dataCurrent++, 0x4E); // gap4a
+	for (int i = 0; i &lt; 12; ++i) trackData.write(dataCurrent++, 0x00); // sync
+	for (int i = 0; i &lt;  3; ++i) trackData.write(dataCurrent++, 0xC2); // index mark
+	for (int i = 0; i &lt;  1; ++i) trackData.write(dataCurrent++, 0xFC); //   "    "
+	for (int i = 0; i &lt; 50; ++i) trackData.write(dataCurrent++, 0x4E); // gap1
+}
+
+void TC8566AF::formatSector()
+{
+	for (int i = 0; i &lt; 12; ++i) trackData.write(dataCurrent++, 0x00); // sync
+
+	for (int i = 0; i &lt;  3; ++i) trackData.write(dataCurrent++, 0xA1); // addr mark
+	trackData.addIdam(dataCurrent);
+	for (int i = 0; i &lt;  1; ++i) trackData.write(dataCurrent++, 0xFE); //  "    "
+	trackData.write(dataCurrent++, currentTrack); // C: Cylinder number
+	trackData.write(dataCurrent++, headNumber);   // H: Head Address
+	trackData.write(dataCurrent++, sectorNumber); // R: Record
+	trackData.write(dataCurrent++, number);       // N: Length of sector
+	word addrCrc = trackData.calcCrc(dataCurrent - 8, 8);
+	trackData.write(dataCurrent++, addrCrc &gt;&gt; 8);   // CRC (high byte)
+	trackData.write(dataCurrent++, addrCrc &amp; 0xff); //     (low  byte)
+
+	for (int i = 0; i &lt; 22; ++i) trackData.write(dataCurrent++, 0x4E); // gap2
+	for (int i = 0; i &lt; 12; ++i) trackData.write(dataCurrent++, 0x00); // sync
+
+	for (int i = 0; i &lt;  3; ++i) trackData.write(dataCurrent++, 0xA1); // data mark
+	for (int i = 0; i &lt;  1; ++i) trackData.write(dataCurrent++, 0xFB); //  "    "
+
+	int sectorSize = 128 &lt;&lt; (number &amp; 7); // 2 -&gt; 512bytes
+	for (int i = 0; i &lt; sectorSize; ++i) trackData.write(dataCurrent++, fillerByte);
+
+	word dataCrc = trackData.calcCrc(dataCurrent - (sectorSize + 4), sectorSize + 4);
+	trackData.write(dataCurrent++, dataCrc &gt;&gt; 8);   // CRC (high byte)
+	trackData.write(dataCurrent++, dataCrc &amp; 0xff); //     (low  byte)
+
+	for (int i = 0; i &lt; gapLength; ++i) trackData.write(dataCurrent++, 0x4E); // gap3
+}
+
 void TC8566AF::doSeek(EmuTime::param time)
 {
 	DiskDrive&amp; currentDrive = *drive[driveSelect];
@@ -598,62 +677,66 @@
 	}
 }
 
-void TC8566AF::executionPhaseWrite(byte value)
+void TC8566AF::writeSector()
 {
+	// write 2 CRC bytes (big endian)
+	trackData.write(dataCurrent++, crc.getValue() &gt;&gt; 8);
+	trackData.write(dataCurrent++, crc.getValue() &amp; 0xFF);
+	drive[driveSelect]-&gt;writeTrack(trackData);
+}
+
+void TC8566AF::executionPhaseWrite(byte value, EmuTime::param time)
+{
 	switch (command) {
 	case CMD_WRITE_DATA:
-		if (sectorOffset &lt; sectorSize) {
-			sectorBuf[sectorOffset++] = value;
-			if (sectorOffset == sectorSize) {
-				try {
-					byte onDiskTrack;
-					byte onDiskSector;
-					byte onDiskSide;
-					int  onDiskSize;
-					drive[driveSelect]-&gt;write(
-						sectorNumber, sectorBuf,
-						onDiskTrack, onDiskSector,
-						onDiskSide,  onDiskSize);
-				} catch (MSXException&amp;) {
-					status1 |= ST1_NW;
-				}
-				phase       = PHASE_RESULT;
-				phaseStep   = 0;
-				mainStatus |= STM_DIO;
+		assert(dataAvailable);
+		trackData.write(dataCurrent++, value);
+		crc.update(value);
+		--dataAvailable;
+		delayTime += 1; // time when next byte can be written
+		mainStatus &amp;= ~STM_RQM;
+		if (delayTime.before(time)) {
+			// lost data
+			status1 |= ST1_OR;
+			resultPhase();
+		} else if (!dataAvailable) {
+			try {
+				writeSector();
+			} catch (MSXException&amp;) {
+				status1 |= ST1_NW;
 			}
+			resultPhase();
 		}
 		break;
 
 	case CMD_FORMAT:
+		delayTime += 1; // correct?
+		mainStatus &amp;= ~STM_RQM;
 		switch (phaseStep &amp; 3) {
 		case 0:
 			currentTrack = value;
 			break;
 		case 1:
 			headNumber = value;
-			memset(sectorBuf, fillerByte, sectorSize);
-			try {
-				byte onDiskTrack;
-				byte onDiskSector;
-				byte onDiskSide;
-				int  onDiskSize;
-				drive[driveSelect]-&gt;write(
-					sectorNumber, sectorBuf,
-					onDiskTrack, onDiskSector,
-					onDiskSide,  onDiskSize);
-			} catch (MSXException&amp;) {
-				status1 |= ST1_NW;
-			}
 			break;
 		case 2:
 			sectorNumber = value;
 			break;
+		case 3:
+			number = value;
+			formatSector();
+			break;
 		}
+		++phaseStep;
 
-		if (++phaseStep == 4 * sectorsPerCylinder - 2) {
-			phase       = PHASE_RESULT;
-			phaseStep   = 0;
-			mainStatus |= STM_DIO;
+		if (phaseStep == 4 * sectorsPerCylinder) {
+			// data for all sectors was written, now write track
+			try {
+				drive[driveSelect]-&gt;writeTrack(trackData);
+			} catch (MSXException&amp;) {
+				status1 |= ST1_NW;
+			}
+			resultPhase();
 		}
 		break;
 	default:
@@ -662,10 +745,19 @@
 	}
 }
 
+void TC8566AF::resultPhase()
+{
+	mainStatus |= STM_DIO | STM_RQM;
+	phase       = PHASE_RESULT;
+	phaseStep   = 0;
+	//interrupt = true;
+}
+
 void TC8566AF::endCommand(EmuTime::param time)
 {
 	phase       = PHASE_IDLE;
 	mainStatus &amp;= ~(STM_CB | STM_DIO);
+	delayTime.reset(time); // set STM_RQM
 	if (headUnloadTime == EmuTime::infinity) {
 		headUnloadTime = time + getHeadUnloadDelay();
 	}
@@ -690,19 +782,16 @@
 }
 EmuDuration TC8566AF::getHeadLoadDelay() const
 {
-	static const double UNIT = 0.002; // 2ms
-	return EmuDuration(UNIT * (specifyData[1] &gt;&gt; 1));
+	return EmuDuration::msec(2 * (specifyData[1] &gt;&gt; 1)); // 2ms per unit
 }
 EmuDuration TC8566AF::getHeadUnloadDelay() const
 {
-	static const double UNIT = 0.016; // 16ms
-	return EmuDuration(UNIT * (specifyData[0] &amp; 0x0F));
+	return EmuDuration::msec(16 * (specifyData[0] &amp; 0x0F)); // 16ms per unit
 }
 
 EmuDuration TC8566AF::getSeekDelay() const
 {
-	static const double UNIT = 0.001; // 1ms
-	return EmuDuration(UNIT * (16 - (specifyData[0] &gt;&gt; 4)));
+	return EmuDuration::msec(16 - (specifyData[0] &gt;&gt; 4)); // 1ms per unit
 }
 
 
@@ -737,6 +826,10 @@
 // version 1: initial version
 // version 2: added specifyData, headUnloadTime, seekValue
 //            inherit from Schedulable
+// version 3: Replaced 'sectorSize', 'sectorOffset', 'sectorBuf'
+//            with 'dataAvailable', 'dataCurrent', .trackData'.
+//            Not 100% backwardscompatible, see also comments in WD2793.
+//            Added 'crc' and 'gapLength'.
 template&lt;typename Archive&gt;
 void TC8566AF::serialize(Archive&amp; ar, unsigned version)
 {
@@ -744,9 +837,6 @@
 	ar.serialize("command", command);
 	ar.serialize("phase", phase);
 	ar.serialize("phaseStep", phaseStep);
-	ar.serialize("sectorSize", sectorSize);
-	ar.serialize("sectorOffset", sectorOffset);
-	ar.serialize_blob("sectorBuf", sectorBuf, sizeof(sectorBuf));
 	ar.serialize("driveSelect", driveSelect);
 	ar.serialize("mainStatus", mainStatus);
 	ar.serialize("status0", status0);
@@ -773,6 +863,35 @@
 		headUnloadTime = EmuTime::zero;
 		seekValue = 0;
 	}
+	if (ar.versionAtLeast(version, 3)) {
+		ar.serialize("dataAvailable", dataAvailable);
+		ar.serialize("dataCurrent", dataCurrent);
+		ar.serialize("trackData", trackData);
+		ar.serialize("gapLength", gapLength);
+		word crcVal = crc.getValue();
+		ar.serialize("crc", crcVal);
+		crc.init(crcVal);
+	} else {
+		// Compared to previous versions the buffer managment worked
+		// differently (was sector oriented instead of track oriented).
+		// Converting the old state to the new state is not that easy,
+		// we only give a warning when an old savestate that was in
+		// the middle of a read/write operation is loaded.
+		//ar.serialize("sectorSize", sectorSize);
+		//ar.serialize("sectorOffset", sectorOffset);
+		//ar.serialize_blob("sectorBuf", sectorBuf, sizeof(sectorBuf));
+		//TODO wrning
+		if ((phase == PHASE_DATATRANSFER) &amp;&amp;
+		    ((command == CMD_READ_DATA)  ||
+		     (command == CMD_WRITE_DATA) ||
+		     (command == CMD_FORMAT))) {
+			cliComm.printWarning(
+				"Loading an old savestate that had an "
+				"in-progress TC8566AF data-transfer command. "
+				"This is not fully backwards-compatible and "
+				"could cause wrong emulation behavior.");
+		}
+	}
 };
 INSTANTIATE_SERIALIZE_METHODS(TC8566AF);
 

Modified: openmsx/trunk/src/fdc/TC8566AF.hh
===================================================================
--- openmsx/trunk/src/fdc/TC8566AF.hh	2012-03-24 16:34:52 UTC (rev 12443)
+++ openmsx/trunk/src/fdc/TC8566AF.hh	2012-03-24 16:35:10 UTC (rev 12444)
@@ -4,6 +4,8 @@
 #define TC8566AF_HH
 
 #include "Clock.hh"
+#include "RawTrack.hh"
+#include "CRC16.hh"
 #include "Schedulable.hh"
 #include "serialize_meta.hh"
 #include "openmsx.hh"
@@ -12,11 +14,13 @@
 
 class Scheduler;
 class DiskDrive;
+class CliComm;
 
 class TC8566AF : public Schedulable /* private noncopyable */
 {
 public:
-	TC8566AF(Scheduler&amp; scheduler, DiskDrive* drive[4], EmuTime::param time);
+	TC8566AF(Scheduler&amp; scheduler, DiskDrive* drive[4], CliComm&amp; cliComm,
+	         EmuTime::param time);
 
 	void reset(EmuTime::param time);
 	byte readReg(int reg, EmuTime::param time);
@@ -58,12 +62,12 @@
 	// Schedulable
 	virtual void executeUntil(EmuTime::param time, int state);
 
-	byte peekDataPort() const;
+	byte peekDataPort(EmuTime::param time) const;
 	byte readDataPort(EmuTime::param time);
 	byte peekStatus() const;
 	byte readStatus(EmuTime::param time);
-	byte executionPhasePeek() const;
-	byte executionPhaseRead();
+	byte executionPhasePeek(EmuTime::param time) const;
+	byte executionPhaseRead(EmuTime::param time);
 	byte resultsPhasePeek() const;
 	byte resultsPhaseRead(EmuTime::param time);
 	void writeDataPort(byte value, EmuTime::param time);
@@ -71,7 +75,8 @@
 	void commandPhase1(byte value);
 	void commandPhaseWrite(byte value, EmuTime::param time);
 	void doSeek(EmuTime::param time);
-	void executionPhaseWrite(byte value);
+	void executionPhaseWrite(byte value, EmuTime::param time);
+	void resultPhase();
 	void endCommand(EmuTime::param time);
 
 	bool isHeadLoaded(EmuTime::param time) const;
@@ -79,8 +84,18 @@
 	EmuDuration getHeadUnloadDelay() const;
 	EmuDuration getSeekDelay() const;
 
+	EmuTime locateSector(EmuTime::param time);
+	void writeSector();
+	void initTrackHeader();
+	void formatSector();
+
+private:
+	static const int TICKS_PER_ROTATION = RawTrack::SIZE;
+	static const int ROTATIONS_PER_SECOND = 5; // 300rpm
+
+	CliComm&amp; cliComm;
 	DiskDrive* drive[4];
-	Clock&lt;1000000&gt; delayTime;
+	Clock&lt;TICKS_PER_ROTATION * ROTATIONS_PER_SECOND&gt; delayTime;
 	EmuTime headUnloadTime; // Before this time head is loaded, after
 	                        // this time it's unloaded. Set to zero/infinity
 	                        // to force a (un)loaded head.
@@ -89,11 +104,12 @@
 	Phase phase;
 	int phaseStep;
 
-	int sectorSize;
-	int sectorOffset;
 	//bool interrupt;
 
-	byte sectorBuf[4096];
+	RawTrack trackData;
+	int dataAvailable;
+	int dataCurrent;
+	CRC16 crc;
 
 	byte driveSelect;
 	byte mainStatus;
@@ -110,10 +126,11 @@
 	byte currentTrack;
 	byte sectorsPerCylinder;
 	byte fillerByte;
+	byte gapLength;
 	byte specifyData[2]; // filled in by SPECIFY command
 	byte seekValue;
 };
-SERIALIZE_CLASS_VERSION(TC8566AF, 2);
+SERIALIZE_CLASS_VERSION(TC8566AF, 3);
 
 } // namespace openmsx
 

Modified: openmsx/trunk/src/fdc/TurboRFDC.cc
===================================================================
--- openmsx/trunk/src/fdc/TurboRFDC.cc	2012-03-24 16:34:52 UTC (rev 12443)
+++ openmsx/trunk/src/fdc/TurboRFDC.cc	2012-03-24 16:35:10 UTC (rev 12444)
@@ -19,6 +19,7 @@
 	, cpu(motherBoard.getCPU())
 	, controller(new TC8566AF(motherBoard.getScheduler(),
 	                          reinterpret_cast&lt;DiskDrive**&gt;(drives),
+	                          getMotherBoard().getMSXCliComm(),
 	                          getCurrentTime()))
 	, blockMask((rom-&gt;getSize() / 0x4000) - 1)
 {

This was sent by the SourceForge.net collaborative development platform, the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg29031623">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29031623/">[openMSX-commits] SF.net SVN: openmsx:[12443] openmsx/trunk/src/fdc</a></b></div>
      
      <small>From: &lt;m9710797@us...&gt; - 2012-03-24 16:35:03</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12443
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12443&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12443&amp;view=rev</a>
Author:   m9710797
Date:     2012-03-24 16:34:52 +0000 (Sat, 24 Mar 2012)
Log Message:
-----------
Various WD2793 improvements related to low level disk access

The most important change in this patch is to convert WD2793 from the old
access methods in Disk/DiskDrive to the new ones (see previous patch).

This change in interface allows to properly access disks with non-standard
disk formats (e.g. disks with some type of copy-protection). Though at the
moment we don't have support yet for a disk image format that can actually
represent such disks. This will be changed in one of the follow up patches.

Other changes in this patch (made possible by the interface change) are:
 - implementation of the "read track" command
 - implementation of the "read address" command
 - moved the guts of the "write track" command implementation from
   the Disk class to the WD2793 class where it belongs (the Disk class
   doesn't need to know about the special WD2793 format codes).

Other changes made possible, but not yet (fully) implemented are:
 - some details about CRC errors in address mark
 - handling of 'deleted' sectors
 - handling of sector sizes other than 512 bytes (mostly done, but need
   to check some details)
 - verification of the track and head information stored in the track

This last class of changes is left as TODO's for the future (I don't yet have
follow up patches). Though for many MSX disk protections the current
implementation is already good enough. Especially if the protection works on
all MSX machines (meaning it doesn't rely on a specific FDC).

Modified Paths:
--------------
    openmsx/trunk/src/fdc/WD2793.cc
    openmsx/trunk/src/fdc/WD2793.hh

Modified: openmsx/trunk/src/fdc/WD2793.cc
===================================================================
--- openmsx/trunk/src/fdc/WD2793.cc	2012-03-24 16:34:36 UTC (rev 12442)
+++ openmsx/trunk/src/fdc/WD2793.cc	2012-03-24 16:34:52 UTC (rev 12443)
@@ -6,7 +6,6 @@
 #include "MSXException.hh"
 #include "serialize.hh"
 #include "unreachable.hh"
-#include &lt;cstring&gt;
 
 namespace openmsx {
 
@@ -39,6 +38,7 @@
 // Sync point types
 enum SyncPointType { SCHED_FSM, SCHED_IDX_IRQ };
 
+
 WD2793::WD2793(Scheduler&amp; scheduler, DiskDrive&amp; drive_, CliComm&amp; cliComm_,
                EmuTime::param time)
 	: Schedulable(scheduler)
@@ -47,9 +47,9 @@
 	, drqTime(EmuTime::infinity)
 {
 	// avoid (harmless) UMR in serialize()
-	memset(dataBuffer, 0, sizeof(dataBuffer));
 	dataCurrent = 0;
 	dataAvailable = 0;
+	lastWasA1 = false;
 
 	reset(time);
 }
@@ -225,19 +225,60 @@
 	if (!getDTRQ(time)) return;
 	assert(statusReg &amp; BUSY);
 
-	if (((commandReg &amp; 0xE0) == 0xA0) ||
-	    ((commandReg &amp; 0xF0) == 0xF0)) {
-		// write sector  or  write track
+	if (((commandReg &amp; 0xE0) == 0xA0) || // write sector
+	    ((commandReg &amp; 0xF0) == 0xF0)) { // write track
+		// handle lost bytes
 		drqTime += 1; // time when next byte will be accepted
 		while (dataAvailable &amp;&amp; unlikely(getDTRQ(time))) {
 			statusReg |= LOST_DATA;
 			drqTime += 1;
-			dataCurrent++;
+			trackData.write(dataCurrent++, 0);
+			crc.update(0);
 			dataAvailable--;
 		}
+
+		byte write = value; // written value not always same as given value
+		if ((commandReg &amp; 0xF0) == 0xF0) {
+			// write track, handle chars with special meaning
+			bool prevA1 = lastWasA1;
+			lastWasA1 = false;
+			if (value == 0xF5) {
+				// write A1 with missing clock transitions
+				write = 0xA1;
+				lastWasA1 = true;
+				// Initialize CRC: the calculated CRC value
+				// includes the 3 A1 bytes. So when starting
+				// from the initial value 0xffff, we should not
+				// re-initialize the CRC value on the 2nd and
+				// 3rd A1 byte. Though what we do instead is on
+				// each A1 byte initialize the value as if
+				// there were already 2 A1 bytes written.
+				crc.init(0x968B);
+			} else if (value == 0xF6) {
+				// write C2 with missing clock transitions
+				write = 0xC2;
+			} else if (value == 0xF7) {
+				// write 2 CRC bytes, big endian
+				word crcVal = crc.getValue();
+				if (dataAvailable) {
+					drqTime += 1;
+					trackData.write(dataCurrent++, crcVal &gt;&gt; 8);
+					dataAvailable--;
+				}
+				write = crcVal &amp; 0xFF;
+			} else if (value == 0xFE) {
+				// Record locations of 0xA1 (with missing clock
+				// transition) followed by 0xFE. The FE byte has
+				// no special meaning for the WD2793 itself,
+				// but it does for the DMK file format.
+				if (prevA1) {
+					trackData.addIdam(dataCurrent);
+				}
+			}
+		}
 		if (dataAvailable) {
-			dataBuffer[dataCurrent] = value;
-			dataCurrent++;
+			trackData.write(dataCurrent++, write);
+			crc.update(write);
 			dataAvailable--;
 		}
 		assert(!dataAvailable || !getDTRQ(time));
@@ -246,28 +287,46 @@
 
 byte WD2793::getDataReg(EmuTime::param time)
 {
-	if (((commandReg &amp; 0xE0) == 0x80) &amp;&amp; getDTRQ(time)) {
-		// read sector
+	if ((((commandReg &amp; 0xE0) == 0x80) ||   // read sector
+	     ((commandReg &amp; 0xF0) == 0xC0) ||   // read address
+	     ((commandReg &amp; 0xF0) == 0xE0)) &amp;&amp;  // read track
+	    getDTRQ(time)) {
 		assert(statusReg &amp; BUSY);
 
-		dataReg = dataBuffer[dataCurrent];
-		dataCurrent++;
+		dataReg = trackData.read(dataCurrent++);
+		crc.update(dataReg);
 		dataAvailable--;
 		drqTime += 1; // time when the next byte will be available
 		while (dataAvailable &amp;&amp; unlikely(getDTRQ(time))) {
 			statusReg |= LOST_DATA;
-			dataCurrent++;
+			dataReg = trackData.read(dataCurrent++);
+			crc.update(dataReg);
 			dataAvailable--;
 			drqTime += 1;
 		}
 		assert(!dataAvailable || !getDTRQ(time));
 		if (dataAvailable == 0) {
-			if (!(commandReg &amp; M_FLAG)) {
+			if ((commandReg &amp; 0xE0) == 0x80) {
+				// read sector
+				// update crc status flag
+				word diskCrc  = 256 * trackData.read(dataCurrent++);
+				     diskCrc +=       trackData.read(dataCurrent++);
+				if (diskCrc == crc.getValue()) {
+					statusReg &amp;= ~CRC_ERROR;
+				} else {
+					statusReg |=  CRC_ERROR;
+				}
+				if (!(commandReg &amp; M_FLAG)) {
+					endCmd();
+				} else {
+					// TODO multi sector read
+					sectorReg++;
+					endCmd();
+				}
+			} else {
+				// read track, read address
+				// TODO check CRC error on 'read address'
 				endCmd();
-			} else {
-				// TODO check if this is correct
-				sectorReg++;
-				tryToReadSector(time);
 			}
 		}
 	}
@@ -276,40 +335,17 @@
 
 byte WD2793::peekDataReg(EmuTime::param time)
 {
-	if (((commandReg &amp; 0xE0) == 0x80) &amp;&amp; getDTRQ(time)) {
-		// read sector
-		return dataBuffer[dataCurrent];
+	if ((((commandReg &amp; 0xE0) == 0x80) ||   // read sector
+	     ((commandReg &amp; 0xF0) == 0xC0) ||   // read address
+	     ((commandReg &amp; 0xF0) == 0xE0)) &amp;&amp;  // read track
+	    peekDTRQ(time)) {
+		return trackData.read(dataCurrent);
 	} else {
 		return dataReg;
 	}
 }
 
-void WD2793::tryToReadSector(EmuTime::param time)
-{
-	try {
-		byte onDiskTrack, onDiskSector, onDiskSide;
-		int  onDiskSize;
-		drive.read(sectorReg, dataBuffer,
-		           onDiskTrack, onDiskSector, onDiskSide, onDiskSize);
-		if (onDiskTrack != trackReg) {
-			// TODO we should wait for 6 index holes
-			statusReg |= RECORD_NOT_FOUND;
-			endCmd();
-			return;
-		}
-		assert(onDiskSize == 512);
-		dataCurrent = 0;
-		dataAvailable = onDiskSize;
-		drqTime.reset(time);
-		drqTime += 1; // (first) byte can be read in a moment
-	} catch (MSXException&amp; e) {
-		PRT_DEBUG("WD2793: read sector failed: " &lt;&lt; e.getMessage());
-		(void)&amp;e; // Prevent warning
-		statusReg = 0; // reset flags
-	}
-}
 
-
 void WD2793::schedule(FSMState state, EmuTime::param time)
 {
 	assert(!pendingSyncPoint(SCHED_FSM));
@@ -355,7 +391,7 @@
 		case FSM_WRITE_SECTOR:
 			if ((commandReg &amp; 0xE0) == 0xA0) {
 				// write sector command
-				writeSector();
+				doneWriteSector();
 			}
 			break;
 		case FSM_TYPE3_WAIT_LOAD:
@@ -382,7 +418,7 @@
 		case FSM_WRITE_TRACK:
 			if ((commandReg &amp; 0xF0) == 0xF0) {
 				// write track command
-				writeTrack();
+				doneWriteTrack();
 			}
 			break;
 		default:
@@ -516,61 +552,120 @@
 		PRT_DEBUG("WD2793: write protected");
 		statusReg |= WRITE_PROTECTED;
 		endCmd();
-	} else {
-		schedule(FSM_TYPE2_ROTATED,
-		         drive.getTimeTillSector(sectorReg, time));
+		return;
 	}
+
+	// Locate sector on disk.
+	RawTrack::Sector sectorInfo;
+	int firstIdx = -1;
+	EmuTime next = time;
+	while (true) {
+		try {
+			next = drive.getNextSector(next, trackData, sectorInfo);
+		} catch (MSXException&amp; e) {
+			statusReg |= RECORD_NOT_FOUND;
+			endCmd();
+			return;
+		}
+		// TODO we should spread this search over time, so that
+		// the CRC status bit toggles correctly.
+		if ((next == EmuTime::infinity) ||      // no sectors on this track
+		    (sectorInfo.addrIdx == firstIdx)) { // already seen this index
+			// TODO real WD2793 searches till 5 index holes
+			//      have passed
+			// TODO actually let EmuTime pass
+			statusReg |= RECORD_NOT_FOUND;
+			endCmd();
+			return;
+		}
+		if (sectorInfo.addrCrcErr) {
+			statusReg |=  CRC_ERROR;
+		} else {
+			statusReg &amp;= ~CRC_ERROR;
+		}
+		if (firstIdx == -1) firstIdx = sectorInfo.addrIdx;
+		if (sectorInfo.addrCrcErr)          continue;
+		if (sectorInfo.track  != trackReg)  continue;
+		if (sectorInfo.sector != sectorReg) continue;
+		// TODO implement (optional) head compare
+		break;
+	}
+
+	// Found sector.
+	// Get sectorsize from disk: 128, 256, 512 or 1024 bytes
+	// TODO are other sizes supported?
+	//      IOW does the WD2793 only look at the lower 2 bits?
+	dataAvailable = 128 &lt;&lt; (sectorInfo.sizeCode &amp; 3);
+	dataCurrent = sectorInfo.dataIdx;
+
+	if ((commandReg &amp; 0xE0) == 0xA0) {
+		// write sector
+		// TODO actually we should
+		//  - skip 22 bytes (from end of data block)
+		//  - write 12 bytes of zero
+		//  - write A1 A1 A1 FB   (or F8)
+		// But ATM we reuse the previous location of the data block
+	}
+	crc.init(0xE295); // A1 A1 A1 FB
+
+	// wait till sector is actually rotated under head
+	schedule(FSM_TYPE2_ROTATED, next);
 }
 
 void WD2793::type2Rotated(EmuTime::param time)
 {
 	switch (commandReg &amp; 0xF0) {
-		case 0x80: // read sector
-		case 0x90: // read sector (multi)
-			tryToReadSector(time);
-			break;
+	case 0x80: // read sector
+	case 0x90: // read sector (multi)
+		startReadSector(time);
+		break;
 
-		case 0xA0: // write sector
-		case 0xB0: // write sector (multi)
-			// TODO By now the CPU should already have written the
-			// first byte, otherwise the write sector command
-			// doesn't even start. This is not yet implemented.
+	case 0xA0: // write sector
+	case 0xB0: // write sector (multi)
+		// TODO By now the CPU should already have written the first
+		// byte, otherwise the write sector command doesn't even start.
+		// This is not yet implemented.
+		drqTime.reset(time); // DRQ = true
 
-			// Bytes that were not filled in by the CPU are written
-			// as zero. We implement this by pre-filling the buffer
-			// with zeros.
-			memset(dataBuffer, 0, 512);
-			dataCurrent = 0;
-			dataAvailable = 512; // TODO should come from sector header
-			drqTime.reset(time); // DRQ = true
-
-			// Moment in time when the sector will be written
-			// (whether the CPU wrote all required data or not)
-			schedule(FSM_WRITE_SECTOR, drqTime + 512);
-			break;
+		// Moment in time when the sector will be written (whether the
+		// CPU wrote all required data or not)
+		schedule(FSM_WRITE_SECTOR, drqTime + dataAvailable);
+		break;
 	}
 }
 
-void WD2793::writeSector()
+void WD2793::startReadSector(EmuTime::param time)
 {
+	drqTime.reset(time);
+	drqTime += 1; // (first) byte can be read in a moment
+}
+
+void WD2793::doneWriteSector()
+{
 	try {
-		byte onDiskTrack, onDiskSector, onDiskSide;
-		int  onDiskSize;
-		drive.write(sectorReg, dataBuffer,
-			    onDiskTrack, onDiskSector,
-			    onDiskSide, onDiskSize);
-		if (onDiskTrack != trackReg) {
-			// TODO we should wait for 6 index holes
-			PRT_DEBUG("WD2793: Record not found");
-			statusReg |= RECORD_NOT_FOUND;
-			endCmd();
-			return;
+		// any lost data?
+		while (dataAvailable) {
+			statusReg |= LOST_DATA;
+			trackData.write(dataCurrent++, 0);
+			crc.update(0);
+			dataAvailable--;
 		}
-		assert(onDiskSize == 512);
+
+		// write 2 CRC bytes (big endian)
+		trackData.write(dataCurrent++, crc.getValue() &gt;&gt; 8);
+		trackData.write(dataCurrent++, crc.getValue() &amp; 0xFF);
+		// write one byte of 0xFE
+		// TODO check this, datasheet is not very clear about this
+		trackData.write(dataCurrent++, 0xFE);
+
+		// write sector (actually full track) to disk.
+		drive.writeTrack(trackData);
+
 		if (!(commandReg &amp; M_FLAG)) {
 			endCmd();
 		} else {
 			// TODO multi sector write
+			sectorReg++;
 			endCmd();
 		}
 	} catch (MSXException&amp;) {
@@ -581,6 +676,7 @@
 	}
 }
 
+
 void WD2793::startType3Cmd(EmuTime::param time)
 {
 	//PRT_DEBUG("WD2793 start type 3 command");
@@ -615,19 +711,45 @@
 		// write track command and write protected
 		statusReg |= WRITE_PROTECTED;
 		endCmd();
+		return;
+	}
+
+	EmuTime next(EmuTime::dummy());
+	if ((commandReg &amp; 0xF0) == 0xC0) {
+		// read address
+		try {
+			// wait till next sector header
+			RawTrack::Sector sector;
+			next = drive.getNextSector(time, trackData, sector);
+			if (next == EmuTime::infinity) {
+				// TODO wait for 5 revolutions
+				endCmd();
+				return;
+			}
+			dataCurrent = sector.addrIdx;
+			dataAvailable = 6;
+		} catch (MSXException&amp; e) {
+			PRT_DEBUG("WD2793: read addr failed: " &lt;&lt; e.getMessage()); (void)&amp;e;
+			// TODO status bits?
+			endCmd();
+			return;
+		}
 	} else {
-		schedule(FSM_TYPE3_ROTATED, drive.getTimeTillIndexPulse(time));
+		// read/write track
+		// wait till next index pulse
+		next = drive.getTimeTillIndexPulse(time);
 	}
+	schedule(FSM_TYPE3_ROTATED, next);
 }
 
 void WD2793::type3Rotated(EmuTime::param time)
 {
 	switch (commandReg &amp; 0xF0) {
 	case 0xC0: // read Address
-		readAddressCmd();
+		readAddressCmd(time);
 		break;
 	case 0xE0: // read track
-		readTrackCmd();
+		readTrackCmd(time);
 		break;
 	case 0xF0: // write track
 		writeTrackCmd(time);
@@ -635,41 +757,54 @@
 	}
 }
 
-void WD2793::readAddressCmd()
+void WD2793::readAddressCmd(EmuTime::param time)
 {
-	PRT_DEBUG("WD2793 command: read address  NOT YET IMPLEMENTED");
-	endCmd();
+	drqTime.reset(time);
+	drqTime += 1; // (first) byte can be read in a moment
 }
 
-void WD2793::readTrackCmd()
+void WD2793::readTrackCmd(EmuTime::param time)
 {
-	PRT_DEBUG("WD2793 command: read track   NOT YET IMPLEMENTED");
-	endCmd();
+	try {
+		drive.readTrack(trackData);
+		dataCurrent = 0;
+		dataAvailable = RawTrack::SIZE;
+		drqTime.reset(time);
+		drqTime += 1; // (first) byte can be read in a moment
+	} catch (MSXException&amp; e) {
+		PRT_DEBUG("WD2793: read track failed: " &lt;&lt; e.getMessage()); (void)&amp;e;
+		// TODO status bits?
+		endCmd();
+	}
 }
 
 void WD2793::writeTrackCmd(EmuTime::param time)
 {
-	// TODO By now the CPU should already have written the
-	// first byte, otherwise the write sector command
-	// doesn't even start. This is not yet implemented.
-
-	// Bytes that were not filled in by the CPU are written
-	// as zero. We implement this by pre-filling the buffer
-	// with zeros.
-	memset(dataBuffer, 0, sizeof(dataBuffer));
+	// TODO By now the CPU should already have written the first byte,
+	// otherwise the write track command doesn't even start. This is not
+	// yet implemented.
+	trackData.clear();
 	dataCurrent = 0;
-	dataAvailable = sizeof(dataBuffer);
+	dataAvailable = RawTrack::SIZE;
 	drqTime.reset(time); // DRQ = true
+	lastWasA1 = false;
 
-	// Moment in time when the track will be written
-	// (whether the CPU wrote all required data or not)
-	schedule(FSM_WRITE_TRACK, drqTime + sizeof(dataBuffer));
+	// Moment in time when the track will be written (whether the CPU wrote
+	// all required data or not).
+	schedule(FSM_WRITE_TRACK, drqTime + RawTrack::SIZE);
 }
 
-void WD2793::writeTrack()
+void WD2793::doneWriteTrack()
 {
 	try {
-		drive.writeTrackData(dataBuffer);
+		// any lost data?
+		while (dataAvailable) {
+			statusReg |= LOST_DATA;
+			trackData.write(dataCurrent, 0);
+			dataCurrent++;
+			dataAvailable--;
+		}
+		drive.writeTrack(trackData);
 	} catch (MSXException&amp;) {
 		// Ignore. Should rarely happen, because
 		// write-protected is already checked at the
@@ -677,34 +812,9 @@
 		// when disk is swapped during format)
 	}
 	endCmd();
-
-	// TODO currently the following logic is implemented in the backend.
-	// It should be moved here (because it's WD2793 specific).
-	/*switch (value) {
-	case 0xFE:
-	case 0xFD:
-	case 0xFC:
-	case 0xFB:
-	case 0xFA:
-	case 0xF9:
-	case 0xF8:
-	       PRT_DEBUG("CRC generator initializing");
-	       break;
-	case 0xF6:
-	       PRT_DEBUG("write C2 ?");
-	       break;
-	case 0xF5:
-	       PRT_DEBUG("CRC generator initializing in MFM, write A1?");
-	       break;
-	case 0xF7:
-	       PRT_DEBUG("two CRC characters");
-	       break;
-	default:
-	       // Normal write to track
-	       break;
-	}*/
 }
 
+
 void WD2793::startType4Cmd(EmuTime::param time)
 {
 	// Force interrupt
@@ -762,6 +872,12 @@
 //            and write track) has changed. So this could result in replay-sync
 //            errors.
 //            (Also the enum FSMState has changed, but that's not a problem.)
+// version3: Added members 'crc' and 'lastWasA1'.
+//           Replaced 'dataBuffer' with 'trackData'. We don't attempt to migrate
+//           the old 'dataBuffer' content to 'trackData' (doing so would be
+//           quite difficult). This means that old savestates that were in the
+//           middle of a sector/track read/write command probably won't work
+//           correctly anymore. We do give a warning on this.
 template&lt;typename Archive&gt;
 void WD2793::serialize(Archive&amp; ar, unsigned version)
 {
@@ -778,7 +894,6 @@
 	ar.serialize("INTRQ", INTRQ);
 	ar.serialize("immediateIRQ", immediateIRQ);
 
-	ar.serialize_blob("dataBuffer", dataBuffer, sizeof(dataBuffer));
 	ar.serialize("dataCurrent", dataCurrent);
 	ar.serialize("dataAvailable", dataAvailable);
 
@@ -807,6 +922,31 @@
 				"could cause wrong emulation behavior.");
 		}
 	}
+
+	if (ar.versionAtLeast(version, 3)) {
+		ar.serialize("trackData", trackData);
+		ar.serialize("lastWasA1", lastWasA1);
+		word crcVal = crc.getValue();
+		ar.serialize("crc", crcVal);
+		crc.init(crcVal);
+	} else {
+		assert(ar.isLoader());
+		//ar.serialize_blob("dataBuffer", dataBuffer, sizeof(dataBuffer));
+		// Compared to version 1 or 2, the databuffer works different:
+		// before we only stored the data of the logical sector, now
+		// we store the full content of the raw track. We don't attempt
+		// to migrate the old format to the new one (it's not very
+		// easy). We only give a warning.
+		if ((statusReg &amp; BUSY) &amp;&amp;
+		    (((commandReg &amp; 0xC0) == 0x80) ||  // read/write sector
+		     ((commandReg &amp; 0xF0) == 0xF0))) { // write track
+			cliComm.printWarning(
+				"Loading an old savestate that had an "
+				"in-progress WD2793 data-transfer command. "
+				"This is not fully backwards-compatible and "
+				"could cause wrong emulation behavior.");
+		}
+	}
 }
 INSTANTIATE_SERIALIZE_METHODS(WD2793);
 

Modified: openmsx/trunk/src/fdc/WD2793.hh
===================================================================
--- openmsx/trunk/src/fdc/WD2793.hh	2012-03-24 16:34:36 UTC (rev 12442)
+++ openmsx/trunk/src/fdc/WD2793.hh	2012-03-24 16:34:52 UTC (rev 12443)
@@ -3,9 +3,10 @@
 #ifndef WD2793_HH
 #define WD2793_HH
 
-#include "Disk.hh"
+#include "RawTrack.hh"
 #include "Clock.hh"
 #include "Schedulable.hh"
+#include "CRC16.hh"
 #include "serialize_meta.hh"
 
 namespace openmsx {
@@ -71,42 +72,47 @@
 	void seekNext(EmuTime::param time);
 	void endType1Cmd();
 
-	void startType2Cmd(EmuTime::param time);
-	void type2WaitLoad(EmuTime::param time);
-	void type2Loaded  (EmuTime::param time);
-	void type2Rotated (EmuTime::param time);
-	void writeSector();
+	void startType2Cmd  (EmuTime::param time);
+	void type2WaitLoad  (EmuTime::param time);
+	void type2Loaded    (EmuTime::param time);
+	void type2Rotated   (EmuTime::param time);
+	void startReadSector(EmuTime::param time);
+	void doneWriteSector();
 
-	void startType3Cmd(EmuTime::param time);
-	void type3WaitLoad(EmuTime::param time);
-	void type3Loaded  (EmuTime::param time);
-	void type3Rotated (EmuTime::param time);
-	void readAddressCmd();
-	void readTrackCmd();
-	void writeTrackCmd(EmuTime::param time);
-	void writeTrack();
+	void startType3Cmd (EmuTime::param time);
+	void type3WaitLoad (EmuTime::param time);
+	void type3Loaded   (EmuTime::param time);
+	void type3Rotated  (EmuTime::param time);
+	void readAddressCmd(EmuTime::param time);
+	void readTrackCmd  (EmuTime::param time);
+	void writeTrackCmd (EmuTime::param time);
+	void doneWriteTrack();
 
 	void startType4Cmd(EmuTime::param time);
 
 	void endCmd();
 
-	void tryToReadSector(EmuTime::param time);
 	inline void resetIRQ();
 	inline void setIRQ();
 
 	void schedule(FSMState state, EmuTime::param time);
 
+private:
 	DiskDrive&amp; drive;
 	CliComm&amp; cliComm;
 
-	static const int TICKS_PER_ROTATION = 6850;
-	static const int ROTATIONS_PER_SECOND = 5;
+	static const int TICKS_PER_ROTATION = RawTrack::SIZE;
+	static const int ROTATIONS_PER_SECOND = 5; // 300rpm
+
 	// DRQ is high iff current time is past this time
 	Clock&lt;TICKS_PER_ROTATION * ROTATIONS_PER_SECOND&gt; drqTime;
 
-	int dataCurrent;   // which byte in dataBuffer is next to be read/write
-	int dataAvailable; // how many bytes left in buffer
+	RawTrack trackData;
+	int dataCurrent;   // which byte in track is next to be read/write
+	int dataAvailable; // how many bytes left to read/write
 
+	CRC16 crc;
+
 	FSMState fsmState;
 	byte statusReg;
 	byte commandReg;
@@ -117,10 +123,9 @@
 	bool directionIn;
 	bool INTRQ;
 	bool immediateIRQ;
-
-	byte dataBuffer[Disk::RAWTRACK_SIZE];
+	bool lastWasA1;
 };
-SERIALIZE_CLASS_VERSION(WD2793, 2);
+SERIALIZE_CLASS_VERSION(WD2793, 3);
 
 } // namespace openmsx
 

This was sent by the SourceForge.net collaborative development platform, the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg29031622">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29031622/">[openMSX-commits] SF.net SVN: openmsx:[12442] openmsx/trunk/src/fdc</a></b></div>
      
      <small>From: &lt;m9710797@us...&gt; - 2012-03-24 16:34:48</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12442
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12442&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12442&amp;view=rev</a>
Author:   m9710797
Date:     2012-03-24 16:34:36 +0000 (Sat, 24 Mar 2012)
Log Message:
-----------
Added new low-level track access methods in Disk/DiskDrive

ATM these classes have two sets of access methods:
 - the (old) existing ones (including sector access methods)
 - the new ones added in this patch
Once the WD2793 and TC8566AF classes are adjusted to use the new methods, the
old ones will be removed.

Actually there are only two low-level access methods anymore:
  readTrack() and writeTrack()
If you e.g. only want to write a sector, you now have to read a track, change
the content of the track and write it back. This may seem like a detour, but it
actually makes the implementation of low-level sector handling at the FDC level
(so including updating the CRC value for the new sector data) a lot easier (see
next patches).

If you're not interested in this 'extra' track data (IOW you only care about
the content of the logical sectors) this approach indeed has some overhead. But
reading/writing sectors is a relatively slow and infrequent process anyway. So
it shouldn't cause any performance problems (not even in 'fullspeedwhenloading'
mode).

The readTrack() / writeTrack() methods at the level of the Disk class don't
take timing into account (they execute in zero Emutime). Only the DiskDrive
class adds rotational and seek delay.

Modified Paths:
--------------
    openmsx/trunk/src/fdc/Disk.cc
    openmsx/trunk/src/fdc/Disk.hh
    openmsx/trunk/src/fdc/DiskDrive.cc
    openmsx/trunk/src/fdc/DiskDrive.hh
    openmsx/trunk/src/fdc/DriveMultiplexer.cc
    openmsx/trunk/src/fdc/DriveMultiplexer.hh
    openmsx/trunk/src/fdc/RealDrive.cc
    openmsx/trunk/src/fdc/RealDrive.hh
    openmsx/trunk/src/fdc/SectorAccessibleDisk.cc
    openmsx/trunk/src/fdc/SectorBasedDisk.cc
    openmsx/trunk/src/fdc/SectorBasedDisk.hh

Modified: openmsx/trunk/src/fdc/Disk.cc
===================================================================
--- openmsx/trunk/src/fdc/Disk.cc	2012-03-24 16:34:07 UTC (rev 12441)
+++ openmsx/trunk/src/fdc/Disk.cc	2012-03-24 16:34:36 UTC (rev 12442)
@@ -61,6 +61,14 @@
 	}
 }
 
+void Disk::writeTrack(byte track, byte side, const RawTrack&amp; input)
+{
+	if (isWriteProtected()) {
+		throw WriteProtectedException("");
+	}
+	writeTrackImpl(track, side, input);
+}
+
 bool Disk::isDoubleSided()
 {
 	if (!nbSides) {
@@ -69,26 +77,31 @@
 	return nbSides == 2;
 }
 
+// Note: Special case to convert between logical/physical sector numbers
+//       for the boot sector and the 1st FAT sector (logical sector: 0/1,
+//       physical location: track 0, side 0, sector 1/2): perform this
+//       conversion without relying on the detected geometry parameters.
+//       Otherwise the detectGeometry() method (which itself reads these
+//       two sectors) would get in an infinite loop.
 int Disk::physToLog(byte track, byte side, byte sector)
 {
 	if ((track == 0) &amp;&amp; (side == 0)) {
-		// special case for bootsector or 1st FAT sector
 		return sector - 1;
 	}
 	if (!nbSides) {
 		detectGeometry();
 	}
-	int result = sectorsPerTrack * (side + nbSides * track) + (sector - 1);
-	//PRT_DEBUG("Disk::physToLog(track " &lt;&lt; (int)track &lt;&lt; ", side "
-	//          &lt;&lt; (int)side &lt;&lt; ", sector " &lt;&lt; (int)sector&lt;&lt; ") returns "
-	//          &lt;&lt; result);
-	return result;
+	return sectorsPerTrack * (side + nbSides * track) + (sector - 1);
 }
-
 void Disk::logToPhys(int log, byte&amp; track, byte&amp; side, byte&amp; sector)
 {
+	if (log &lt;= 1) {
+		track = 0;
+		side = 0;
+		sector = log + 1;
+		return;
+	}
 	if (!nbSides) {
-		// try to guess values from boot sector
 		detectGeometry();
 	}
 	track = log / (nbSides * sectorsPerTrack);
@@ -100,6 +113,13 @@
 {
 	sectorsPerTrack = num;
 }
+unsigned Disk::getSectorsPerTrack()
+{
+	if (!nbSides) {
+		detectGeometry();
+	}
+	return sectorsPerTrack;
+}
 void Disk::setNbSides(unsigned num)
 {
 	nbSides = num;
@@ -150,7 +170,7 @@
 
 	try {
 		byte buf[SECTOR_SIZE];
-		read(0, 1, 0, SECTOR_SIZE, buf);
+		readSector(0, buf); // bootsector
 		if ((buf[0] == 0xE9) || (buf[0] ==0xEB)) {
 			// use values from bootsector
 			sectorsPerTrack = buf[0x18] + 256 * buf[0x19];
@@ -161,7 +181,7 @@
 				detectGeometryFallback();
 			}
 		} else {
-			read(0, 2, 0, SECTOR_SIZE, buf);
+			readSector(1, buf); // 1st fat sector
 			byte mediaDescriptor = buf[0];
 			if (mediaDescriptor &gt;= 0xF8) {
 				sectorsPerTrack = (mediaDescriptor &amp; 2) ? 8 : 9;

Modified: openmsx/trunk/src/fdc/Disk.hh
===================================================================
--- openmsx/trunk/src/fdc/Disk.hh	2012-03-24 16:34:07 UTC (rev 12441)
+++ openmsx/trunk/src/fdc/Disk.hh	2012-03-24 16:34:36 UTC (rev 12442)
@@ -4,6 +4,7 @@
 #define DISK_HH
 
 #include "SectorAccessibleDisk.hh"
+#include "RawTrack.hh"
 #include "DiskName.hh"
 #include "openmsx.hh"
 
@@ -12,6 +13,8 @@
 class Disk : public SectorAccessibleDisk
 {
 public:
+	// TODO This should be 6250 (see calculation in RawTrack), but it will
+	//      soon be replaced.
 	static const int RAWTRACK_SIZE = 6850;
 
 	virtual ~Disk();
@@ -29,6 +32,12 @@
 	void writeTrackData(byte track, byte side, const byte* data);
 	virtual void readTrackData(byte track, byte side, byte* output);
 
+	/** Replace a full track in this image with the given track. */
+	        void writeTrack(byte track, byte side, const RawTrack&amp; input);
+
+	/** Read a full track from this disk image. */
+	virtual void readTrack (byte track, byte side,       RawTrack&amp; output) = 0;
+
 	bool isDoubleSided();
 
 protected:
@@ -39,11 +48,13 @@
 	virtual void detectGeometry();
 
 	void setSectorsPerTrack(unsigned num);
+	unsigned getSectorsPerTrack();
 	void setNbSides(unsigned num);
 
 	virtual void writeImpl(byte track, byte sector,
 	                       byte side, unsigned size, const byte* buf) = 0;
 	virtual void writeTrackDataImpl(byte track, byte side, const byte* data);
+	virtual void writeTrackImpl(byte track, byte side, const RawTrack&amp; input) = 0;
 
 private:
 	void detectGeometryFallback();

Modified: openmsx/trunk/src/fdc/DiskDrive.cc
===================================================================
--- openmsx/trunk/src/fdc/DiskDrive.cc	2012-03-24 16:34:07 UTC (rev 12441)
+++ openmsx/trunk/src/fdc/DiskDrive.cc	2012-03-24 16:34:36 UTC (rev 12442)
@@ -2,6 +2,7 @@
 
 #include "DiskDrive.hh"
 #include "DiskExceptions.hh"
+#include &lt;cassert&gt;
 
 namespace openmsx {
 
@@ -103,6 +104,22 @@
 	// ignore ???
 }
 
+void DummyDrive::writeTrack(const RawTrack&amp; /*track*/)
+{
+	assert(false);
+}
+
+void DummyDrive::readTrack(RawTrack&amp; /*track*/)
+{
+	assert(false);
+}
+
+EmuTime DummyDrive::getNextSector(EmuTime::param /*time*/, RawTrack&amp; /*track*/,
+                                  RawTrack::Sector&amp; /*sector*/)
+{
+	return EmuTime::infinity;
+}
+
 bool DummyDrive::diskChanged()
 {
 	return false;
@@ -118,5 +135,4 @@
 	return true;
 }
 
-
 } // namespace openmsx

Modified: openmsx/trunk/src/fdc/DiskDrive.hh
===================================================================
--- openmsx/trunk/src/fdc/DiskDrive.hh	2012-03-24 16:34:07 UTC (rev 12441)
+++ openmsx/trunk/src/fdc/DiskDrive.hh	2012-03-24 16:34:36 UTC (rev 12442)
@@ -4,6 +4,7 @@
 #define DISKDRIVE_HH
 
 #include "EmuTime.hh"
+#include "RawTrack.hh"
 #include "noncopyable.hh"
 #include "openmsx.hh"
 
@@ -98,6 +99,10 @@
 	virtual void getSectorHeader(byte sector, byte* buf) = 0;
 	virtual void getTrackHeader(byte* buf) = 0;
 	virtual void writeTrackData(const byte* data) = 0;
+	virtual void writeTrack(const RawTrack&amp; track) = 0;
+	virtual void readTrack (      RawTrack&amp; track) = 0;
+	virtual EmuTime getNextSector(EmuTime::param time, RawTrack&amp; track,
+	                              RawTrack::Sector&amp; sector) = 0;
 
 	/** Is disk changed?
 	 */
@@ -137,6 +142,10 @@
 	virtual void getSectorHeader(byte sector, byte* buf);
 	virtual void getTrackHeader(byte* buf);
 	virtual void writeTrackData(const byte* data);
+	virtual void writeTrack(const RawTrack&amp; track);
+	virtual void readTrack (      RawTrack&amp; track);
+	virtual EmuTime getNextSector(EmuTime::param time, RawTrack&amp; track,
+	                              RawTrack::Sector&amp; sector);
 	virtual bool diskChanged();
 	virtual bool peekDiskChanged() const;
 	virtual bool isDummyDrive() const;

Modified: openmsx/trunk/src/fdc/DriveMultiplexer.cc
===================================================================
--- openmsx/trunk/src/fdc/DriveMultiplexer.cc	2012-03-24 16:34:07 UTC (rev 12441)
+++ openmsx/trunk/src/fdc/DriveMultiplexer.cc	2012-03-24 16:34:36 UTC (rev 12442)
@@ -125,6 +125,22 @@
 	drive[selected]-&gt;writeTrackData(data);
 }
 
+void DriveMultiplexer::writeTrack(const RawTrack&amp; track)
+{
+	drive[selected]-&gt;writeTrack(track);
+}
+
+void DriveMultiplexer::readTrack(RawTrack&amp; track)
+{
+	drive[selected]-&gt;readTrack(track);
+}
+
+EmuTime DriveMultiplexer::getNextSector(EmuTime::param time, RawTrack&amp; track,
+                                        RawTrack::Sector&amp; sector)
+{
+	return drive[selected]-&gt;getNextSector(time, track, sector);
+}
+
 bool DriveMultiplexer::diskChanged()
 {
 	return drive[selected]-&gt;diskChanged();

Modified: openmsx/trunk/src/fdc/DriveMultiplexer.hh
===================================================================
--- openmsx/trunk/src/fdc/DriveMultiplexer.hh	2012-03-24 16:34:07 UTC (rev 12441)
+++ openmsx/trunk/src/fdc/DriveMultiplexer.hh	2012-03-24 16:34:36 UTC (rev 12442)
@@ -49,6 +49,10 @@
 	virtual void getSectorHeader(byte sector, byte* buf);
 	virtual void getTrackHeader(byte* buf);
 	virtual void writeTrackData(const byte* data);
+	virtual void writeTrack(const RawTrack&amp; track);
+	virtual void readTrack (      RawTrack&amp; track);
+	virtual EmuTime getNextSector(EmuTime::param time, RawTrack&amp; track,
+	                              RawTrack::Sector&amp; sector);
 	virtual bool diskChanged();
 	virtual bool peekDiskChanged() const;
 	virtual bool isDummyDrive() const;

Modified: openmsx/trunk/src/fdc/RealDrive.cc
===================================================================
--- openmsx/trunk/src/fdc/RealDrive.cc	2012-03-24 16:34:07 UTC (rev 12441)
+++ openmsx/trunk/src/fdc/RealDrive.cc	2012-03-24 16:34:36 UTC (rev 12442)
@@ -280,8 +280,7 @@
 	}
 	int delta = TICKS_PER_ROTATION -
 	            (motorTimer.getTicksTill(time) % TICKS_PER_ROTATION);
-	EmuDuration dur = Clock&lt;TICKS_PER_ROTATION * ROTATIONS_PER_SECOND&gt;::
-	                      duration(delta);
+	EmuDuration dur = MotorClock::duration(delta);
 	return time + dur;
 }
 
@@ -336,6 +335,30 @@
 	changer-&gt;getDisk().writeTrackData(headPos, side, data);
 }
 
+void RealDrive::writeTrack(const RawTrack&amp; track)
+{
+	changer-&gt;getDisk().writeTrack(headPos, side, track);
+}
+
+void RealDrive::readTrack(RawTrack&amp; track)
+{
+	changer-&gt;getDisk().readTrack(headPos, side, track);
+}
+
+EmuTime RealDrive::getNextSector(
+	EmuTime::param time, RawTrack&amp; track, RawTrack::Sector&amp; sector)
+{
+	int idx = motorTimer.getTicksTill(time) % TICKS_PER_ROTATION;
+	changer-&gt;getDisk().readTrack(headPos, side, track);
+	if (!track.decodeNextSector(idx, sector)) {
+		return EmuTime::infinity;
+	}
+	int ticks = sector.addrIdx - idx;
+	if (ticks &lt; 0) ticks += TICKS_PER_ROTATION;
+	assert(0 &lt;= ticks); assert(ticks &lt; TICKS_PER_ROTATION);
+	return time + MotorClock::duration(ticks);
+}
+
 bool RealDrive::diskChanged()
 {
 	return changer-&gt;diskChanged();

Modified: openmsx/trunk/src/fdc/RealDrive.hh
===================================================================
--- openmsx/trunk/src/fdc/RealDrive.hh	2012-03-24 16:34:07 UTC (rev 12441)
+++ openmsx/trunk/src/fdc/RealDrive.hh	2012-03-24 16:34:36 UTC (rev 12442)
@@ -46,6 +46,10 @@
 	virtual void getSectorHeader(byte sector, byte* buf);
 	virtual void getTrackHeader(byte* buf);
 	virtual void writeTrackData(const byte* data);
+	virtual void writeTrack(const RawTrack&amp; track);
+	virtual void readTrack (      RawTrack&amp; track);
+	virtual EmuTime getNextSector(EmuTime::param time, RawTrack&amp; track,
+	                              RawTrack::Sector&amp; sector);
 	virtual bool diskChanged();
 	virtual bool peekDiskChanged() const;
 	virtual bool isDummyDrive() const;
@@ -59,7 +63,7 @@
 	void setLoading(EmuTime::param time);
 
 	static const int MAX_TRACK = 85;
-	static const int TICKS_PER_ROTATION = 6850; // TODO
+	static const int TICKS_PER_ROTATION = 6250; // see Disk.hh
 	static const int ROTATIONS_PER_SECOND = 5;
 	static const int INDEX_DURATION = TICKS_PER_ROTATION / 50;
 
@@ -67,7 +71,8 @@
 	const std::auto_ptr&lt;LoadingIndicator&gt; loadingIndicator;
 	const EmuDuration motorTimeout;
 
-	Clock&lt;TICKS_PER_ROTATION * ROTATIONS_PER_SECOND&gt; motorTimer;
+	typedef Clock&lt;TICKS_PER_ROTATION * ROTATIONS_PER_SECOND&gt; MotorClock;
+	MotorClock motorTimer;
 	Clock&lt;1000&gt; headLoadTimer; // ms
 	std::auto_ptr&lt;DiskChanger&gt; changer;
 	int headPos;

Modified: openmsx/trunk/src/fdc/SectorAccessibleDisk.cc
===================================================================
--- openmsx/trunk/src/fdc/SectorAccessibleDisk.cc	2012-03-24 16:34:07 UTC (rev 12441)
+++ openmsx/trunk/src/fdc/SectorAccessibleDisk.cc	2012-03-24 16:34:36 UTC (rev 12442)
@@ -22,6 +22,10 @@
 void SectorAccessibleDisk::readSector(unsigned sector, byte* buf)
 {
 	if (!isDummyDisk() &amp;&amp; // in that case we want DriveEmptyException
+	    (sector &gt; 1) &amp;&amp; // allow reading sector 0 and 1 without calling
+	                    // getNbSectors() because this potentially calls
+	                    // detectGeometry() and that would cause an
+	                    // infinite loop
 	    (getNbSectors() &lt;= sector)) {
 		throw NoSuchSectorException("No such sector");
 	}

Modified: openmsx/trunk/src/fdc/SectorBasedDisk.cc
===================================================================
--- openmsx/trunk/src/fdc/SectorBasedDisk.cc	2012-03-24 16:34:07 UTC (rev 12441)
+++ openmsx/trunk/src/fdc/SectorBasedDisk.cc	2012-03-24 16:34:36 UTC (rev 12442)
@@ -123,6 +123,104 @@
 	assert((out - output) == RAWTRACK_SIZE);
 }
 
+void SectorBasedDisk::writeTrackImpl(byte track, byte side, const RawTrack&amp; input)
+{
+	std::vector&lt;RawTrack::Sector&gt; sectors = input.decodeAll();
+	for (std::vector&lt;RawTrack::Sector&gt;::const_iterator it = sectors.begin();
+	     it != sectors.end(); ++it) {
+		// Ignore 'track' and 'head' information
+		// Always assume sectorsize = 512 (so also ignore sizeCode).
+		// Ignore CRC value/errors of both address and data.
+		// Ignore sector type (deleted or not)
+		// Ignore sectors that are outside the range 1..sectorsPerTrack
+		if ((it-&gt;sector &lt; 1) || (it-&gt;sector &gt; getSectorsPerTrack())) continue;
+		byte buf[512];
+		input.readBlock(it-&gt;dataIdx, 512, buf);
+		unsigned logicalSector = physToLog(track, side, it-&gt;sector);
+		writeSector(logicalSector, buf);
+		// it's important to use writeSector() and not writeSectorImpl()
+		// because only the former flushes SHA1 cache
+	}
+}
+
+void SectorBasedDisk::readTrack(byte track, byte side, RawTrack&amp; output)
+{
+	// This disk image only stores the actual sector data, not all the
+	// extra gap, sync and header information that is in reality stored
+	// in between the sectors. This function transforms the cooked sector
+	// data back into raw track data. It assumes a standard IBM double
+	// density, 9 sectors/track, 512 bytes/sector track layout.
+	//
+	// -- track --
+	// gap4a         80 x 0x4e
+	// sync          12 x 0x00
+	// index mark     3 x 0xc2(*)
+	//                1 x 0xfc
+	// gap1          50 x 0x4e
+	// 9 x [sector]   9 x [[658]]
+	// gap4b        182 x 0x4e
+	//
+	// -- sector --
+	// sync          12 x 0x00
+	// ID addr mark   3 x 0xa1(*)
+	//                1 x 0xfe
+	// C H R N        4 x [..]
+	// CRC            2 x [..]
+	// gap2          22 x 0x4e
+	// sync          12 x 0x00
+	// data mark      3 x 0xa1(*)
+	//                1 x 0xfb
+	// data         512 x [..]    &lt;-- actual sector data
+	// CRC            2 x [..]
+	// gap3          84 x 0x4e
+	//
+	// (*) Missing clock transitions in MFM encoding
+
+	output.clear(); // clear idam positions
+
+	int idx = 0;
+	for (int i = 0; i &lt; 80; ++i) output.write(idx++, 0x4E); // gap4a
+	for (int i = 0; i &lt; 12; ++i) output.write(idx++, 0x00); // sync
+	for (int i = 0; i &lt;  3; ++i) output.write(idx++, 0xC2); // index mark (1)
+	for (int i = 0; i &lt;  1; ++i) output.write(idx++, 0xFC); //            (2)
+	for (int i = 0; i &lt; 50; ++i) output.write(idx++, 0x4E); // gap1
+
+	for (int j = 0; j &lt; 9; ++j) {
+		for (int i = 0; i &lt; 12; ++i) output.write(idx++, 0x00); // sync
+
+		for (int i = 0; i &lt;  3; ++i) output.write(idx++, 0xA1); // addr mark (1)
+		output.addIdam(idx);
+		for (int i = 0; i &lt;  1; ++i) output.write(idx++, 0xFE); //           (2)
+		output.write(idx++, track); // C: Cylinder number
+		output.write(idx++, side);  // H: Head Address
+		output.write(idx++, j + 1); // R: Record
+		output.write(idx++, 0x02);  // N: Number (length of sector: 512 = 128 &lt;&lt; 2)
+		word addrCrc = output.calcCrc(idx - 8, 8);
+		output.write(idx++, addrCrc &gt;&gt; 8);   // CRC (high byte)
+		output.write(idx++, addrCrc &amp; 0xff); //     (low  byte)
+
+		for (int i = 0; i &lt; 22; ++i) output.write(idx++, 0x4E); // gap2
+		for (int i = 0; i &lt; 12; ++i) output.write(idx++, 0x00); // sync
+
+		for (int i = 0; i &lt;  3; ++i) output.write(idx++, 0xA1); // data mark (1)
+		for (int i = 0; i &lt;  1; ++i) output.write(idx++, 0xFB); //           (2)
+
+		unsigned logicalSector = physToLog(track, side, j + 1);
+		byte sectorBuf[512];
+		readSector(logicalSector, sectorBuf);
+		for (int i = 0; i &lt; 512; ++i) output.write(idx++, sectorBuf[i]);
+
+		word dataCrc = output.calcCrc(idx - (512 + 4), 512 + 4);
+		output.write(idx++, dataCrc &gt;&gt; 8);   // CRC (high byte)
+		output.write(idx++, dataCrc &amp; 0xff); //     (low  byte)
+
+		for (int i = 0; i &lt; 84; ++i) output.write(idx++, 0x4E); // gap3
+	}
+
+	for (int i = 0; i &lt; 182; ++i) output.write(idx++, 0x4E); // gap4b
+	assert(idx == RawTrack::SIZE);
+}
+
 unsigned SectorBasedDisk::getNbSectorsImpl() const
 {
 	assert(nbSectors != unsigned(-1)); // must have been initialized

Modified: openmsx/trunk/src/fdc/SectorBasedDisk.hh
===================================================================
--- openmsx/trunk/src/fdc/SectorBasedDisk.hh	2012-03-24 16:34:07 UTC (rev 12441)
+++ openmsx/trunk/src/fdc/SectorBasedDisk.hh	2012-03-24 16:34:36 UTC (rev 12442)
@@ -8,6 +8,10 @@
 
 namespace openmsx {
 
+/** Abstract class for disk images that only represent the logical sector
+  * information (so not the raw track data that is sometimes needed for
+  * copy-protected disks).
+  */
 class SectorBasedDisk : public Disk, private noncopyable
 {
 protected:
@@ -26,6 +30,8 @@
 	virtual void writeImpl(byte track, byte sector, byte side,
 	                       unsigned size, const byte* buf);
 	virtual void writeTrackDataImpl(byte track, byte side, const byte* data);
+	virtual void readTrack(byte track, byte side, RawTrack&amp; output);
+	virtual void writeTrackImpl(byte track, byte side, const RawTrack&amp; input);
 
 	unsigned nbSectors;
 };

This was sent by the SourceForge.net collaborative development platform, the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg29031621">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29031621/">[openMSX-commits] SF.net SVN: openmsx:[12441] openmsx/trunk/src</a></b></div>
      
      <small>From: &lt;m9710797@us...&gt; - 2012-03-24 16:34:19</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12441
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12441&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12441&amp;view=rev</a>
Author:   m9710797
Date:     2012-03-24 16:34:07 +0000 (Sat, 24 Mar 2012)
Log Message:
-----------
Added RawTrack class

This patch only adds the RawTrack class but doesn't actually use it yet (follow
up patches will). Eventually this will be used to support copy-protected disks.
See comments in the code for more details about RawTrack.

Modified Paths:
--------------
    openmsx/trunk/src/fdc/node.mk
    openmsx/trunk/src/utils/CRC16.cc
    openmsx/trunk/src/utils/CRC16.hh

Added Paths:
-----------
    openmsx/trunk/src/fdc/RawTrack.cc
    openmsx/trunk/src/fdc/RawTrack.hh

Added: openmsx/trunk/src/fdc/RawTrack.cc
===================================================================
--- openmsx/trunk/src/fdc/RawTrack.cc	                        (rev 0)
+++ openmsx/trunk/src/fdc/RawTrack.cc	2012-03-24 16:34:07 UTC (rev 12441)
@@ -0,0 +1,183 @@
+// $Id$
+
+#include "RawTrack.hh"
+#include "CRC16.hh"
+#include "serialize.hh"
+#include "serialize_stl.hh"
+#include &lt;algorithm&gt;
+#include &lt;cstring&gt;
+#include &lt;cassert&gt;
+
+using std::vector;
+
+namespace openmsx {
+
+const int RawTrack::SIZE;
+
+RawTrack::RawTrack()
+{
+	clear();
+}
+
+void RawTrack::clear()
+{
+	idam.clear();
+	memset(data, 0x4e, sizeof(data));
+}
+
+void RawTrack::addIdam(int idx)
+{
+	assert(idx &lt; SIZE);
+	assert(idam.empty() || (idx &gt; idam.back()));
+	idam.push_back(idx);
+}
+
+bool RawTrack::decodeSector(int idx, Sector&amp; sector) const
+{
+	// read (and check) address mark
+	CRC16 addrCrc;
+	// assume addr mark starts with three A1 bytes (should be
+	// located right before the current 'idx' position)
+	for (int i = 0; i &lt; 3; ++i) {
+		addrCrc.update(0xA1);
+	}
+	if (read(idx++) != 0xFE) return false;
+	addrCrc.update(0xFE);
+	int addrIdx = idx;
+
+	byte trackNum = read(idx++);
+	byte headNum = read(idx++);
+	byte secNum = read(idx++);
+	byte sizeCode = read(idx++);
+	addrCrc.update(trackNum);
+	addrCrc.update(headNum);
+	addrCrc.update(secNum);
+	addrCrc.update(sizeCode);
+
+	byte addrCrc1 = read(idx++);
+	byte addrCrc2 = read(idx++);
+	bool addrCrcErr = (256 * addrCrc1 + addrCrc2) != addrCrc.getValue();
+
+	// Locate data mark, should starts within 43 bytes from current
+	// position (that's what the WD2793 does).
+	for (int i = 0; i &lt; 43; ++i) {
+		CRC16 dataCrc;
+		int idx2 = idx + i;
+		int j = 0;
+		for (; j &lt; 3; ++j) {
+			if (read(idx2++) != 0xA1) break;
+			dataCrc.update(0xA1);
+		}
+		if (j != 3) continue; // didn't find 3 x 0xA1
+
+		byte type = read(idx2++);
+		if (!((type == 0xfb) || (type == 0xf8))) continue;
+		dataCrc.update(type);
+		int dataIdx = idx2;
+
+		// OK, found start of data, calculate CRC.
+		unsigned sectorSize = 128 &lt;&lt; (sizeCode &amp; 7);
+		for (unsigned j = 0; j &lt; sectorSize; ++j) {
+			byte d = read(idx2++);
+			dataCrc.update(d);
+		}
+		byte dataCrc1 = read(idx2++);
+		byte dataCrc2 = read(idx2++);
+		bool dataCrcErr = (256 * dataCrc1 + dataCrc2) != dataCrc.getValue();
+
+		// store result
+		sector.addrIdx    = addrIdx;
+		sector.dataIdx    = dataIdx;
+		sector.track      = trackNum;
+		sector.head       = headNum;
+		sector.sector     = secNum;
+		sector.sizeCode   = sizeCode;
+		sector.deleted    = type == 0xf8;
+		sector.addrCrcErr = addrCrcErr;
+		sector.dataCrcErr = dataCrcErr;
+		return true;
+	}
+	return false;
+}
+
+vector&lt;RawTrack::Sector&gt; RawTrack::decodeAll() const
+{
+	vector&lt;Sector&gt; result;
+	for (vector&lt;int&gt;::const_iterator it = idam.begin();
+	     it != idam.end(); ++it) {
+		Sector sector;
+		if (decodeSector(*it, sector)) {
+			result.push_back(sector);
+		}
+	}
+	return result;
+}
+
+static vector&lt;int&gt; rotateIdam(vector&lt;int&gt; idam, int startIdx)
+{
+	// find first element that is equal or bigger
+	vector&lt;int&gt;::iterator it = lower_bound(idam.begin(), idam.end(), startIdx);
+	// rotate range so that we start at that element
+	if (it != idam.end()) {
+		rotate(idam.begin(), it, idam.end());
+	}
+	return idam;
+}
+
+bool RawTrack::decodeNextSector(int startIdx, Sector&amp; sector) const
+{
+	vector&lt;int&gt; idamCopy = rotateIdam(idam, startIdx);
+	// get first valid sector
+	for (vector&lt;int&gt;::const_iterator it = idamCopy.begin();
+	     it != idamCopy.end(); ++it) {
+		if (decodeSector(*it, sector)) {
+			return true;
+		}
+	}
+	return false;
+}
+
+bool RawTrack::decodeSector(byte sectorNum, Sector&amp; sector) const
+{
+	for (vector&lt;int&gt;::const_iterator it = idam.begin();
+	     it != idam.end(); ++it) {
+		if (decodeSector(*it, sector) &amp;&amp;
+		    (sector.sector == sectorNum)) {
+			return true;
+		}
+	}
+	return false;
+}
+
+void RawTrack::readBlock(int idx, unsigned size, byte* destination) const
+{
+	for (unsigned i = 0; i &lt; size; ++i) {
+		destination[i] = read(idx + i);
+	}
+}
+void RawTrack::writeBlock(int idx, unsigned size, const byte* source)
+{
+	for (unsigned i = 0; i &lt; size; ++i) {
+		write(idx + i, source[i]);
+	}
+}
+
+word RawTrack::calcCrc(int idx, int size) const
+{
+	CRC16 crc;
+	for (int i = 0; i &lt; size; ++i) {
+		crc.update(read(idx + i));
+	}
+	return crc.getValue();
+}
+
+
+template&lt;typename Archive&gt;
+void RawTrack::serialize(Archive&amp; ar, unsigned /*version*/)
+{
+	ar.serialize("idam", idam);
+	ar.serialize_blob("data", data, sizeof(data));
+}
+INSTANTIATE_SERIALIZE_METHODS(RawTrack);
+
+} // namespace openmsx

Added: openmsx/trunk/src/fdc/RawTrack.hh
===================================================================
--- openmsx/trunk/src/fdc/RawTrack.hh	                        (rev 0)
+++ openmsx/trunk/src/fdc/RawTrack.hh	2012-03-24 16:34:07 UTC (rev 12441)
@@ -0,0 +1,135 @@
+// $Id$
+
+#ifndef RAWTRACK_HH
+#define RAWTRACK_HH
+
+#include "openmsx.hh"
+#include &lt;vector&gt;
+
+namespace openmsx {
+
+// This class represents a raw disk track. It contains the logical sector
+// content, but also address blocks, CRC checksums, sync blocks and the data
+// in the gaps between these blocks.
+//
+// The internal representation is based on the DMK disk image file format. See:
+//    <a href="http://www.trs-80.com/wordpress/emulation-dmk-format/" rel="nofollow">http://www.trs-80.com/wordpress/emulation-dmk-format/</a>
+//
+// Besides the raw track data, this format also stores the positions of the
+// 'address marks' in the track (this roughly corresponds with the start of a
+// sector). Of course a real disk doesn't have such a list. In a real disk this
+// information is stored as 'MFM encodings with missing clock transitions'.
+//
+// Normal MFM encoding goes like this: An input bit of '0' is encoded as 'x0'
+// with x the inverse of the previously encoded bit. A '1' input bit is encoded
+// as '01'. (More in detail: a '1' encoded bit indicates a magnetic flux
+// transition, a '0' bit is no flux transition). So for example the input byte
+// 0xA1 (binary 10100001) is MFM encoded as '01 00 01 00 10 10 10 01'. (Note
+// that decoding is simply taking every 2nd bit (the data bits), the other bits
+// (the clock bits) ensure that between encoded '1' bits is always at least 1
+// and at most 3 zero bits. So no too dense flux transitions and not too far
+// apart to keep the stream synchronized).
+//
+// Now for the missing clock transitions: besides the encodings for the 256
+// possible input bytes, the FDC can write two other encodings, namely:
+//   01 00 01 00 10 00 10 01  (0xA1 with missing clock between bit 4 and 5)
+//   01 01 00 10 00 10 01 00  (0xC2 with missing clock between bit 3 and 4)
+//
+// So in principle we should store each of these special 0xA1 or 0xC2 bytes.
+// Instead we only store the locations of '0xA1 0xA1 0xA1 0xFE' sequences (the
+// 0xA1 bytes have missing clocks, this sequence indicates the start of an
+// address mark). So we don't store the location of the special 0xC2 bytes, nor
+// the location of each special 0xA1 byte. These certainly do occur on a real
+// disk track, but the WD2793 controller only reacts to the full sequence
+// above, so for us this is good enough. (The FDC also uses these special
+// encodings to re-synchronize itself with the input stream, e.g. figure out
+// which bit is the start bit in a byte, but from a functional emulation point
+// of view we can ignore this).
+//
+// Also note that it's possible to create real disks that have still completely
+// different magnetic flux patterns than the 256+2 possible MFM patterns
+// described above. Such disks cannot be described by this class. But for
+// openMSX that's not a problem because the WD2793 or TC8566AF disk controllers
+// anyway can't handle such disks (they would always interpret the flux pattern
+// as one of the 256+2 MFM patterns). Other systems (like Amiga) have disk
+// controllers that allow more direct access to the disk and could for example
+// encode the data in a more efficient way than MFM (e.g. GCR6). That's why
+// Amiga can fit more data on the same disk (even more than simply storing 10
+// or 11 sectors on a track by making the gaps between the sectors smaller).
+
+struct RawTrack {
+public:
+	// 250kbps, 300rpm -&gt; 6250 bytes per rotation.
+	// The IBM Disk Format Specification confirms this number.
+	// Of course this is in ideal circumstances: in reality the rotation
+	// speed can vary and thus the disk can be formatted with slightly more
+	// or slightly less raw bytes per track.
+	static const int SIZE = 6250;
+
+	struct Sector
+	{
+		int addrIdx;
+		int dataIdx;
+		byte track;
+		byte head;
+		byte sector;
+		byte sizeCode;
+		bool deleted;
+		bool addrCrcErr;
+		bool dataCrcErr;
+	};
+
+	/* Construct a (cleared) track. */
+	RawTrack();
+
+	/** Clear track data. */
+	void clear();
+
+	void addIdam(int idx);
+
+	// In the methods below, 'index' is allowed to be 'out-of-bounds',
+	// it will wrap like in a circular buffer.
+
+	byte read(int idx) const { return data[idx % SIZE]; }
+	void write(int idx, byte val) { data[idx % SIZE] = val; }
+
+	/** Get info on all sectors in this track. */
+	std::vector&lt;Sector&gt; decodeAll() const;
+
+	/** Get the next sector (starting from a certain index). */
+	bool decodeNextSector(int startIdx, Sector&amp; sector) const;
+
+	/** Get a sector with a specific number.
+	  * Note that if a sector with the same number occurs multiple times,
+	  * this method will always return the same (the first) sector. So
+	  * don't use it in the implementation of FDC / DiskDrive code.
+	  */
+	bool decodeSector(byte sectorNum, Sector&amp; sector) const;
+
+	/** Like memcpy() but copy from/to circular buffer. */
+	void readBlock (int idx, unsigned size, byte* destination) const;
+	void writeBlock(int idx, unsigned size, const byte* source);
+
+	/** Convenience method to calculate CRC for part of this track. */
+	word calcCrc(int idx, int length) const;
+
+	template&lt;typename Archive&gt;
+	void serialize(Archive&amp; ar, unsigned version);
+
+private:
+	bool decodeSector(int idx, Sector&amp; sector) const;
+
+	// Index into 'data'-array to positions where an address mark
+	// starts (it points to the 'FE' byte in the 'A1 A1 A1 FE ..'
+	// sequence.
+	std::vector&lt;int&gt; idam;
+
+	// MFM-decoded raw data, this does NOT include the missing clock
+	// transitions that can occur in the encodings of the 'A1' and
+	// 'C2' bytes.
+	byte data[SIZE];
+};
+
+} // namespace openmsx
+
+#endif

Modified: openmsx/trunk/src/fdc/node.mk
===================================================================
--- openmsx/trunk/src/fdc/node.mk	2012-03-24 11:40:08 UTC (rev 12440)
+++ openmsx/trunk/src/fdc/node.mk	2012-03-24 16:34:07 UTC (rev 12441)
@@ -20,6 +20,7 @@
 	DiskFactory \
 	DriveMultiplexer \
 	Disk \
+	RawTrack \
 	DiskName \
 	SectorBasedDisk \
 	DummyDisk \

Modified: openmsx/trunk/src/utils/CRC16.cc
===================================================================
--- openmsx/trunk/src/utils/CRC16.cc	2012-03-24 11:40:08 UTC (rev 12440)
+++ openmsx/trunk/src/utils/CRC16.cc	2012-03-24 16:34:07 UTC (rev 12441)
@@ -43,19 +43,14 @@
 } // namespace openmsx
 
 #if 0
-using openmsx::CRC16;
-int main(int argc, char** argv)
+#include &lt;cassert&gt;
+int main()
 {
-	CRC16 crc1;
-	assert(crc1.getValue() == 0xFFFF);
-	crc1.update(0xA1);
-	crc1.update(0xA1);
-	crc1.update(0xA1);
-	assert(crc1.getValue() == 0xCDB4);
-
-	CRC16 crc2;
-	byte test[3] = { 0xA1, 0xA1, 0xA1 };
-	crc2.update(test, 3);
-	assert(crc2.getValue() == 0xCDB4);
+	openmsx::CRC16 crc;
+	assert(crc.getValue() == 0xFFFF);
+	crc.update(0xA1);
+	crc.update(0xA1);
+	crc.update(0xA1);
+	assert(crc.getValue() == 0xCDB4);
 }
 #endif

Modified: openmsx/trunk/src/utils/CRC16.hh
===================================================================
--- openmsx/trunk/src/utils/CRC16.hh	2012-03-24 11:40:08 UTC (rev 12440)
+++ openmsx/trunk/src/utils/CRC16.hh	2012-03-24 16:34:07 UTC (rev 12441)
@@ -18,6 +18,13 @@
 	 */
 	explicit CRC16(word initialCRC = 0xFFFF)
 	{
+		init(initialCRC);
+	}
+
+	/** (Re)initialize the current value
+	 */
+	void init(word initialCRC)
+	{
 		crc = initialCRC;
 	}
 
@@ -28,15 +35,6 @@
 		crc = (crc &lt;&lt; 8) ^ CRC16Table[(crc &gt;&gt; 8) ^ value];
 	}
 
-	/** Update CRC with a buffer of bytes
-	 */
-	void update(byte* values, int num)
-	{
-		while (num--) {
-			update(*values++);
-		}
-	}
-
 	/** Get current CRC value
 	 */
 	word getValue() const

This was sent by the SourceForge.net collaborative development platform, the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg29030883">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29030883/">[openMSX-commits] SF.net SVN: openmsx:[12440]
	openmsx/trunk/doc/manual/compile.html</a></b></div>
      
      <small>From: &lt;mthuurne@us...&gt; - 2012-03-24 11:40:20</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12440
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12440&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12440&amp;view=rev</a>
Author:   mthuurne
Date:     2012-03-24 11:40:08 +0000 (Sat, 24 Mar 2012)
Log Message:
-----------
Updated build instructions for Mac OS X and clang.

Modified Paths:
--------------
    openmsx/trunk/doc/manual/compile.html

Modified: openmsx/trunk/doc/manual/compile.html
===================================================================
--- openmsx/trunk/doc/manual/compile.html	2012-03-24 11:01:12 UTC (rev 
12439)
+++ openmsx/trunk/doc/manual/compile.html	2012-03-24 11:40:08 UTC (rev 
12440)
@@ -140,15 +140,14 @@
 make sure you install a version from the 2.x series. Eventually Python 
will
 replace Make completely in our build system, but at the moment both are
 required. Note: on Windows 7 you may have to add the path to Python 
(e.g. &lt;code&gt;C:\Python26&lt;/code&gt;) to your 
&lt;code&gt;PATH&lt;/code&gt; manually.&lt;/dd&gt;
-&lt;dt&gt;There are two compilers that are can be used to build 
openMSX: gcc
-and Visual C++. The gcc compiler builds openMSX on all supported 
platforms,
-while Visual C++ is the primary compiler for Windows.&lt;/dt&gt;
+&lt;dt&gt;There are three compilers that are supported to build 
openMSX: GCC, clang
+and Visual C++. The GCC compiler builds openMSX on all supported 
platforms, clang is the default on Mac OS X, while Visual C++ is the 
primary compiler for Windows.&lt;/dt&gt;
 
 &lt;/dl&gt;
 
-&lt;h4&gt;gcc&lt;/h4&gt;
+&lt;h4&gt;GCC&lt;/h4&gt;
 
-&lt;p&gt;For compilation with gcc, you need GNU Make and g++:&lt;/p&gt;
+&lt;p&gt;For compilation with GCC, you need GNU Make and g++:&lt;/p&gt;
 
 &lt;dl&gt;
 
@@ -164,19 +163,6 @@
 
 &lt;/dl&gt;
 
-&lt;h5&gt;Mac OS X&lt;/h5&gt;
-
-&lt;p&gt;
-Install Xcode from Apple, which you can find on the Mac OS X 
installation DVD or download from the &lt;a class="external" href="<a href="http://developer.apple.com/support/xcode/%22%3EApple" rel="nofollow">http://developer.apple.com/support/xcode/"&gt;Apple</a>
 Developer Connection&lt;/a&gt; (free registration required).
-The Xcode package contains up-to-date versions of Make, GCC and SVN. 
Make sure you also install support for compiling for Mac OS X 10.4 
(Tiger), which is an optional component.
-&lt;/p&gt;
-&lt;p&gt;
-If you want to do a 64-bit Intel build, you can use either Xcode 3 or 
4. If you want to do a universal build or a 32-bit Intel or PowerPC 
build, you need Xcode 3. If you already have Xcode 4 installed, install 
Xcode 3 into a separate directory, for example 
&lt;code&gt;/Developer/Xcode3&lt;/code&gt;; this allows version 3 and 4 
to co-exist.
-&lt;/p&gt;
-&lt;p&gt;
-By default openMSX assumes Xcode 4 installed in 
&lt;code&gt;/Developer&lt;/code&gt; and Xcode 3 installed in 
&lt;code&gt;/Developer/Xcode3&lt;/code&gt;. If the installation paths 
you used are different, please modify &lt;code&gt;SDK_PATH&lt;/code&gt; 
in &lt;code&gt;build/platform-darwin.mk&lt;/code&gt; in the openMSX 
source tree accordingly.
-&lt;/p&gt;
-
 &lt;h5&gt;Microsoft Windows&lt;/h5&gt;
 
 &lt;p&gt;You need to install MinGW (with MSYS).&lt;/p&gt;
@@ -194,6 +180,14 @@
 href="<a href="http://www.treewalker.org/opendingux/%22%3EOpenDingux" rel="nofollow">http://www.treewalker.org/opendingux/"&gt;OpenDingux</a>
 Releases&lt;/a&gt; page.
 &lt;/p&gt;
 
+&lt;h4&gt;clang&lt;/h4&gt;
+
+&lt;h5&gt;Mac OS X&lt;/h5&gt;
+
+&lt;p&gt;
+Install Xcode from Apple, which you can find in the Mac App Store. 
Start Xcode and from the menu select Xcode &amp;gt; Preferences... 
&amp;gt; Downloads and install the "Command Line Tools" component. The 
openMSX build is not done inside the Xcode IDE, but it uses the SDK and 
command line tools that are provided by Xcode.
+&lt;/p&gt;
+
 &lt;h4&gt;Visual C++&lt;/h4&gt;
 
 &lt;p&gt;There are three different ways to obtain the Visual C++ 
compiler:&lt;/p&gt;
@@ -283,7 +277,7 @@
 
 &lt;/dl&gt;
 
-&lt;h4&gt;gcc&lt;/h4&gt;
+&lt;h4&gt;GCC / clang&lt;/h4&gt;
 &lt;p&gt;
 You can install the required libraries systemwide, or you can use the 
"3rd party libraries" support in the openMSX build system and build a 
stand-alone binary. Systemwide is recommended if you run a modular 
operating system (such as Linux, BSD or Mac OS X with MacPorts or Fink) 
and you intend to only use the openMSX binary on your computer. The 3rd 
party library system is recommended if you build for other operating 
systems (Windows, plain Mac OS X or embedded systems) or if you want to 
build a binary that can be used on other computers besides your own. If 
you choose the latter, please skip to the &lt;a class="internal" 
href="#standalone"&gt;Stand-alone Binary&lt;/a&gt; chapter.
 &lt;/p&gt;
@@ -456,7 +450,7 @@
 
 &lt;p&gt;In TortoiseSVN, use &lt;code&gt;<a href="https://openmsx.svn.sourceforge.net/svnroot/openmsx/openmsx/trunk%3C/code%3E" rel="nofollow">https://openmsx.svn.sourceforge.net/svnroot/openmsx/openmsx/trunk&lt;/code&gt;</a>;
 as
 the "URL of repository&amp;quot; and the directory of your choice as 
the "Checkout directory". Use the &lt;code&gt;HEAD&lt;/code&gt; revision
 and click OK.
-When compiling openMSX on Windows with gcc, it's often convenient to 
use 
&lt;code&gt;C:\MinGW\msys\1.0\home\&amp;lt;username&amp;gt;\openMSX&lt;/code&gt;
+When
 compiling openMSX on Windows with GCC, it's often convenient to use 
&lt;code&gt;C:\MinGW\msys\1.0\home\&amp;lt;username&amp;gt;\openMSX&lt;/code&gt;

 as the checkout directory, as this is easy to reach from your MinGW 
Shell - it's
 your MinGW home directory.
 &lt;/p&gt;
@@ -501,8 +495,9 @@
 Now that all the necessary tools and libraries are installed,
 you are almost ready to start the actual compilation of openMSX.
 &lt;/p&gt;
-&lt;h4&gt;gcc&lt;/h4&gt;
 
+&lt;h4&gt;GCC&lt;/h4&gt;
+
 &lt;p&gt;
 The first thing you may want to know is that you can build openMSX in
 different flavours. The default flavour depends on the CPU, but is 
always one that is optimized for performance. For example for x86 
processors the default
@@ -587,13 +582,18 @@
 Make sure you provide us with the error message you got.
 &lt;/p&gt;
 
-&lt;h5&gt;Mac OS X&lt;/h5&gt;
+&lt;h4&gt;clang&lt;/h4&gt;
 
+&lt;h5&gt;Linux and BSD&lt;/h5&gt;
+
 &lt;p&gt;
-By default, openMSX is compiled for the type of CPU that is present in 
your Mac. If you want to build for a different CPU, use 
&lt;code&gt;export OPENMSX_TARGET_CPU=ppc&lt;/code&gt; (PowerPC), 
&lt;code&gt;export OPENMSX_TARGET_CPU=x86&lt;/code&gt; (32-bit Intel) or
 &lt;code&gt;export OPENMSX_TARGET_CPU=x86_64&lt;/code&gt; (64-bit 
Intel). If you want to build a universal binary, use &lt;code&gt;export 
OPENMSX_TARGET_CPU=univ&lt;/code&gt;.
+Add &lt;code&gt;CXX=clang++&lt;/code&gt; as an argument to the 
&lt;code&gt;make&lt;/code&gt; command to select clang as the compiler 
instead of GCC.
 &lt;/p&gt;
+
+&lt;h5&gt;Mac OS X&lt;/h5&gt;
+
 &lt;p&gt;
-If you have a G4 or better PPC CPU, using &lt;code&gt;export 
OPENMSX_FLAVOUR=ppcg4&lt;/code&gt; may give you a faster openMSX 
executable.
+By default, openMSX is compiled for the type of CPU that is present in 
your Mac. If you want to build for a different CPU, use 
&lt;code&gt;export OPENMSX_TARGET_CPU=x86&lt;/code&gt; (32-bit Intel) or
 &lt;code&gt;export OPENMSX_TARGET_CPU=x86_64&lt;/code&gt; (64-bit 
Intel). If you want to build a universal binary, use &lt;code&gt;export 
OPENMSX_TARGET_CPU=univ&lt;/code&gt;. Note that the 64-bit version needs
 OS X 10.6 or later to run, while the 32-bit version can run on OS X 
10.4 or later.
 &lt;/p&gt;
 
 &lt;h4&gt;Visual C++&lt;/h4&gt;
@@ -603,8 +603,10 @@
 dynamically link against import libraries, this is not currently 
supported.&lt;/p&gt;
 &lt;h3&gt;&lt;a id="installlocal"&gt;4.2 
Installation&lt;/a&gt;&lt;/h3&gt;
 
-&lt;h4&gt;gcc&lt;/h4&gt;
+&lt;h4&gt;GCC / clang&lt;/h4&gt;
 
+&lt;h5&gt;Linux and BSD&lt;/h5&gt;
+
 &lt;p&gt;
 To install openMSX, run the following command:
 &lt;/p&gt;
@@ -647,7 +649,7 @@
 
 &lt;h3&gt;&lt;a id="compilestandalone"&gt;5.1 
Compilation&lt;/a&gt;&lt;/h3&gt;
 
-&lt;h4&gt;gcc&lt;/h4&gt;
+&lt;h4&gt;GCC / clang&lt;/h4&gt;
 &lt;p&gt;
 If you want to change something about this process, for example switch 
to a newer library release, edit the 
&lt;code&gt;build/3rdparty.mk&lt;/code&gt; Makefile.
 &lt;/p&gt;
@@ -676,7 +678,7 @@
 
 &lt;p&gt;
 Here's the very short version if you want quick results on Microsoft 
Windows
-with gcc:
+with GCC:
 &lt;/p&gt;
 &lt;ul&gt;
 &lt;li&gt;Open a MinGW Shell&lt;/li&gt;
@@ -859,25 +861,16 @@
 &lt;h5&gt;Mac OS X&lt;/h5&gt;
 
 &lt;p&gt;
-By default openMSX will not be in your search path.
-So to start it, you will have to specify the full path on the command 
line.
-For example:
+You can run the openMSX application folder from Finder or from the 
command line:
 &lt;/p&gt;
 &lt;div class="commandline"&gt;
-/opt/openMSX/bin/openmsx
+open 
derived/&amp;lt;cpu&amp;gt;-darwin-&amp;lt;flavour&amp;gt;-3rd/bindist/openMSX.app

 &lt;/div&gt;
 
 &lt;p&gt;
-If you built an application folder, you can run it from Finder or from 
the command line:
+We do not have a finished GUI yet that works on Mac OS X, so you can 
either use openMSX from the command line for now, or use third party 
software like &lt;a class="external" href="<a href="http://nekocan.sitemix.jp/?page_id=17%22%3ENekoLauncher" rel="nofollow">http://nekocan.sitemix.jp/?page_id=17"&gt;NekoLauncher</a>
 openMSX&lt;/a&gt;.
 &lt;/p&gt;
-&lt;div class="commandline"&gt;
-open 
derived/&amp;lt;cpu&amp;gt;-darwin-app-&amp;lt;flavour&amp;gt;/bindist/openMSX.app
-&lt;/div&gt;

 
-&lt;p&gt;
-We do not have a finished GUI yet that works on Mac OS X, so you can 
either use openMSX from the command line for now, or use third party 
software like &lt;a class="external" href="<a href="http://nekocan.sitemix.jp/?page_id=17%22%3ENekolauncher" rel="nofollow">http://nekocan.sitemix.jp/?page_id=17"&gt;Nekolauncher</a> openMSX&lt;/a&gt; or &lt;a class="external" href="<a href="http://cesco.it/il-mio-software-gratuito/openmsx-peashooter/%22%3EopenMSX" rel="nofollow">http://cesco.it/il-mio-software-gratuito/openmsx-peashooter/"&gt;openMSX</a> Peashooter&lt;/a&gt;.
-&lt;/p&gt;
-
 &lt;h5&gt;Microsoft Windows&lt;/h5&gt;
 
 &lt;p&gt;
@@ -931,7 +924,7 @@
 bug or request.
 &lt;/p&gt;
 
-&lt;h4&gt;gcc&lt;/h4&gt;&lt;p&gt;For experienced users: if you get a crash or a hang,
+&lt;h4&gt;GCC / clang&lt;/h4&gt;&lt;p&gt;For experienced users: if you get a crash or a hang,
 try to provide a &lt;code&gt;gdb&lt;/code&gt; backtrace.
 This will only work if you did not strip the openMSX binary
 of its debug symbols.&lt;/p&gt;

This was sent by the SourceForge.net collaborative development platform, the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg29030768">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29030768/">[openMSX-commits] SF.net SVN: openmsx:[12439] openmsx/trunk/build</a></b></div>
      
      <small>From: &lt;mthuurne@us...&gt; - 2012-03-24 11:01:24</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12439
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12439&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12439&amp;view=rev</a>
Author:   mthuurne
Date:     2012-03-24 11:01:12 +0000 (Sat, 24 Mar 2012)
Log Message:
-----------
For Mac OS X, switch to clang as the compiler and drop PPC support. PPC 
support was already tricky on OS X 10.6, doing it on 10.7 would be too 
much of a hassle. Also updated SDK path to use Xcode from the Mac App 
Store.

Modified Paths:
--------------
    openmsx/trunk/build/main.mk
    openmsx/trunk/build/platform-darwin.mk

Modified: openmsx/trunk/build/main.mk
===================================================================
--- openmsx/trunk/build/main.mk	2012-03-21 21:02:19 UTC (rev 12438)
+++ openmsx/trunk/build/main.mk	2012-03-24 11:01:12 UTC (rev 12439)
@@ -140,10 +140,7 @@
 
 # List of CPUs to compile for.
 ifeq ($(OPENMSX_TARGET_CPU),univ)
-CPU_LIST:=ppc x86
-ifeq ($(shell $(PYTHON) -c 'from platform import mac_ver ; print 
tuple(int(n) for n in mac_ver()[0].split(".")) &gt;= (10, 6)'),True)
-CPU_LIST+=x86_64
-endif
+CPU_LIST:=x86 x86_64
 else
 CPU_LIST:=$(OPENMSX_TARGET_CPU)
 endif

Modified: openmsx/trunk/build/platform-darwin.mk
===================================================================
--- openmsx/trunk/build/platform-darwin.mk	2012-03-21 21:02:19 UTC (rev 
12438)
+++ openmsx/trunk/build/platform-darwin.mk	2012-03-24 11:01:12 UTC (rev 
12439)
@@ -34,27 +34,14 @@
 TARGET_FLAGS+=-mmacosx-version-min=$(OSX_MIN_VER)
 
 # Select the SDK to use. This can be higher than the OS X minimum 
version.
-ifeq ($(OPENMSX_TARGET_CPU),x86_64)
-SDK_PATH:=/Developer/SDKs/MacOSX10.6.sdk
-else
-# Note: Xcode 4.2 does not include PPC support in all of its dylibs, so
 when
-#       building a PPC/universal binary we must use the SDK from Xcode 
3.
-#       If you have Xcode 3 installed in its default location 
(/Developer),
-#       please remove the "Xcode3" part of the SDK_PATH definition 
below.
-SDK_PATH:=/Developer/Xcode3/SDKs/MacOSX10.6.sdk
-endif
+SDK_PATH:=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.6.sdk/
+#
 The path above is for Xcode from the Mac App Store. If you're using the
 older
+# stand-alone Xcode, this is the right path:
+#SDK_PATH:=/Developer/SDKs/MacOSX10.6.sdk
 TARGET_FLAGS+=-isysroot $(SDK_PATH)
 
-# Select an appropriate GCC version.
-ifeq ($(OPENMSX_TARGET_CPU),x86_64)
-CXX:=g++-4.2
-else
-# GCC from Xcode 4.2 fails to link PPC binaries, so use GCC from Xcode 
3.
-# GCC 4.2 on PPC and x86 uses a ridiculous amount of memory (about 7 
GB)
-# and will therefore never finish in a reasonable amount of time if the
 build
-# machine has 4 GB of memory or less. GCC 4.0 does not have this 
problem.
-CXX:=$(SDK_PATH)/../../usr/bin/g++-4.0
-endif
+# Select clang as the compiler.
+CXX:=clang++
 
 ifeq ($(filter 3RD_%,$(LINK_MODE)),)
 # Compile against local libs. We assume the binary is intended to be 
run on

This was sent by the SourceForge.net collaborative development platform,
 the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg29018120">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29018120/">[openMSX-commits] SF.net SVN: openmsx:[12438]
	openmsx/trunk/src/console/OSDConsoleRenderer.cc</a></b></div>
      
      <small>From: &lt;manuelbi@us...&gt; - 2012-03-21 21:02:25</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12438
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12438&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12438&amp;view=rev</a>
Author:   manuelbi
Date:     2012-03-21 21:02:19 +0000 (Wed, 21 Mar 2012)
Log Message:
-----------
Fixed crash when rendering a new line with only a space.

Easiest way to reproduce this issue: type lots of spaces in the console,
when the line wraps you got a crash.

Modified Paths:
--------------
    openmsx/trunk/src/console/OSDConsoleRenderer.cc

Modified: openmsx/trunk/src/console/OSDConsoleRenderer.cc
===================================================================
--- openmsx/trunk/src/console/OSDConsoleRenderer.cc	2012-03-19 21:12:11 UTC (rev 12437)
+++ openmsx/trunk/src/console/OSDConsoleRenderer.cc	2012-03-21 21:02:19 UTC (rev 12438)
@@ -291,10 +291,10 @@
 void OSDConsoleRenderer::drawText(OutputSurface&amp; output, const string&amp; text,
                                   int x, int y, byte alpha)
 {
-	if (text.empty()) return;
 	SDLSurfacePtr surf;
 	try {
 		surf = font-&gt;render(text, 255, 255, 255);
+		if (!surf.get()) return; // nothing was rendered, so do nothing
 	} catch (MSXException&amp; e) {
 		static bool alreadyPrinted = false;
 		if (!alreadyPrinted) {

This was sent by the SourceForge.net collaborative development platform, the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg29007334">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/29007334/">[openMSX-commits] SF.net SVN: openmsx:[12437]
	openmsx/trunk/src/video/scalers/LineScalers.hh</a></b></div>
      
      <small>From: &lt;m9710797@us...&gt; - 2012-03-19 21:12:17</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12437
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12437&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12437&amp;view=rev</a>
Author:   m9710797
Date:     2012-03-19 21:12:11 +0000 (Mon, 19 Mar 2012)
Log Message:
-----------
Fixed assert in SSE/MMX version of some LineScaler routines:

To reproduce:
  - start gfx9000 version of symbos
  - in the configuration screen switch to 768x240

The crash occured in the SSE version of the scale_2on1 routine. That routine
assumed that it could always work on a multiple of 4 pixels (so that the
MMX/SSE instructions can do aligned/full-word accesses). Usually this is the
case except for gfx9000-overscan modes in combination with the sdlgl-pp
renderer.

Fixed by extending the asm routines to do the initial part in asm and the last
few pixels with the slower c++ version of the routine.

Modified Paths:
--------------
    openmsx/trunk/src/video/scalers/LineScalers.hh

Modified: openmsx/trunk/src/video/scalers/LineScalers.hh
===================================================================
--- openmsx/trunk/src/video/scalers/LineScalers.hh	2012-03-16 23:38:31 UTC (rev 12436)
+++ openmsx/trunk/src/video/scalers/LineScalers.hh	2012-03-19 21:12:11 UTC (rev 12437)
@@ -439,12 +439,26 @@
 void Scale_1on2&lt;Pixel, streaming&gt;::operator()(
 	const Pixel* __restrict in, Pixel* __restrict out, unsigned long width) __restrict
 {
+	unsigned long width2 = 0;
+
 	#if ASM_X86
 	const HostCPU&amp; cpu = HostCPU::getInstance();
-	#ifndef _MSC_VER
+
+	#ifdef _MSC_VER
+
+	if ((sizeof(Pixel) == 4) &amp;&amp; cpu.hasMMX()) {
+		// MMX routine 32bpp
+		width2 = width &amp; ~15;
+		assert(((2 * width2) % 32) == 0);
+		Scale_1on2_4_MMX(in, out, width2);
+	}
+
+	#else
+
 	if ((sizeof(Pixel) == 2) &amp;&amp; streaming &amp;&amp; cpu.hasSSE()) {
 		// extended-MMX routine 16bpp
-		assert((width % 32) == 0);
+		width2 = width &amp; ~31;
+		assert((width2 % 32) == 0);
 		asm (
 			".p2align 4,,15;"
 		"0:"
@@ -481,20 +495,19 @@
 			"emms;"
 
 			: // no output
-			: "r" (in  + width / 2) // 0
-			, "r" (out + width) // 1
-			, "r" (-width) // 2
+			: "r" (in  + width2 / 2) // 0
+			, "r" (out + width2) // 1
+			, "r" (-width2) // 2
 			#ifdef __MMX__
 			: "mm0", "mm1", "mm2", "mm3",
 			  "mm4", "mm5", "mm6", "mm7"
 			#endif
 		);
-		return;
-	}
 
-	if ((sizeof(Pixel) == 2) &amp;&amp; cpu.hasMMX()) {
+	} else if ((sizeof(Pixel) == 2) &amp;&amp; cpu.hasMMX()) {
 		// MMX routine 16bpp
-		assert((width % 32) == 0);
+		width2 = width &amp; ~31;
+		assert((width2 % 32) == 0);
 		asm (
 			".p2align 4,,15;"
 		"0:"
@@ -531,20 +544,19 @@
 			"emms;"
 
 			: // no output
-			: "r" (in  + width / 2) // 0
-			, "r" (out + width) // 1
-			, "r" (-width) // 2
+			: "r" (in  + width2 / 2) // 0
+			, "r" (out + width2) // 1
+			, "r" (-width2) // 2
 			#ifdef __MMX__
 			: "mm0", "mm1", "mm2", "mm3",
 			  "mm4", "mm5", "mm6", "mm7"
 			#endif
 		);
-		return;
-	}
 
-	if ((sizeof(Pixel) == 4) &amp;&amp; streaming &amp;&amp; cpu.hasSSE()) {
+	} else if ((sizeof(Pixel) == 4) &amp;&amp; streaming &amp;&amp; cpu.hasSSE()) {
 		// extended-MMX routine 32bpp
-		assert(((2 * width) % 32) == 0);
+		width2 = width &amp; ~15;
+		assert(((2 * width2) % 32) == 0);
 		asm (
 			".p2align 4,,15;"
 		"0:"
@@ -581,23 +593,19 @@
 			"emms;"
 
 			: // no output
-			: "r" (in  + width / 2) // 0
-			, "r" (out + width) // 1
-			, "r" (-2 * width) // 2
+			: "r" (in  + width2 / 2) // 0
+			, "r" (out + width2) // 1
+			, "r" (-2 * width2) // 2
 			#ifdef __MMX__
 			: "mm0", "mm1", "mm2", "mm3",
 			  "mm4", "mm5", "mm6", "mm7"
 			#endif
 		);
-		return;
-	}
-	#endif
-	if ((sizeof(Pixel) == 4) &amp;&amp; cpu.hasMMX()) {
+
+	} else if ((sizeof(Pixel) == 4) &amp;&amp; cpu.hasMMX()) {
 		// MMX routine 32bpp
-		assert(((2 * width) % 32) == 0);
-	#ifdef _MSC_VER
-		Scale_1on2_4_MMX(in, out, width);
-	#else
+		width2 = width &amp; ~15;
+		assert(((2 * width2) % 32) == 0);
 		asm (
 			".p2align 4,,15;"
 		"0:"
@@ -634,19 +642,23 @@
 			"emms;"
 
 			: // no output
-			: "r" (in  + width / 2) // 0
-			, "r" (out + width) // 1
-			, "r" (-2 * width) // 2
+			: "r" (in  + width2 / 2) // 0
+			, "r" (out + width2) // 1
+			, "r" (-2 * width2) // 2
 			#ifdef __MMX__
 			: "mm0", "mm1", "mm2", "mm3",
 			  "mm4", "mm5", "mm6", "mm7"
 			#endif
 		);
-	#endif
-		return;
 	}
+
 	#endif
+	#endif
 
+	in += width2;
+	out += width2;
+	width -= width2;
+
 	for (unsigned x = 0; x &lt; width / 2; x++) {
 		out[x * 2] = out[x * 2 + 1] = in[x];
 	}
@@ -657,16 +669,24 @@
 	const Pixel* __restrict in, Pixel* __restrict out, unsigned long width) __restrict
 {
 	unsigned long nBytes = width * sizeof(Pixel);
+	unsigned long nBytes2 = 0;
+
 	#if ASM_X86
-	assert((nBytes % 64) == 0);
+
+	nBytes2 = nBytes &amp; ~63;
+	assert((nBytes2 % 64) == 0);
 	const HostCPU&amp; cpu = HostCPU::getInstance();
+
+	#ifdef _MSC_VER
+
 	if (streaming &amp;&amp; cpu.hasSSE()) {
 		// extended-MMX routine (both 16bpp and 32bpp)
-	#ifdef _MSC_VER
-		Scale_1on1_SSE(in, out, nBytes);
-		return;
+		Scale_1on1_SSE(in, out, nBytes2);
 	}
+
 	#else
+
+	if (streaming &amp;&amp; cpu.hasSSE()) {
 		asm (
 			".p2align 4,,15;"
 		"0:"
@@ -694,18 +714,16 @@
 			"emms;"
 
 			: // no output
-			: "r" (reinterpret_cast&lt;const char*&gt;(in)  + nBytes) // 0
-			, "r" (reinterpret_cast&lt;char*      &gt;(out) + nBytes) // 1
-			, "r" (-nBytes) // 2
+			: "r" (reinterpret_cast&lt;const char*&gt;(in)  + nBytes2) // 0
+			, "r" (reinterpret_cast&lt;char*      &gt;(out) + nBytes2) // 1
+			, "r" (-nBytes2) // 2
 			#ifdef __MMX__
 			: "mm0", "mm1", "mm2", "mm3",
 			  "mm4", "mm5", "mm6", "mm7"
 			#endif
 		);
-		return;
-	}
 
-	if (cpu.hasMMX()) {
+	} else if (cpu.hasMMX()) {
 		// MMX routine (both 16bpp and 32bpp)
 		asm (
 			".p2align 4,,15;"
@@ -734,22 +752,23 @@
 			"emms;"
 
 			: // no output
-			: "r" (reinterpret_cast&lt;const char*&gt;(in)  + nBytes) // 0
-			, "r" (reinterpret_cast&lt;char*      &gt;(out) + nBytes) // 1
-			, "r" (-nBytes) // 2
+			: "r" (reinterpret_cast&lt;const char*&gt;(in)  + nBytes2) // 0
+			, "r" (reinterpret_cast&lt;char*      &gt;(out) + nBytes2) // 1
+			, "r" (-nBytes2) // 2
 			#ifdef __MMX__
 			: "mm0", "mm1", "mm2", "mm3",
 			  "mm4", "mm5", "mm6", "mm7"
 			#endif
 		);
-		return;
 	}
+
 	#endif
 	#endif
 
 #ifdef __arm__
-	assert(nBytes &gt; 0);
-	assert((nBytes % 64) == 0);
+	nBytes2 = nBytes &amp; ~63;
+	assert(nBytes2 &gt; 0);
+	assert((nBytes2 % 64) == 0);
 	assert((long(in)  &amp; 3) == 0);
 	assert((long(out) &amp; 3) == 0);
 
@@ -763,15 +782,19 @@
 		"bne	0b;\n\t"
 
 		: // no output
-		: "r" (nBytes)
+		: "r" (nBytes2)
 		, "r" (in)
 		, "r" (out)
 		: "r0","r1","r2","r3","r4","r5","r6","r8"
 	);
-	return;
 #endif
 
-	memcpy(out, in, nBytes);
+	      char* out2 = reinterpret_cast&lt;      char*&gt;(out) + nBytes2;
+	const char* in2  = reinterpret_cast&lt;const char*&gt;(in ) + nBytes2;
+	nBytes -= nBytes2;
+	if (nBytes) {
+		memcpy(out2, in2, nBytes);
+	}
 }
 
 
@@ -785,16 +808,27 @@
 void Scale_2on1&lt;Pixel&gt;::operator()(
 	const Pixel* __restrict in, Pixel* __restrict out, unsigned long width) __restrict
 {
+	unsigned long width2 = 0;
+
 	#if ASM_X86
+
 	const HostCPU&amp; cpu = HostCPU::getInstance();
+
+	#ifdef _MSC_VER
+
 	if ((sizeof(Pixel) == 4) &amp;&amp; cpu.hasSSE()) {
 		// extended-MMX routine, 32bpp
-		assert(((4 * width) % 16) == 0);
-	#ifdef _MSC_VER
-		Scale_2on1_SSE(in, out, width);
-		return;
+		width2 = width &amp; ~3;
+		assert(((4 * width2) % 16) == 0);
+		Scale_2on1_SSE(in, out, width2);
 	}
+
 	#else
+
+	if ((sizeof(Pixel) == 4) &amp;&amp; cpu.hasSSE()) {
+		// extended-MMX routine, 32bpp
+		width2 = width &amp; ~3;
+		assert(((4 * width2) % 16) == 0);
 		asm volatile (
 			".p2align 4,,15;"
 		"0:"
@@ -817,18 +851,18 @@
 			"emms;"
 
 			: // no output
-			: "r" (in  + 2 * width) // 0
-			, "r" (out +     width) // 1
-			, "r" (-4 * width)      // 2
+			: "r" (in  + 2 * width2) // 0
+			, "r" (out +     width2) // 1
+			, "r" (-4 * width2)      // 2
 			#ifdef __MMX__
 			: "mm0", "mm1", "mm2", "mm3", "mm4", "mm5"
 			#endif
 		);
-		return;
-	}
-	if ((sizeof(Pixel) == 4) &amp;&amp; cpu.hasMMX()) {
+
+	} else if ((sizeof(Pixel) == 4) &amp;&amp; cpu.hasMMX()) {
 		// MMX routine, 32bpp
-		assert(((4 * width) % 16) == 0);
+		width2 = width &amp; ~3;
+		assert(((4 * width2) % 16) == 0);
 		asm volatile (
 			"pxor	%%mm7, %%mm7;"
 			".p2align 4,,15;"
@@ -866,19 +900,19 @@
 			"emms;"
 
 			: // no output
-			: "r" (in  + 2 * width) // 0
-			, "r" (out +     width) // 1
-			, "r" (-4 * width)      // 2
+			: "r" (in  + 2 * width2) // 0
+			, "r" (out +     width2) // 1
+			, "r" (-4 * width2)      // 2
 			#ifdef __MMX__
 			: "mm0", "mm1", "mm2", "mm3"
 			, "mm4", "mm5", "mm6", "mm7"
 			#endif
 		);
-		return;
-	}
-	if ((sizeof(Pixel) == 2) &amp;&amp; cpu.hasSSE()) {
+
+	} else if ((sizeof(Pixel) == 2) &amp;&amp; cpu.hasSSE()) {
 		// extended-MMX routine, 16bpp
-		assert(((2 * width) % 16) == 0);
+		width2 = width &amp; ~7;
+		assert(((2 * width2) % 16) == 0);
 		unsigned mask = ~pixelOps.getBlendMask();
 		mask = ~(mask | (mask &lt;&lt; 16));
 		asm volatile (
@@ -927,20 +961,20 @@
 			"emms;"
 
 			: // no output
-			: "r" (in  + 2 * width) // 0
-			, "r" (out +     width) // 1
+			: "r" (in  + 2 * width2) // 0
+			, "r" (out +     width2) // 1
 			, "r" (mask)             // 2
-			, "r" (-2 * width)      // 3
+			, "r" (-2 * width2)      // 3
 			#ifdef __MMX__
 			: "mm0", "mm1", "mm2", "mm3"
 			, "mm4", "mm5", "mm6", "mm7"
 			#endif
 		);
-		return;
-	}
-	if ((sizeof(Pixel) == 2) &amp;&amp; cpu.hasMMX()) {
+
+	} else if ((sizeof(Pixel) == 2) &amp;&amp; cpu.hasMMX()) {
 		// MMX routine, 16bpp
-		assert(((2 * width) % 16) == 0);
+		width2 = width &amp; ~7;
+		assert(((2 * width2) % 16) == 0);
 		unsigned mask = ~pixelOps.getBlendMask();
 		mask = ~(mask | (mask &lt;&lt; 16));
 		asm volatile (
@@ -989,20 +1023,23 @@
 			"emms;"
 
 			: // no output
-			: "r" (in  + 2 * width) // 0
-			, "r" (out +     width) // 1
+			: "r" (in  + 2 * width2) // 0
+			, "r" (out +     width2) // 1
 			, "r" (mask)             // 2
-			, "r" (-2 * width)      // 3
+			, "r" (-2 * width2)      // 3
 			#ifdef __MMX__
 			: "mm0", "mm1", "mm2", "mm3"
 			, "mm4", "mm5", "mm6", "mm7"
 			#endif
 		);
-		return;
 	}
 	#endif
 	#endif
 
+	in += width2;
+	out += width2;
+	width -= width2;
+
 	// pure C++ version
 	for (unsigned i = 0; i &lt; width; ++i) {
 		out[i] = pixelOps.template blend&lt;1, 1&gt;(

This was sent by the SourceForge.net collaborative development platform, the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
      

<table id="msg28994608">
<tbody><tr>
  <td class="email-header">
    <div>
      <div><b><a href="http://sourceforge.net/p/openmsx/mailman/message/28994608/">[openMSX-commits] SF.net SVN: openmsx:[12436]
	openmsx/trunk/src/utils</a></b></div>
      
      <small>From: &lt;mthuurne@us...&gt; - 2012-03-16 23:38:38</small>
      <div class="attachments">
        <small>
          
        </small>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td class="email-body"><pre>Revision: 12436
          <a href="http://openmsx.svn.sourceforge.net/openmsx/?rev=12436&amp;view=rev" rel="nofollow">http://openmsx.svn.sourceforge.net/openmsx/?rev=12436&amp;view=rev</a>
Author:   mthuurne
Date:     2012-03-16 23:38:31 +0000 (Fri, 16 Mar 2012)
Log Message:
-----------
Specify operation width for x86 inline asm. Without this compilation fails with clang on Mac OS X (x86 only).

Modified Paths:
--------------
    openmsx/trunk/src/utils/DivModByConst.hh
    openmsx/trunk/src/utils/DivModBySame.hh

Modified: openmsx/trunk/src/utils/DivModByConst.hh
===================================================================
--- openmsx/trunk/src/utils/DivModByConst.hh	2012-03-16 20:39:35 UTC (rev 12435)
+++ openmsx/trunk/src/utils/DivModByConst.hh	2012-03-16 23:38:31 UTC (rev 12436)
@@ -222,26 +222,26 @@
 	#else
 		unsigned th, tl, ch, cl;
 		asm (
-			"mov	%[AH],%%eax\n\t"
+			"movl	%[AH],%%eax\n\t"
 			"mull	%[BL]\n\t"
-			"mov	%%eax,%[TL]\n\t"
-			"mov	%%edx,%[TH]\n\t"
-			"mov	%[AL],%%eax\n\t"
+			"movl	%%eax,%[TL]\n\t"
+			"movl	%%edx,%[TH]\n\t"
+			"movl	%[AL],%%eax\n\t"
 			"mull	%[BL]\n\t"
-			"add	%%edx,%[TL]\n\t"
-			"adc	$0,%[TH]\n\t"
+			"addl	%%edx,%[TL]\n\t"
+			"adcl	$0,%[TH]\n\t"
 
-			"mov	%[AH],%%eax\n\t"
+			"movl	%[AH],%%eax\n\t"
 			"mull	%[BH]\n\t"
-			"mov	%%eax,%[CL]\n\t"
-			"mov	%%edx,%[CH]\n\t"
-			"mov	%[AL],%%eax\n\t"
+			"movl	%%eax,%[CL]\n\t"
+			"movl	%%edx,%[CH]\n\t"
+			"movl	%[AL],%%eax\n\t"
 			"mull	%[BH]\n\t"
-			"add	%%eax,%[TL]\n\t"
-			"adc	%%edx,%[TH]\n\t"
-			"adc	$0,%[CH]\n\t"
-			"add	%[TH],%[CL]\n\t"
-			"adc	$0,%[CH]\n\t"
+			"addl	%%eax,%[TL]\n\t"
+			"adcl	%%edx,%[TH]\n\t"
+			"adcl	$0,%[CH]\n\t"
+			"addl	%[TH],%[CL]\n\t"
+			"adcl	$0,%[CH]\n\t"
 
 			: [CH] "=&amp;rm" (ch)
 			, [TH] "=&amp;r"  (th)

Modified: openmsx/trunk/src/utils/DivModBySame.hh
===================================================================
--- openmsx/trunk/src/utils/DivModBySame.hh	2012-03-16 20:39:35 UTC (rev 12435)
+++ openmsx/trunk/src/utils/DivModBySame.hh	2012-03-16 23:38:31 UTC (rev 12436)
@@ -104,15 +104,15 @@
 		unsigned dummy;
 		asm (
 			"mull	%[BL]\n\t"       // eax = [AH]
-			"mov	%%eax,%[TL]\n\t"
-			"mov	%%edx,%[TH]\n\t"
-			"mov	%[AL],%%eax\n\t"
+			"movl	%%eax,%[TL]\n\t"
+			"movl	%%edx,%[TH]\n\t"
+			"movl	%[AL],%%eax\n\t"
 			"mull	%[BL]\n\t"
-			"add	%%eax,%[CL]\n\t"
-			"adc	%%edx,%[CH]\n\t"
-			"adc	$0,%[TH]\n\t"
-			"add	%[CH],%[TL]\n\t"
-			"adc	$0,%[TH]\n\t"
+			"addl	%%eax,%[CL]\n\t"
+			"adcl	%%edx,%[CH]\n\t"
+			"adcl	$0,%[TH]\n\t"
+			"addl	%[CH],%[TL]\n\t"
+			"adcl	$0,%[TH]\n\t"
 
 			: [TH]  "=&amp;rm"  (_th_)
 			, [TL]  "=&amp;r"   (_tl_)
@@ -128,15 +128,15 @@
 		);
 		asm (
 			"mull	%[BH]\n\t"       // eax = [AH]
-			"mov	%%eax,%[CL]\n\t"
-			"mov	%%edx,%[CH]\n\t"
-			"mov	%[AL],%%eax\n\t"
+			"movl	%%eax,%[CL]\n\t"
+			"movl	%%edx,%[CH]\n\t"
+			"movl	%[AL],%%eax\n\t"
 			"mull	%[BH]\n\t"
-			"add	%%eax,%[TL]\n\t"
-			"adc	%%edx,%[TH]\n\t"
-			"adc	$0,%[CH]\n\t"
-			"add	%[TH],%[CL]\n\t"
-			"adc	$0,%[CH]\n\t"
+			"addl	%%eax,%[TL]\n\t"
+			"adcl	%%edx,%[TH]\n\t"
+			"adcl	$0,%[CH]\n\t"
+			"addl	%[TH],%[CL]\n\t"
+			"adcl	$0,%[CH]\n\t"
 
 			: [CH]  "=rm"   (_ch_)
 			, [CL]  "=r"    (_cl_)

This was sent by the SourceForge.net collaborative development platform, the world's largest Open Source development site.



</pre></td>
</tr>
</tbody></table>
    
  
  

  <div class="grid-19 mail-archive-style-switcher">
    <div class="grid-8">
      <form method="get">
  
    <input tabindex="5" name="viewmonth" value="201203" type="hidden">
  
  
  <p><strong>Showing
  
    <select tabindex="6" class="results_per_page" name="limit">
      
          <option selected="selected" value="25">25</option>
      
          <option value="50">50</option>
      
          <option value="100">100</option>
      
          <option value="250">250</option>
      
    </select>
  
  results of 34 </strong></p>
  
</form>
    </div>
    <div class="grid-4 thread-flat-switcher margin-top-10">
      <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203&amp;style=flat">Flat</a> |
      <a href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203&amp;style=threaded">Threaded</a>
    </div>
    <div>
  <div class="page_list">
      <span class="pager_curpage">1</span> <a class="pager_link" href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203&amp;page=1">2</a> <a class="pager_link" href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203&amp;page=1">&gt;</a> <a class="pager_link" href="http://sourceforge.net/p/openmsx/mailman/openmsx-commits/?viewmonth=201203&amp;page=1">&gt;&gt;</a> (Page 1 of 2)
  </div>
  <div class="clear"></div>
</div>
  </div>
  <div style="clear: both;"></div>

                </div>
                
                
            </div>
        
    </div>
</section>
  
<footer id="site-footer">
    <div class="wrapper">
        <nav>
            <h5>SourceForge</h5>
            <a href="http://sourceforge.net/about">About</a>
            <a href="http://sourceforge.net/blog/category/sitestatus/">Site Status</a>
            <a href="http://twitter.com/sfnet_ops">@sfnet_ops</a>
            <a id="allura-notice" href="http://allura.apache.org/">
                <p>Powered by</p>
                <p>Apache Allura™</p>
                <img src="openMSX%20_%20Mailing%20Lists_files/logo-black-svg_g.png">
            </a>
        </nav>
        <nav>
            <h5>Find and Develop Software</h5>
            <a href="http://sourceforge.net/create/">Create a Project</a>
            <a href="http://sourceforge.net/directory/">Software Directory</a>
            <a href="http://sourceforge.net/top">Top Downloaded Projects</a>
        </nav>
        <nav>
            <h5>Community</h5>
            <a href="http://sourceforge.net/blog/">Blog</a>
            <a href="http://twitter.com/sourceforge">@sourceforge</a>
            <a href="http://sourceforge.net/jobs?source=footer">Job Board</a>
            <a href="http://library.slashdotmedia.com/?source=sfnet_footer">Resources</a>
        </nav>
        <nav>
            <h5>Help</h5>
            <a href="http://p.sf.net/sourceforge/docs">Site Documentation</a>
            <a href="http://sourceforge.net/support">Support Request</a>
            <a href="http://p.sf.net/sourceforge/irc">Real-Time Support</a>
        </nav>
    </div>
</footer>
<footer id="site-copyright-footer">
    <div class="wrapper">
        <div id="copyright">
            © 2016 Slashdot Media. All Rights Reserved.<br>
            <div id="dhi-icon"><span class="logo-DHI-alt"></span></div>
            <div id="service-text"><div class="smalltext"> SourceForge is a <a href="http://www.dhigroupinc.com/" target="_blank">DHI service</a></div></div>
        </div>
        <nav>
            <a href="http://slashdotmedia.com/terms-of-use">Terms</a>
            <a href="http://slashdotmedia.com/privacy-statement/">Privacy</a>
            <span consent="null" id="teconsent"><a style="cursor: pointer;" role="button" tabindex="0" id="icon-id05009959671094141">Cookie Preferences</a></span>
            <a href="http://slashdotmedia.com/opt-out-choices">Opt Out Choices</a>
            <a href="http://slashdotmedia.com/">Advertise</a>
        </nav>
    </div>
</footer>
<div style="position: fixed; top: 20px;" id="messages">
    
</div>


    <!-- ew:body_js -->


    <script type="text/javascript" src="openMSX%20_%20Mailing%20Lists_files/js_002"></script>

    
<!-- /ew:body_js -->



    <!-- ew:body_js_tail -->


    <script type="text/javascript">$(function () {
            $('select.results_per_page').change(function () {
                this.form.submit();});});</script>

    
<!-- /ew:body_js_tail -->




    


    <!-- Google Code for Remarketing tag -->
    <!-- Remarketing tags may not be associated with personally identifiable information or placed on pages related to sensitive categories. For instructions on adding this tag and more information on the above requirements, read the setup guide: google.com/ads/remarketingsetup -->
    <script type="text/javascript">
        /* <![CDATA[ */
        var google_conversion_id = 1002083962;
        var google_conversion_label = "G_uGCOaBlAQQ-qzq3QM";
        var google_custom_params = window.google_tag_params;
        var google_remarketing_only = true;
        /* ]]> */
    </script>
    <script type="text/javascript" src="openMSX%20_%20Mailing%20Lists_files/conversion.js"> </script><iframe name="google_conversion_frame" title="Google conversion frame" src="https://googleads.g.doubleclick.net/pagead/viewthroughconversion/1002083962/?random=1451828807299&amp;cv=8&amp;fst=1451828807299&amp;num=1&amp;fmt=1&amp;label=G_uGCOaBlAQQ-qzq3QM&amp;guid=ON&amp;u_h=1080&amp;u_w=1920&amp;u_ah=1080&amp;u_aw=1920&amp;u_cd=24&amp;u_his=3&amp;u_tz=60&amp;u_java=true&amp;u_nplug=25&amp;u_nmime=129&amp;frm=0&amp;url=http%3A//sourceforge.net/p/openmsx/mailman/openmsx-commits/%3Fviewmonth%3D201203&amp;ref=https%3A//www.google.nl" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" frameborder="0" height="13" width="300">&lt;img
 height="1" width="1" border="0" alt="" 
src="https://googleads.g.doubleclick.net/pagead/viewthroughconversion/1002083962/?frame=0&amp;random=1451828807299&amp;cv=8&amp;fst=1451828807299&amp;num=1&amp;fmt=1&amp;label=G_uGCOaBlAQQ-qzq3QM&amp;guid=ON&amp;u_h=1080&amp;u_w=1920&amp;u_ah=1080&amp;u_aw=1920&amp;u_cd=24&amp;u_his=3&amp;u_tz=60&amp;u_java=true&amp;u_nplug=25&amp;u_nmime=129&amp;frm=0&amp;url=http%3A//sourceforge.net/p/openmsx/mailman/openmsx-commits/%3Fviewmonth%3D201203&amp;ref=https%3A//www.google.nl"
 /&gt;</iframe>
    <script id="truste_0.7897582531972956" type="text/javascript" src="openMSX%20_%20Mailing%20Lists_files/get"></script><script async="async" src="openMSX%20_%20Mailing%20Lists_files/notice"></script>
    <noscript>
      <div style="display:inline;">
        <img height="1" width="1" style="border-style:none;" alt="" 
src="//googleads.g.doubleclick.net/pagead/viewthroughconversion/1002083962/?value=0&amp;label=G_uGCOaBlAQQ-qzq3QM&amp;guid=ON&amp;script=0"/>

      </div>
    </noscript>

     
      

<script>
    $(document).ready(function () {
        $(".tooltip").tooltipster({
            animation: 'fade',
            delay: 200,
            theme: 'tooltipster-light',
            trigger: 'hover',
            position: 'right',
            iconCloning: false,
            maxWidth: 300
        }).focus(function () {
            $(this).tooltipster('show');
        }).blur(function () {
            $(this).tooltipster('hide');
        });
    })
</script>

</body></html>